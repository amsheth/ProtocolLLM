{
    "prompt_0": [
        {
            "role": "user",
            "content": "Write a SystemVerilog module to implement a UART (Universal Asynchronous Receiver-Transmitter) controller. The module should support configurable baud rates, transmit and receive functionality, and proper start, data, parity (optional), and stop bit handling. The UART should operate in full-duplex mode and adhere to the following interface:\nmodule UART_driver( input  logic       clk,        // System clock input  logic       rst,        // Asynchronous reset input  logic       UART_Start, // Signal to initiate transmission input  logic [7:0] data_in,    // Data to be transmitted input  logic       RX,         // UART receive line output logic       TX,         // UART transmit line output logic [7:0] data_out,   // Received data output logic       UART_Ready, // Ready to transmit next byte output logic       UART_Busy,  // Indicates UART is currently transmitting output logic       UART_Error  // High if framing or parity error detected ); "
        },
        {
            "role": "assistant",
            "content": "```systemverilog\nmodule UART_driver(\n    input  logic       clk,         // System clock\n    input  logic       rst,         // Asynchronous reset\n    input  logic       UART_Start,  // Signal to initiate transmission\n    input  logic [7:0] data_in,     // Data to be transmitted\n    input  logic       RX,          // UART receive line\n    output logic       TX,          // UART transmit line\n    output logic [7:0] data_out,    // Received data\n    output logic       UART_Ready,  // Ready to transmit next byte\n    output logic       UART_Busy,   // Indicates UART is currently transmitting\n    output logic       UART_Error   // High if framing or parity error detected\n);\n\n    // === Configurable Parameters ===\n    parameter BAUD_RATE    = 115200;   // Baud rate\n    parameter CLK_FREQ     = 50000000; // System clock frequency (Hz)\n    parameter PARITY_EN    = 0;        // 0: No parity, 1: Even parity, 2: Odd parity\n\n    // === Local Parameters ===\n    localparam integer BAUD_DIV = CLK_FREQ / BAUD_RATE;\n\n    // === Transmitter Signals ===\n    typedef enum logic [1:0] {TX_IDLE, TX_START, TX_DATA, TX_PARITY, TX_STOP} tx_state_t;\n    tx_state_t tx_state, tx_state_next;\n    logic [15:0] tx_baud_cnt;\n    logic [3:0]  tx_bit_cnt;\n    logic [7:0]  tx_shift_reg;\n    logic        tx_parity_bit;\n    logic        tx_busy, tx_ready;\n    logic        tx_line;\n\n    // === Receiver Signals ===\n    typedef enum logic [2:0] {RX_IDLE, RX_START, RX_DATA, RX_PARITY, RX_STOP, RX_ERROR} rx_state_t;\n    rx_state_t rx_state, rx_state_next;\n    logic [15:0] rx_baud_cnt;\n    logic [3:0]  rx_bit_cnt;\n    logic [7:0]  rx_shift_reg;\n    logic        rx_parity_bit;\n    logic        rx_sampled_bit;\n    logic        rx_error;\n    logic        rx_ready;\n    logic [7:0]  rx_data_out;\n\n    // === Assign Outputs ===\n    assign TX         = tx_line;\n    assign UART_Ready = tx_ready;\n    assign UART_Busy  = tx_busy;\n    assign UART_Error = rx_error;\n    assign data_out   = rx_data_out;\n\n    // === Transmitter Logic ===\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tx_state      <= TX_IDLE;\n            tx_baud_cnt   <= 0;\n            tx_bit_cnt    <= 0;\n            tx_shift_reg  <= 0;\n            tx_parity_bit <= 0;\n            tx_line       <= 1'b1; // Idle is high\n            tx_busy       <= 1'b0;\n            tx_ready      <= 1'b1;\n        end else begin\n            tx_state <= tx_state_next;\n            case (tx_state)\n                TX_IDLE: begin\n                    tx_line     <= 1'b1;\n                    tx_busy     <= 1'b0;\n                    tx_ready    <= 1'b1;\n                    tx_baud_cnt <= 0;\n                    tx_bit_cnt  <= 0;\n                    if (UART_Start) begin\n                        tx_shift_reg  <= data_in;\n                        tx_parity_bit <= (PARITY_EN == 0) ? 1'b0 :\n                                         (PARITY_EN == 1) ? ~^data_in : // Even parity\n                                         (PARITY_EN == 2) ?  ^data_in : // Odd parity\n                                         1'b0;\n                    end\n                end\n                TX_START: begin\n                    tx_line     <= 1'b0; // Start bit\n                    tx_busy     <= 1'b1;\n                    tx_ready    <= 1'b0;\n                    if (tx_baud_cnt == BAUD_DIV-1) begin\n                        tx_baud_cnt <= 0;\n                        tx_state    <= TX_DATA;\n                        tx_bit_cnt  <= 0;\n                    end else begin\n                        tx_baud_cnt <= tx_baud_cnt + 1;\n                    end\n                end\n                TX_DATA: begin\n                    tx_line <= tx_shift_reg[0];\n                    if (tx_baud_cnt == BAUD_DIV-1) begin\n                        tx_baud_cnt  <= 0;\n                        tx_shift_reg <= {1'b0, tx_shift_reg[7:1]};\n                        if (tx_bit_cnt == 7) begin\n                            if (PARITY_EN != 0)\n                                tx_state <= TX_PARITY;\n                            else\n                                tx_state <= TX_STOP;\n                        end\n                        tx_bit_cnt <= tx_bit_cnt + 1;\n                    end else begin\n                        tx_baud_cnt <= tx_baud_cnt + 1;\n                    end\n                end\n                TX_PARITY: begin\n                    tx_line <= tx_parity_bit;\n                    if (tx_baud_cnt == BAUD_DIV-1) begin\n                        tx_baud_cnt <= 0;\n                        tx_state    <= TX_STOP;\n                    end else begin\n                        tx_baud_cnt <= tx_baud_cnt + 1;\n                    end\n                end\n                TX_STOP: begin\n                    tx_line <= 1'b1; // Stop bit\n                    if (tx_baud_cnt == BAUD_DIV-1) begin\n                        tx_baud_cnt <= 0;\n                        tx_state    <= TX_IDLE;\n                    end else begin\n                        tx_baud_cnt <= tx_baud_cnt + 1;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Transmitter State Machine Next State Logic\n    always_comb begin\n        tx_state_next = tx_state;\n        case (tx_state)\n            TX_IDLE:   if (UART_Start) tx_state_next = TX_START;\n            TX_START:  if (tx_baud_cnt == BAUD_DIV-1) tx_state_next = TX_DATA;\n            TX_DATA:   if ((tx_baud_cnt == BAUD_DIV-1) && (tx_bit_cnt == 7))\n                           tx_state_next = (PARITY_EN != 0) ? TX_PARITY : TX_STOP;\n            TX_PARITY: if (tx_baud_cnt == BAUD_DIV-1) tx_state_next = TX_STOP;\n            TX_STOP:   if (tx_baud_cnt == BAUD_DIV-1) tx_state_next = TX_IDLE;\n        endcase\n    end\n\n    // === Receiver Logic ===\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_state      <= RX_IDLE;\n            rx_baud_cnt   <= 0;\n            rx_bit_cnt    <= 0;\n            rx_shift_reg  <= 0;\n            rx_parity_bit <= 0;\n            rx_error      <= 1'b0;\n            rx_ready      <= 1'b0;\n            rx_data_out   <= 8'b0;\n        end else begin\n            rx_state <= rx_state_next;\n            case (rx_state)\n                RX_IDLE: begin\n                    rx_baud_cnt <= 0;\n                    rx_bit_cnt  <= 0;\n                    rx_ready    <= 1'b0;\n                    rx_error    <= 1'b0;\n                    if (~RX) begin // Start bit detected (falling edge)\n                        rx_baud_cnt <= BAUD_DIV/2; // Sample in the middle of the start bit\n                    end\n                end\n                RX_START: begin\n                    if (rx_baud_cnt == BAUD_DIV-1) begin\n                        if (~RX) begin // Confirm still low\n                            rx_baud_cnt <= 0;\n                            rx_bit_cnt  <= 0;\n                        end else begin\n                            rx_state <= RX_ERROR; // False start bit\n                        end\n                    end else begin\n                        rx_baud_cnt <= rx_baud_cnt + 1;\n                    end\n                end\n                RX_DATA: begin\n                    if (rx_baud_cnt == BAUD_DIV-1) begin\n                        rx_shift_reg <= {RX, rx_shift_reg[7:1]};\n                        if (rx_bit_cnt == 7) begin\n                            if (PARITY_EN != 0)\n                                rx_state <= RX_PARITY;\n                            else\n                                rx_state <= RX_STOP;\n                        end\n                        rx_bit_cnt  <= rx_bit_cnt + 1;\n                        rx_baud_cnt <= 0;\n                    end else begin\n                        rx_baud_cnt <= rx_baud_cnt + 1;\n                    end\n                end\n                RX_PARITY: begin\n                    if (rx_baud_cnt == BAUD_DIV-1) begin\n                        rx_parity_bit <= RX;\n                        rx_baud_cnt   <= 0;\n                        rx_state      <= RX_STOP;\n                    end else begin\n                        rx_baud_cnt <= rx_baud_cnt + 1;\n                    end\n                end\n                RX_STOP: begin\n                    if (rx_baud_cnt == BAUD_DIV-1) begin\n                        if (RX) begin // Stop bit should be high\n                            // Parity check\n                            if (PARITY_EN == 0 ||\n                                (PARITY_EN == 1 && rx_parity_bit == ~^rx_shift_reg) ||\n                                (PARITY_EN == 2 && rx_parity_bit ==  ^rx_shift_reg)) begin\n                                rx_data_out <= rx_shift_reg;\n                                rx_ready    <= 1'b1;\n                                rx_state    <= RX_IDLE;\n                            end else begin\n                                rx_error <= 1'b1;\n                                rx_state <= RX_ERROR;\n                            end\n                        end else begin\n                            rx_error <= 1'b1;\n                            rx_state <= RX_ERROR;\n                        end\n                        rx_baud_cnt <= 0;\n                    end else begin\n                        rx_baud_cnt <= rx_baud_cnt + 1;\n                    end\n                end\n                RX_ERROR: begin\n                    rx_ready <= 1'b0;\n                    if (RX) // Wait for line to return to idle\n                        rx_state <= RX_IDLE;\n                end\n            endcase\n        end\n    end\n\n    // Receiver State Machine Next State Logic\n    always_comb begin\n        rx_state_next = rx_state;\n        case (rx_state)\n            RX_IDLE:   if (~RX) rx_state_next = RX_START;\n            RX_START:  if (rx_baud_cnt == BAUD_DIV-1 && ~RX) rx_state_next = RX_DATA;\n            RX_DATA:   if ((rx_baud_cnt == BAUD_DIV-1) && (rx_bit_cnt == 7))\n                           rx_state_next = (PARITY_EN != 0) ? RX_PARITY : RX_STOP;\n            RX_PARITY: if (rx_baud_cnt == BAUD_DIV-1) rx_state_next = RX_STOP;\n            RX_STOP:   if (rx_baud_cnt == BAUD_DIV-1) rx_state_next = RX_IDLE;\n            RX_ERROR:  if (RX) rx_state_next = RX_IDLE;\n        endcase\n    end\n\nendmodule\n```\n**Notes:**\n- `BAUD_RATE`, `CLK_FREQ`, and `PARITY_EN` are parameters and can be overridden as needed.\n- Parity is optional: `PARITY_EN=0` disables parity, `1` enables even, `2` enables odd.\n- The module is full-duplex: transmit and receive logic are independent.\n- `UART_Ready` is high when ready to accept a new byte for transmission.\n- `UART_Busy` is high during transmission.\n- `UART_Error` is high if a framing or parity error is detected during reception.\n- The receiver samples the RX line in the middle of each bit period for robustness.\n- The design assumes 8 data bits, 1 start bit, 1 stop bit, and optional parity."
        },
        {
            "role": "user",
            "content": "Refine the following code to fix these errors:\n\n[1]      N.A        STX_VE_449    STX_VE_449    Syntax      ../../code/uart/gpt-4.1/UART_driver_code_0_RAGFalse.sv    23      1000    Size of the enumeration constant ( 3 ) for enum label TX_STOP is more than the range specified for the enumeration. Correct the entire code. Give full code as the output."
        }
    ],
    "answer_0": "Certainly! The error is due to the `typedef enum logic [1:0]` for the transmitter state machine, but there are **five** states, so the range must be at least 3 bits (`logic [2:0]`).  \nSimilarly, for the receiver, there are **six** states, so the enum should also be at least 3 bits.\n\nBelow is the **corrected and refined code**:\n\n```systemverilog\nmodule UART_driver(\n    input  logic       clk,         // System clock\n    input  logic       rst,         // Asynchronous reset\n    input  logic       UART_Start,  // Signal to initiate transmission\n    input  logic [7:0] data_in,     // Data to be transmitted\n    input  logic       RX,          // UART receive line\n    output logic       TX,          // UART transmit line\n    output logic [7:0] data_out,    // Received data\n    output logic       UART_Ready,  // Ready to transmit next byte\n    output logic       UART_Busy,   // Indicates UART is currently transmitting\n    output logic       UART_Error   // High if framing or parity error detected\n);\n\n    // === Configurable Parameters ===\n    parameter BAUD_RATE    = 115200;   // Baud rate\n    parameter CLK_FREQ     = 50000000; // System clock frequency (Hz)\n    parameter PARITY_EN    = 0;        // 0: No parity, 1: Even parity, 2: Odd parity\n\n    // === Local Parameters ===\n    localparam integer BAUD_DIV = CLK_FREQ / BAUD_RATE;\n\n    // === Transmitter Signals ===\n    typedef enum logic [2:0] {TX_IDLE, TX_START, TX_DATA, TX_PARITY, TX_STOP} tx_state_t;\n    tx_state_t tx_state, tx_state_next;\n    logic [$clog2(BAUD_DIV):0] tx_baud_cnt;\n    logic [3:0]  tx_bit_cnt;\n    logic [7:0]  tx_shift_reg;\n    logic        tx_parity_bit;\n    logic        tx_busy, tx_ready;\n    logic        tx_line;\n\n    // === Receiver Signals ===\n    typedef enum logic [2:0] {RX_IDLE, RX_START, RX_DATA, RX_PARITY, RX_STOP, RX_ERROR} rx_state_t;\n    rx_state_t rx_state, rx_state_next;\n    logic [$clog2(BAUD_DIV):0] rx_baud_cnt;\n    logic [3:0]  rx_bit_cnt;\n    logic [7:0]  rx_shift_reg;\n    logic        rx_parity_bit;\n    logic        rx_error;\n    logic        rx_ready;\n    logic [7:0]  rx_data_out;\n\n    // === Assign Outputs ===\n    assign TX         = tx_line;\n    assign UART_Ready = tx_ready;\n    assign UART_Busy  = tx_busy;\n    assign UART_Error = rx_error;\n    assign data_out   = rx_data_out;\n\n    // === Transmitter Logic ===\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tx_state      <= TX_IDLE;\n            tx_baud_cnt   <= 0;\n            tx_bit_cnt    <= 0;\n            tx_shift_reg  <= 0;\n            tx_parity_bit <= 0;\n            tx_line       <= 1'b1; // Idle is high\n            tx_busy       <= 1'b0;\n            tx_ready      <= 1'b1;\n        end else begin\n            tx_state <= tx_state_next;\n            case (tx_state)\n                TX_IDLE: begin\n                    tx_line     <= 1'b1;\n                    tx_busy     <= 1'b0;\n                    tx_ready    <= 1'b1;\n                    tx_baud_cnt <= 0;\n                    tx_bit_cnt  <= 0;\n                    if (UART_Start) begin\n                        tx_shift_reg  <= data_in;\n                        tx_parity_bit <= (PARITY_EN == 0) ? 1'b0 :\n                                         (PARITY_EN == 1) ? ~^data_in : // Even parity\n                                         (PARITY_EN == 2) ?  ^data_in : // Odd parity\n                                         1'b0;\n                    end\n                end\n                TX_START: begin\n                    tx_line     <= 1'b0; // Start bit\n                    tx_busy     <= 1'b1;\n                    tx_ready    <= 1'b0;\n                    if (tx_baud_cnt == BAUD_DIV-1) begin\n                        tx_baud_cnt <= 0;\n                        tx_state    <= TX_DATA;\n                        tx_bit_cnt  <= 0;\n                    end else begin\n                        tx_baud_cnt <= tx_baud_cnt + 1;\n                    end\n                end\n                TX_DATA: begin\n                    tx_line <= tx_shift_reg[0];\n                    if (tx_baud_cnt == BAUD_DIV-1) begin\n                        tx_baud_cnt  <= 0;\n                        tx_shift_reg <= {1'b0, tx_shift_reg[7:1]};\n                        if (tx_bit_cnt == 7) begin\n                            if (PARITY_EN != 0)\n                                tx_state <= TX_PARITY;\n                            else\n                                tx_state <= TX_STOP;\n                        end\n                        tx_bit_cnt <= tx_bit_cnt + 1;\n                    end else begin\n                        tx_baud_cnt <= tx_baud_cnt + 1;\n                    end\n                end\n                TX_PARITY: begin\n                    tx_line <= tx_parity_bit;\n                    if (tx_baud_cnt == BAUD_DIV-1) begin\n                        tx_baud_cnt <= 0;\n                        tx_state    <= TX_STOP;\n                    end else begin\n                        tx_baud_cnt <= tx_baud_cnt + 1;\n                    end\n                end\n                TX_STOP: begin\n                    tx_line <= 1'b1; // Stop bit\n                    if (tx_baud_cnt == BAUD_DIV-1) begin\n                        tx_baud_cnt <= 0;\n                        tx_state    <= TX_IDLE;\n                    end else begin\n                        tx_baud_cnt <= tx_baud_cnt + 1;\n                    end\n                end\n                default: begin\n                    tx_state <= TX_IDLE;\n                end\n            endcase\n        end\n    end\n\n    // Transmitter State Machine Next State Logic\n    always_comb begin\n        tx_state_next = tx_state;\n        case (tx_state)\n            TX_IDLE:   if (UART_Start) tx_state_next = TX_START;\n            TX_START:  if (tx_baud_cnt == BAUD_DIV-1) tx_state_next = TX_DATA;\n            TX_DATA:   if ((tx_baud_cnt == BAUD_DIV-1) && (tx_bit_cnt == 7))\n                           tx_state_next = (PARITY_EN != 0) ? TX_PARITY : TX_STOP;\n            TX_PARITY: if (tx_baud_cnt == BAUD_DIV-1) tx_state_next = TX_STOP;\n            TX_STOP:   if (tx_baud_cnt == BAUD_DIV-1) tx_state_next = TX_IDLE;\n            default:   tx_state_next = TX_IDLE;\n        endcase\n    end\n\n    // === Receiver Logic ===\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_state      <= RX_IDLE;\n            rx_baud_cnt   <= 0;\n            rx_bit_cnt    <= 0;\n            rx_shift_reg  <= 0;\n            rx_parity_bit <= 0;\n            rx_error      <= 1'b0;\n            rx_ready      <= 1'b0;\n            rx_data_out   <= 8'b0;\n        end else begin\n            rx_state <= rx_state_next;\n            case (rx_state)\n                RX_IDLE: begin\n                    rx_baud_cnt <= 0;\n                    rx_bit_cnt  <= 0;\n                    rx_ready    <= 1'b0;\n                    rx_error    <= 1'b0;\n                    if (~RX) begin // Start bit detected (falling edge)\n                        rx_baud_cnt <= BAUD_DIV/2; // Sample in the middle of the start bit\n                    end\n                end\n                RX_START: begin\n                    if (rx_baud_cnt == BAUD_DIV-1) begin\n                        if (~RX) begin // Confirm still low\n                            rx_baud_cnt <= 0;\n                            rx_bit_cnt  <= 0;\n                        end else begin\n                            rx_state <= RX_ERROR; // False start bit\n                        end\n                    end else begin\n                        rx_baud_cnt <= rx_baud_cnt + 1;\n                    end\n                end\n                RX_DATA: begin\n                    if (rx_baud_cnt == BAUD_DIV-1) begin\n                        rx_shift_reg <= {RX, rx_shift_reg[7:1]};\n                        if (rx_bit_cnt == 7) begin\n                            if (PARITY_EN != 0)\n                                rx_state <= RX_PARITY;\n                            else\n                                rx_state <= RX_STOP;\n                        end\n                        rx_bit_cnt  <= rx_bit_cnt + 1;\n                        rx_baud_cnt <= 0;\n                    end else begin\n                        rx_baud_cnt <= rx_baud_cnt + 1;\n                    end\n                end\n                RX_PARITY: begin\n                    if (rx_baud_cnt == BAUD_DIV-1) begin\n                        rx_parity_bit <= RX;\n                        rx_baud_cnt   <= 0;\n                        rx_state      <= RX_STOP;\n                    end else begin\n                        rx_baud_cnt <= rx_baud_cnt + 1;\n                    end\n                end\n                RX_STOP: begin\n                    if (rx_baud_cnt == BAUD_DIV-1) begin\n                        if (RX) begin // Stop bit should be high\n                            // Parity check\n                            if (PARITY_EN == 0 ||\n                                (PARITY_EN == 1 && rx_parity_bit == ~^rx_shift_reg) ||\n                                (PARITY_EN == 2 && rx_parity_bit ==  ^rx_shift_reg)) begin\n                                rx_data_out <= rx_shift_reg;\n                                rx_ready    <= 1'b1;\n                                rx_state    <= RX_IDLE;\n                            end else begin\n                                rx_error <= 1'b1;\n                                rx_state <= RX_ERROR;\n                            end\n                        end else begin\n                            rx_error <= 1'b1;\n                            rx_state <= RX_ERROR;\n                        end\n                        rx_baud_cnt <= 0;\n                    end else begin\n                        rx_baud_cnt <= rx_baud_cnt + 1;\n                    end\n                end\n                RX_ERROR: begin\n                    rx_ready <= 1'b0;\n                    if (RX) // Wait for line to return to idle\n                        rx_state <= RX_IDLE;\n                end\n                default: begin\n                    rx_state <= RX_IDLE;\n                end\n            endcase\n        end\n    end\n\n    // Receiver State Machine Next State Logic\n    always_comb begin\n        rx_state_next = rx_state;\n        case (rx_state)\n            RX_IDLE:   if (~RX) rx_state_next = RX_START;\n            RX_START:  if (rx_baud_cnt == BAUD_DIV-1 && ~RX) rx_state_next = RX_DATA;\n            RX_DATA:   if ((rx_baud_cnt == BAUD_DIV-1) && (rx_bit_cnt == 7))\n                           rx_state_next = (PARITY_EN != 0) ? RX_PARITY : RX_STOP;\n            RX_PARITY: if (rx_baud_cnt == BAUD_DIV-1) rx_state_next = RX_STOP;\n            RX_STOP:   if (rx_baud_cnt == BAUD_DIV-1) rx_state_next = RX_IDLE;\n            RX_ERROR:  if (RX) rx_state_next = RX_IDLE;\n            default:   rx_state_next = RX_IDLE;\n        endcase\n    end\n\nendmodule\n```\n\n**Key Fixes:**\n- Changed `typedef enum logic [1:0]` to `typedef enum logic [2:0]` for both `tx_state_t` and `rx_state_t` to accommodate all states.\n- Used `logic [$clog2(BAUD_DIV):0]` for baud counters to ensure enough width for any baud rate.\n- Added `default` cases in state machines for safety.\n\nThis should resolve the enumeration size error and make the code robust for synthesis and simulation."
}
