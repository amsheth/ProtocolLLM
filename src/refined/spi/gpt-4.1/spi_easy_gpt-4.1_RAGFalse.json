{
    "prompt_0": [
        {
            "role": "user",
            "content": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=1 and CPHA=1. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out ); Please return code only. No sure here, or any text. "
        },
        {
            "role": "assistant",
            "content": "module SPI_driver(\n    input  logic        clk,\n    input  logic        rst,\n    input  logic [7:0]  data_in,\n    input  logic        SPI_MISO,\n    input  logic        SPI_start,\n    output logic        SPI_MOSI,\n    output logic        SPI_CLK,\n    output logic        SPI_EN,\n    output logic [7:0]  data_out\n);\n\n    typedef enum logic [1:0] {IDLE, LOAD, TRANSFER, DONE} state_t;\n    state_t state, next_state;\n\n    logic [7:0] shift_reg;\n    logic [7:0] recv_reg;\n    logic [2:0] bit_cnt;\n    logic       sclk_int;\n    logic       sclk_en;\n    logic       sclk_rise;\n    logic       sclk_fall;\n\n    // CPOL=1, CPHA=1: SCLK idles high, data is sampled on rising edge, changed on falling edge\n    assign SPI_CLK = sclk_int;\n    assign SPI_EN  = (state == TRANSFER);\n    assign data_out = recv_reg;\n\n    // SCLK generation (divide by 2 for SPI clock)\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sclk_int <= 1'b1; // CPOL=1, idle high\n        end else if (sclk_en) begin\n            sclk_int <= ~sclk_int;\n        end else begin\n            sclk_int <= 1'b1;\n        end\n    end\n\n    // SCLK edge detection\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sclk_rise <= 1'b0;\n            sclk_fall <= 1'b0;\n        end else begin\n            sclk_rise <= (sclk_en && ~sclk_int && (state == TRANSFER));\n            sclk_fall <= (sclk_en &&  sclk_int && (state == TRANSFER));\n        end\n    end\n\n    // State machine\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always_comb begin\n        next_state = state;\n        case (state)\n            IDLE:    if (SPI_start) next_state = LOAD;\n            LOAD:    next_state = TRANSFER;\n            TRANSFER:if (bit_cnt == 3'd7 && sclk_rise) next_state = DONE;\n            DONE:    next_state = IDLE;\n        endcase\n    end\n\n    // Bit counter\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            bit_cnt <= 3'd0;\n        end else if (state == LOAD) begin\n            bit_cnt <= 3'd0;\n        end else if (state == TRANSFER && sclk_rise) begin\n            bit_cnt <= bit_cnt + 3'd1;\n        end\n    end\n\n    // Shift register for MOSI\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            shift_reg <= 8'd0;\n        end else if (state == LOAD) begin\n            shift_reg <= data_in;\n        end else if (state == TRANSFER && sclk_fall) begin\n            shift_reg <= {shift_reg[6:0], 1'b0};\n        end\n    end\n\n    // Output MOSI (CPHA=1: change on falling edge, sample on rising edge)\n    assign SPI_MOSI = shift_reg[7];\n\n    // Receive register for MISO\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            recv_reg <= 8'd0;\n        end else if (state == LOAD) begin\n            recv_reg <= 8'd0;\n        end else if (state == TRANSFER && sclk_rise) begin\n            recv_reg <= {recv_reg[6:0], SPI_MISO};\n        end\n    end\n\n    // SCLK enable\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sclk_en <= 1'b0;\n        end else if (state == LOAD) begin\n            sclk_en <= 1'b1;\n        end else if (state == DONE) begin\n            sclk_en <= 1'b0;\n        end\n    end\n\nendmodule"
        },
        {
            "role": "user",
            "content": "Refine the following code to fix these errors:\n\n. Correct the entire code. Give full code as the output."
        }
    ],
    "answer_0": "module SPI_driver(\n    input  logic        clk,\n    input  logic        rst,\n    input  logic [7:0]  data_in,\n    input  logic        SPI_MISO,\n    input  logic        SPI_start,\n    output logic        SPI_MOSI,\n    output logic        SPI_CLK,\n    output logic        SPI_EN,\n    output logic [7:0]  data_out\n);\n\n    typedef enum logic [1:0] {IDLE, LOAD, TRANSFER, DONE} state_t;\n    state_t state, next_state;\n\n    logic [7:0] shift_reg;\n    logic [7:0] recv_reg;\n    logic [2:0] bit_cnt;\n    logic       sclk_int;\n    logic       sclk_en;\n    logic       sclk_prev;\n    logic       sclk_rise;\n    logic       sclk_fall;\n\n    // CPOL=1, CPHA=1: SCLK idles high, data is sampled on rising edge, changed on falling edge\n    assign SPI_CLK = sclk_int;\n    assign SPI_EN  = (state == TRANSFER);\n    assign data_out = recv_reg;\n\n    // SCLK generation (divide by 2 for SPI clock)\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sclk_int <= 1'b1; // CPOL=1, idle high\n        end else if (sclk_en) begin\n            sclk_int <= ~sclk_int;\n        end else begin\n            sclk_int <= 1'b1;\n        end\n    end\n\n    // SCLK edge detection\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sclk_prev <= 1'b1;\n            sclk_rise <= 1'b0;\n            sclk_fall <= 1'b0;\n        end else begin\n            sclk_rise <= (~sclk_prev) & sclk_int;\n            sclk_fall <= sclk_prev & (~sclk_int);\n            sclk_prev <= sclk_int;\n        end\n    end\n\n    // State machine\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always_comb begin\n        next_state = state;\n        case (state)\n            IDLE:     if (SPI_start) next_state = LOAD;\n            LOAD:     next_state = TRANSFER;\n            TRANSFER: if ((bit_cnt == 3'd7) && sclk_rise) next_state = DONE;\n            DONE:     next_state = IDLE;\n            default:  next_state = IDLE;\n        endcase\n    end\n\n    // Bit counter\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            bit_cnt <= 3'd0;\n        end else if (state == LOAD) begin\n            bit_cnt <= 3'd0;\n        end else if (state == TRANSFER && sclk_rise) begin\n            bit_cnt <= bit_cnt + 3'd1;\n        end\n    end\n\n    // Shift register for MOSI\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            shift_reg <= 8'd0;\n        end else if (state == LOAD) begin\n            shift_reg <= data_in;\n        end else if (state == TRANSFER && sclk_fall) begin\n            shift_reg <= {shift_reg[6:0], 1'b0};\n        end\n    end\n\n    // Output MOSI (CPHA=1: change on falling edge, sample on rising edge)\n    assign SPI_MOSI = shift_reg[7];\n\n    // Receive register for MISO\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            recv_reg <= 8'd0;\n        end else if (state == LOAD) begin\n            recv_reg <= 8'd0;\n        end else if (state == TRANSFER && sclk_rise) begin\n            recv_reg <= {recv_reg[6:0], SPI_MISO};\n        end\n    end\n\n    // SCLK enable\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sclk_en <= 1'b0;\n        end else if (state == LOAD) begin\n            sclk_en <= 1'b1;\n        end else if (state == DONE) begin\n            sclk_en <= 1'b0;\n        end\n    end\n\nendmodule",
    
    "prompt_1": [
        {
            "role": "user",
            "content": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=1 and CPHA=0. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out ); Please return code only. No sure here, or any text. "
        },
        {
            "role": "assistant",
            "content": "module SPI_driver(\n    input  logic        clk,\n    input  logic        rst,\n    input  logic [7:0]  data_in,\n    input  logic        SPI_MISO,\n    input  logic        SPI_start,\n    output logic        SPI_MOSI,\n    output logic        SPI_CLK,\n    output logic        SPI_EN,\n    output logic [7:0]  data_out\n);\n\n    typedef enum logic [1:0] {IDLE, LOAD, TRANSFER, DONE} state_t;\n    state_t state, next_state;\n\n    logic [7:0] shift_reg;\n    logic [7:0] recv_reg;\n    logic [2:0] bit_cnt;\n    logic       spi_clk_int;\n    logic       spi_clk_en;\n\n    // CPOL=1, CPHA=0: SPI_CLK idles high, data is sampled on leading (falling) edge, changed on trailing (rising) edge\n\n    // SPI clock generation (divide by 2 for demonstration)\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            spi_clk_int <= 1'b1; // CPOL=1, idle high\n        end else if (spi_clk_en) begin\n            spi_clk_int <= ~spi_clk_int;\n        end else begin\n            spi_clk_int <= 1'b1; // CPOL=1, idle high\n        end\n    end\n\n    // State machine\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state     <= IDLE;\n            shift_reg <= 8'd0;\n            recv_reg  <= 8'd0;\n            bit_cnt   <= 3'd7;\n        end else begin\n            state <= next_state;\n            case (state)\n                IDLE: begin\n                    shift_reg <= 8'd0;\n                    recv_reg  <= 8'd0;\n                    bit_cnt   <= 3'd7;\n                end\n                LOAD: begin\n                    shift_reg <= data_in;\n                    bit_cnt   <= 3'd7;\n                end\n                TRANSFER: begin\n                    // CPHA=0: Output data on trailing (rising) edge, sample on leading (falling) edge\n                    if (spi_clk_en && !spi_clk_int) begin // falling edge: sample MISO\n                        recv_reg[bit_cnt] <= SPI_MISO;\n                    end\n                    if (spi_clk_en && spi_clk_int) begin // rising edge: shift out next bit\n                        if (bit_cnt != 0) begin\n                            shift_reg <= {shift_reg[6:0], 1'b0};\n                            bit_cnt   <= bit_cnt - 1;\n                        end\n                    end\n                end\n                DONE: begin\n                    // nothing\n                end\n            endcase\n        end\n    end\n\n    // Next state logic\n    always_comb begin\n        next_state = state;\n        spi_clk_en = 1'b0;\n        case (state)\n            IDLE: begin\n                if (SPI_start)\n                    next_state = LOAD;\n            end\n            LOAD: begin\n                next_state = TRANSFER;\n            end\n            TRANSFER: begin\n                spi_clk_en = 1'b1;\n                if ((bit_cnt == 0) && (spi_clk_en && spi_clk_int)) // after last bit shifted out\n                    next_state = DONE;\n            end\n            DONE: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // SPI signals\n    assign SPI_EN   = (state == TRANSFER) ? 1'b0 : 1'b1; // Active low\n    assign SPI_CLK  = spi_clk_int;\n    assign SPI_MOSI = shift_reg[7];\n    assign data_out = recv_reg;\n\nendmodule"
        },
        {
            "role": "user",
            "content": "Refine the following code to fix these errors:\n\n. Correct the entire code. Give full code as the output."
        }
    ],
    "answer_1": "module SPI_driver(\n    input  logic        clk,\n    input  logic        rst,\n    input  logic [7:0]  data_in,\n    input  logic        SPI_MISO,\n    input  logic        SPI_start,\n    output logic        SPI_MOSI,\n    output logic        SPI_CLK,\n    output logic        SPI_EN,\n    output logic [7:0]  data_out\n);\n\n    typedef enum logic [1:0] {IDLE, LOAD, TRANSFER, DONE} state_t;\n    state_t state, next_state;\n\n    logic [7:0] shift_reg;\n    logic [7:0] recv_reg;\n    logic [2:0] bit_cnt;\n    logic       spi_clk_int;\n    logic       spi_clk_en;\n    logic       spi_clk_edge;\n    logic [1:0] clk_div;\n\n    // SPI clock generation (divide by 4 for demonstration)\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            clk_div     <= 2'd0;\n            spi_clk_int <= 1'b1; // CPOL=1, idle high\n        end else if (spi_clk_en) begin\n            clk_div <= clk_div + 1'b1;\n            if (clk_div == 2'd1) begin\n                spi_clk_int <= ~spi_clk_int;\n            end\n        end else begin\n            clk_div     <= 2'd0;\n            spi_clk_int <= 1'b1; // CPOL=1, idle high\n        end\n    end\n\n    // Detect SPI clock edges (for state machine)\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            spi_clk_edge <= 1'b0;\n        end else begin\n            spi_clk_edge <= (spi_clk_en && (clk_div == 2'd1));\n        end\n    end\n\n    // State machine\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state     <= IDLE;\n            shift_reg <= 8'd0;\n            recv_reg  <= 8'd0;\n            bit_cnt   <= 3'd7;\n        end else begin\n            state <= next_state;\n            case (state)\n                IDLE: begin\n                    shift_reg <= 8'd0;\n                    recv_reg  <= 8'd0;\n                    bit_cnt   <= 3'd7;\n                end\n                LOAD: begin\n                    shift_reg <= data_in;\n                    bit_cnt   <= 3'd7;\n                end\n                TRANSFER: begin\n                    // CPHA=0: Output data on trailing (rising) edge, sample on leading (falling) edge\n                    if (spi_clk_edge) begin\n                        if (!spi_clk_int) begin // falling edge: sample MISO\n                            recv_reg[bit_cnt] <= SPI_MISO;\n                        end else begin // rising edge: shift out next bit\n                            if (bit_cnt != 0) begin\n                                shift_reg <= {shift_reg[6:0], 1'b0};\n                                bit_cnt   <= bit_cnt - 1'b1;\n                            end\n                        end\n                    end\n                end\n                DONE: begin\n                    // nothing\n                end\n            endcase\n        end\n    end\n\n    // Next state logic\n    always_comb begin\n        next_state = state;\n        spi_clk_en = 1'b0;\n        case (state)\n            IDLE: begin\n                if (SPI_start)\n                    next_state = LOAD;\n            end\n            LOAD: begin\n                next_state = TRANSFER;\n            end\n            TRANSFER: begin\n                spi_clk_en = 1'b1;\n                if ((bit_cnt == 0) && spi_clk_edge && spi_clk_int) // after last bit shifted out\n                    next_state = DONE;\n            end\n            DONE: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // SPI signals\n    assign SPI_EN   = (state == TRANSFER) ? 1'b0 : 1'b1; // Active low\n    assign SPI_CLK  = spi_clk_int;\n    assign SPI_MOSI = shift_reg[7];\n    assign data_out = recv_reg;\n\nendmodule",

    "prompt_2": [
        {
            "role": "user",
            "content": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=0 and CPHA=1. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out ); Please return code only. No sure here, or any text. "
        },
        {
            "role": "assistant",
            "content": "module SPI_driver(\n    input  logic        clk,\n    input  logic        rst,\n    input  logic [7:0]  data_in,\n    input  logic        SPI_MISO,\n    input  logic        SPI_start,\n    output logic        SPI_MOSI,\n    output logic        SPI_CLK,\n    output logic        SPI_EN,\n    output logic [7:0]  data_out\n);\n\n    typedef enum logic [1:0] {IDLE, LOAD, TRANSFER, DONE} state_t;\n    state_t state, next_state;\n\n    logic [7:0] shift_reg;\n    logic [7:0] recv_reg;\n    logic [2:0] bit_cnt;\n    logic       sclk_int;\n    logic       sclk_en;\n    logic       mosi_int;\n    logic       en_int;\n\n    // CPOL=0, CPHA=1: SCLK idles low, data sampled on rising edge, changed on falling edge\n\n    // SCLK generation (one SCLK per two clk cycles)\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sclk_int <= 1'b0;\n        end else if (sclk_en) begin\n            sclk_int <= ~sclk_int;\n        end else begin\n            sclk_int <= 1'b0;\n        end\n    end\n\n    // State machine\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state     <= IDLE;\n            shift_reg <= 8'd0;\n            recv_reg  <= 8'd0;\n            bit_cnt   <= 3'd7;\n            mosi_int  <= 1'b0;\n            en_int    <= 1'b1;\n        end else begin\n            state <= next_state;\n            case (state)\n                IDLE: begin\n                    en_int   <= 1'b1;\n                    mosi_int <= 1'b0;\n                    if (SPI_start) begin\n                        shift_reg <= data_in;\n                        bit_cnt   <= 3'd7;\n                    end\n                end\n                LOAD: begin\n                    en_int   <= 1'b0;\n                    mosi_int <= shift_reg[7];\n                end\n                TRANSFER: begin\n                    en_int <= 1'b0;\n                    // CPHA=1: Change MOSI on falling edge, sample MISO on rising edge\n                    if (sclk_int == 1'b0) begin // falling edge\n                        mosi_int  <= shift_reg[bit_cnt];\n                    end else begin // rising edge\n                        recv_reg[bit_cnt] <= SPI_MISO;\n                        if (bit_cnt != 0)\n                            bit_cnt <= bit_cnt - 1;\n                    end\n                end\n                DONE: begin\n                    en_int   <= 1'b1;\n                    mosi_int <= 1'b0;\n                end\n            endcase\n        end\n    end\n\n    // Next state logic\n    always_comb begin\n        next_state = state;\n        sclk_en    = 1'b0;\n        case (state)\n            IDLE: begin\n                if (SPI_start)\n                    next_state = LOAD;\n            end\n            LOAD: begin\n                next_state = TRANSFER;\n            end\n            TRANSFER: begin\n                sclk_en = 1'b1;\n                if ((bit_cnt == 0) && (sclk_int == 1'b1))\n                    next_state = DONE;\n            end\n            DONE: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    assign SPI_MOSI = mosi_int;\n    assign SPI_CLK  = sclk_int;\n    assign SPI_EN   = en_int;\n    assign data_out = recv_reg;\n\nendmodule"
        },
        {
            "role": "user",
            "content": "Refine the following code to fix these errors:\n\n. Correct the entire code. Give full code as the output."
        }
    ],
    "answer_2": "module SPI_driver(\n    input  logic        clk,\n    input  logic        rst,\n    input  logic [7:0]  data_in,\n    input  logic        SPI_MISO,\n    input  logic        SPI_start,\n    output logic        SPI_MOSI,\n    output logic        SPI_CLK,\n    output logic        SPI_EN,\n    output logic [7:0]  data_out\n);\n\n    typedef enum logic [1:0] {IDLE, LOAD, TRANSFER, DONE} state_t;\n    state_t state, next_state;\n\n    logic [7:0] shift_reg;\n    logic [7:0] recv_reg;\n    logic [2:0] bit_cnt;\n    logic       sclk_int;\n    logic       sclk_en;\n    logic       mosi_int;\n    logic       en_int;\n    logic       sclk_rise;\n    logic       sclk_fall;\n    logic       sclk_int_d;\n\n    // CPOL=0, CPHA=1: SCLK idles low, data sampled on rising edge, changed on falling edge\n\n    // SCLK generation (one SCLK per two clk cycles)\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sclk_int <= 1'b0;\n        end else if (sclk_en) begin\n            sclk_int <= ~sclk_int;\n        end else begin\n            sclk_int <= 1'b0;\n        end\n    end\n\n    // SCLK edge detection\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sclk_int_d <= 1'b0;\n        end else begin\n            sclk_int_d <= sclk_int;\n        end\n    end\n    assign sclk_rise = (sclk_int == 1'b1) && (sclk_int_d == 1'b0);\n    assign sclk_fall = (sclk_int == 1'b0) && (sclk_int_d == 1'b1);\n\n    // State machine\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state     <= IDLE;\n            shift_reg <= 8'd0;\n            recv_reg  <= 8'd0;\n            bit_cnt   <= 3'd7;\n            mosi_int  <= 1'b0;\n            en_int    <= 1'b1;\n        end else begin\n            state <= next_state;\n            case (state)\n                IDLE: begin\n                    en_int   <= 1'b1;\n                    mosi_int <= 1'b0;\n                    if (SPI_start) begin\n                        shift_reg <= data_in;\n                        bit_cnt   <= 3'd7;\n                    end\n                end\n                LOAD: begin\n                    en_int   <= 1'b0;\n                    mosi_int <= shift_reg[7];\n                end\n                TRANSFER: begin\n                    en_int <= 1'b0;\n                    // CPHA=1: Change MOSI on falling edge, sample MISO on rising edge\n                    if (sclk_fall) begin\n                        if (bit_cnt != 0)\n                            mosi_int <= shift_reg[bit_cnt-1];\n                        else\n                            mosi_int <= 1'b0;\n                    end\n                    if (sclk_rise) begin\n                        recv_reg[bit_cnt] <= SPI_MISO;\n                        if (bit_cnt != 0)\n                            bit_cnt <= bit_cnt - 1;\n                    end\n                end\n                DONE: begin\n                    en_int   <= 1'b1;\n                    mosi_int <= 1'b0;\n                end\n            endcase\n        end\n    end\n\n    // Next state logic\n    always_comb begin\n        next_state = state;\n        sclk_en    = 1'b0;\n        case (state)\n            IDLE: begin\n                if (SPI_start)\n                    next_state = LOAD;\n            end\n            LOAD: begin\n                next_state = TRANSFER;\n            end\n            TRANSFER: begin\n                sclk_en = 1'b1;\n                if ((bit_cnt == 0) && sclk_rise)\n                    next_state = DONE;\n            end\n            DONE: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    assign SPI_MOSI = mosi_int;\n    assign SPI_CLK  = sclk_int;\n    assign SPI_EN   = en_int;\n    assign data_out = recv_reg;\n\nendmodule",

    "prompt_3": [
        {
            "role": "user",
            "content": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=0 and CPHA=0. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out ); Please return code only. No sure here, or any text. "
        },
        {
            "role": "assistant",
            "content": "module SPI_driver(\n    input  logic        clk,\n    input  logic        rst,\n    input  logic [7:0]  data_in,\n    input  logic        SPI_MISO,\n    input  logic        SPI_start,\n    output logic        SPI_MOSI,\n    output logic        SPI_CLK,\n    output logic        SPI_EN,\n    output logic [7:0]  data_out\n);\n\n    typedef enum logic [1:0] {IDLE, LOAD, TRANSFER, DONE} state_t;\n    state_t state, next_state;\n\n    logic [7:0] shift_reg;\n    logic [7:0] recv_reg;\n    logic [2:0] bit_cnt;\n    logic       clk_div;\n    logic       clk_en;\n\n    // SPI clock generation (divide by 2 for demonstration)\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            clk_div <= 1'b0;\n        else if (clk_en)\n            clk_div <= ~clk_div;\n        else\n            clk_div <= 1'b0;\n    end\n\n    // SPI state machine\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    always_comb begin\n        next_state = state;\n        case (state)\n            IDLE:    if (SPI_start) next_state = LOAD;\n            LOAD:    next_state = TRANSFER;\n            TRANSFER:if (bit_cnt == 3'd7 && clk_div && clk_en) next_state = DONE;\n            DONE:    next_state = IDLE;\n        endcase\n    end\n\n    // Bit counter\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            bit_cnt <= 3'd0;\n        else if (state == LOAD)\n            bit_cnt <= 3'd0;\n        else if (state == TRANSFER && clk_div && clk_en)\n            bit_cnt <= bit_cnt + 1'b1;\n    end\n\n    // Shift register for MOSI\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            shift_reg <= 8'd0;\n        else if (state == LOAD)\n            shift_reg <= data_in;\n        else if (state == TRANSFER && clk_div && clk_en)\n            shift_reg <= {shift_reg[6:0], 1'b0};\n    end\n\n    // Receive register for MISO\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            recv_reg <= 8'd0;\n        else if (state == LOAD)\n            recv_reg <= 8'd0;\n        else if (state == TRANSFER && clk_en && !clk_div) // sample on leading edge\n            recv_reg <= {recv_reg[6:0], SPI_MISO};\n    end\n\n    // Output assignments\n    assign SPI_MOSI = shift_reg[7];\n    assign SPI_CLK  = (state == TRANSFER && clk_en) ? clk_div : 1'b0; // CPOL=0\n    assign SPI_EN   = (state == TRANSFER || state == LOAD) ? 1'b0 : 1'b1; // Active low\n    assign data_out = (state == DONE) ? recv_reg : 8'd0;\n\n    // Enable SPI clock only during transfer\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            clk_en <= 1'b0;\n        else if (state == LOAD)\n            clk_en <= 1'b1;\n        else if (state == DONE)\n            clk_en <= 1'b0;\n    end\n\nendmodule"
        },
        {
            "role": "user",
            "content": "Refine the following code to fix these errors:\n\n. Correct the entire code. Give full code as the output."
        }
    ],
    "answer_3": "module SPI_driver(\n    input  logic        clk,\n    input  logic        rst,\n    input  logic [7:0]  data_in,\n    input  logic        SPI_MISO,\n    input  logic        SPI_start,\n    output logic        SPI_MOSI,\n    output logic        SPI_CLK,\n    output logic        SPI_EN,\n    output logic [7:0]  data_out\n);\n\n    typedef enum logic [1:0] {IDLE, LOAD, TRANSFER, DONE} state_t;\n    state_t state, next_state;\n\n    logic [7:0] shift_reg;\n    logic [7:0] recv_reg;\n    logic [2:0] bit_cnt;\n    logic       clk_div;\n    logic       clk_en;\n    logic [7:0] data_out_reg;\n\n    // SPI clock generation (divide by 2 for demonstration)\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            clk_div <= 1'b0;\n        else if (clk_en)\n            clk_div <= ~clk_div;\n        else\n            clk_div <= 1'b0;\n    end\n\n    // SPI state machine\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    always_comb begin\n        next_state = state;\n        case (state)\n            IDLE:    if (SPI_start) next_state = LOAD;\n            LOAD:    next_state = TRANSFER;\n            TRANSFER:if ((bit_cnt == 3'd7) && (clk_div == 1'b1) && (clk_en == 1'b1)) next_state = DONE;\n            DONE:    next_state = IDLE;\n            default: next_state = IDLE;\n        endcase\n    end\n\n    // Bit counter\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            bit_cnt <= 3'd0;\n        else if (state == LOAD)\n            bit_cnt <= 3'd0;\n        else if ((state == TRANSFER) && (clk_div == 1'b1) && (clk_en == 1'b1))\n            bit_cnt <= bit_cnt + 1'b1;\n    end\n\n    // Shift register for MOSI\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            shift_reg <= 8'd0;\n        else if (state == LOAD)\n            shift_reg <= data_in;\n        else if ((state == TRANSFER) && (clk_div == 1'b1) && (clk_en == 1'b1))\n            shift_reg <= {shift_reg[6:0], 1'b0};\n    end\n\n    // Receive register for MISO\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            recv_reg <= 8'd0;\n        else if (state == LOAD)\n            recv_reg <= 8'd0;\n        else if ((state == TRANSFER) && (clk_en == 1'b1) && (clk_div == 1'b0)) // sample on leading edge\n            recv_reg <= {recv_reg[6:0], SPI_MISO};\n    end\n\n    // Output data register\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            data_out_reg <= 8'd0;\n        else if (state == DONE)\n            data_out_reg <= recv_reg;\n    end\n\n    assign data_out = data_out_reg;\n\n    // Output assignments\n    assign SPI_MOSI = shift_reg[7];\n    assign SPI_CLK  = (state == TRANSFER && clk_en) ? clk_div : 1'b0; // CPOL=0\n    assign SPI_EN   = (state == TRANSFER || state == LOAD) ? 1'b0 : 1'b1; // Active low\n\n    // Enable SPI clock only during transfer\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            clk_en <= 1'b0;\n        else if (state == LOAD)\n            clk_en <= 1'b1;\n        else if (state == DONE)\n            clk_en <= 1'b0;\n    end\n\nendmodule"


}
