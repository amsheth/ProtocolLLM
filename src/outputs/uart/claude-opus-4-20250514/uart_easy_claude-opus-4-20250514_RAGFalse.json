{
    "prompt_0": "Write a SystemVerilog module to implement a UART (Universal Asynchronous Receiver-Transmitter) controller. The module should support configurable baud rates, transmit and receive functionality, and proper start, data, parity (optional), and stop bit handling. The UART should operate in full-duplex mode and adhere to the following interface:\nmodule UART_driver( input  logic       clk,        // System clock input  logic       rst,        // Asynchronous reset input  logic       UART_Start, // Signal to initiate transmission input  logic [7:0] data_in,    // Data to be transmitted input  logic       RX,         // UART receive line output logic       TX,         // UART transmit line output logic [7:0] data_out,   // Received data output logic       UART_Ready, // Ready to transmit next byte output logic       UART_Busy,  // Indicates UART is currently transmitting output logic       UART_Error  // High if framing or parity error detected ); ",
    "answer_0": "Here's a comprehensive SystemVerilog implementation of a UART controller with configurable parameters:\n\n```systemverilog\nmodule UART_driver #(\n    parameter CLK_FREQ = 50_000_000,  // System clock frequency in Hz\n    parameter BAUD_RATE = 115200,     // Desired baud rate\n    parameter DATA_BITS = 8,          // Number of data bits (7 or 8)\n    parameter PARITY_EN = 0,          // Enable parity (0: disabled, 1: enabled)\n    parameter PARITY_TYPE = 0,        // 0: even parity, 1: odd parity\n    parameter STOP_BITS = 1           // Number of stop bits (1 or 2)\n)(\n    input  logic       clk,           // System clock\n    input  logic       rst,           // Asynchronous reset\n    input  logic       UART_Start,    // Signal to initiate transmission\n    input  logic [7:0] data_in,       // Data to be transmitted\n    input  logic       RX,            // UART receive line\n    output logic       TX,            // UART transmit line\n    output logic [7:0] data_out,      // Received data\n    output logic       UART_Ready,    // Ready to transmit next byte\n    output logic       UART_Busy,     // Indicates UART is currently transmitting\n    output logic       UART_Error     // High if framing or parity error detected\n);\n\n    // Calculate clock divider for baud rate generation\n    localparam CLKS_PER_BIT = CLK_FREQ / BAUD_RATE;\n    \n    // State definitions for TX and RX FSMs\n    typedef enum logic [2:0] {\n        IDLE,\n        START_BIT,\n        DATA_BITS,\n        PARITY_BIT,\n        STOP_BIT,\n        CLEANUP\n    } uart_state_t;\n    \n    // Transmitter signals\n    uart_state_t tx_state;\n    logic [15:0] tx_clk_count;\n    logic [2:0]  tx_bit_index;\n    logic [7:0]  tx_data_reg;\n    logic        tx_parity_bit;\n    \n    // Receiver signals\n    uart_state_t rx_state;\n    logic [15:0] rx_clk_count;\n    logic [2:0]  rx_bit_index;\n    logic [7:0]  rx_data_reg;\n    logic        rx_parity_bit;\n    logic        rx_parity_calc;\n    logic        rx_frame_error;\n    logic        rx_parity_error;\n    logic        rx_data_ready;\n    \n    // RX synchronizer for metastability\n    logic [2:0] rx_sync;\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_sync <= 3'b111;\n        end else begin\n            rx_sync <= {rx_sync[1:0], RX};\n        end\n    end\n    \n    wire rx_in = rx_sync[2];\n    \n    // Parity calculation function\n    function logic calc_parity(input logic [7:0] data, input logic parity_type);\n        logic parity;\n        parity = ^data;  // XOR all bits\n        return parity_type ? ~parity : parity;  // odd or even parity\n    endfunction\n    \n    // ==================== TRANSMITTER ====================\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tx_state <= IDLE;\n            tx_clk_count <= 0;\n            tx_bit_index <= 0;\n            tx_data_reg <= 0;\n            TX <= 1'b1;  // Idle state is high\n            UART_Busy <= 1'b0;\n            tx_parity_bit <= 1'b0;\n        end else begin\n            case (tx_state)\n                IDLE: begin\n                    TX <= 1'b1;\n                    tx_clk_count <= 0;\n                    tx_bit_index <= 0;\n                    UART_Busy <= 1'b0;\n                    \n                    if (UART_Start) begin\n                        tx_data_reg <= data_in;\n                        UART_Busy <= 1'b1;\n                        tx_state <= START_BIT;\n                        if (PARITY_EN)\n                            tx_parity_bit <= calc_parity(data_in, PARITY_TYPE);\n                    end\n                end\n                \n                START_BIT: begin\n                    TX <= 1'b0;  // Start bit is low\n                    \n                    if (tx_clk_count < CLKS_PER_BIT - 1) begin\n                        tx_clk_count <= tx_clk_count + 1;\n                    end else begin\n                        tx_clk_count <= 0;\n                        tx_state <= DATA_BITS;\n                    end\n                end\n                \n                DATA_BITS: begin\n                    TX <= tx_data_reg[tx_bit_index];\n                    \n                    if (tx_clk_count < CLKS_PER_BIT - 1) begin\n                        tx_clk_count <= tx_clk_count + 1;\n                    end else begin\n                        tx_clk_count <= 0;\n                        \n                        if (tx_bit_index < DATA_BITS - 1) begin\n                            tx_bit_index <= tx_bit_index + 1;\n                        end else begin\n                            tx_bit_index <= 0;\n                            tx_state <= PARITY_EN ? PARITY_BIT : STOP_BIT;\n                        end\n                    end\n                end\n                \n                PARITY_BIT: begin\n                    TX <= tx_parity_bit;\n                    \n                    if (tx_clk_count < CLKS_PER_BIT - 1) begin\n                        tx_clk_count <= tx_clk_count + 1;\n                    end else begin\n                        tx_clk_count <= 0;\n                        tx_state <= STOP_BIT;\n                    end\n                end\n                \n                STOP_BIT: begin\n                    TX <= 1'b1;  // Stop bit is high\n                    \n                    if (tx_clk_count < CLKS_PER_BIT - 1) begin\n                        tx_clk_count <= tx_clk_count + 1;\n                    end else begin\n                        tx_clk_count <= 0;\n                        \n                        if (STOP_BITS == 2 && tx_bit_index == 0) begin\n                            tx_bit_index <= 1;\n                        end else begin\n                            tx_state <= CLEANUP;\n                            tx_bit_index <= 0;\n                        end\n                    end\n                end\n                \n                CLEANUP: begin\n                    UART_Busy <= 1'b0;\n                    tx_state <= IDLE;\n                end\n                \n                default: tx_state <= IDLE;\n            endcase\n        end\n    end\n    \n    // ==================== RECEIVER ====================\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_state <= IDLE;\n            rx_clk_count <= 0;\n            rx_bit_index <= 0;\n            rx_data_reg <= 0;\n            rx_data_ready <= 1'b0;\n            rx_frame_error <= 1'b0;\n            rx_parity_error <= 1'b0;\n            rx_parity_calc <= 1'b0;\n        end else begin\n            rx_data_ready <= 1'b0;  // Default\n            \n            case (rx_state)\n                IDLE: begin\n                    rx_clk_count <= 0;\n                    rx_bit_index <= 0;\n                    \n                    if (rx_in == 1'b0) begin  // Start bit detected\n                        rx_state <= START_BIT;\n                        rx_frame_error <= 1'b0;\n                        rx_parity_error <= 1'b0;\n                    end\n                end\n                \n                START_BIT: begin\n                    if (rx_clk_count < (CLKS_PER_BIT - 1) / 2) begin\n                        rx_clk_count <= rx_clk_count + 1;\n                    end else begin\n                        if (rx_in == 1'b0) begin  // Valid start bit\n                            rx_clk_count <= 0;\n                            rx_state <= DATA_BITS;\n                            rx_parity_calc <= 1'b0;\n                        end else begin  // False start bit\n                            rx_state <= IDLE;\n                        end\n                    end\n                end\n                \n                DATA_BITS: begin\n                    if (rx_clk_count < CLKS_PER_BIT - 1) begin\n                        rx_clk_count <= rx_clk_count + 1;\n                    end else begin\n                        rx_clk_count <= 0;\n                        rx_data_reg[rx_bit_index] <= rx_in;\n                        rx_parity_calc <= rx_parity_calc ^ rx_in;\n                        \n                        if (rx_bit_index < DATA_BITS - 1) begin\n                            rx_bit_index <= rx_bit_index + 1;\n                        end else begin\n                            rx_bit_index <= 0;\n                            rx_state <= PARITY_EN ? PARITY_BIT : STOP_BIT;\n                        end\n                    end\n                end\n                \n                PARITY_BIT: begin\n                    if (rx_clk_count < CLKS_PER_BIT - 1) begin\n                        rx_clk_count <= rx_clk_count + 1;\n                    end else begin\n                        rx_clk_count <= 0;\n                        rx_parity_bit <= rx_in;\n                        \n                        // Check parity\n                        if (PARITY_TYPE == 0) begin  // Even parity\n                            rx_parity_error <= (rx_parity_calc != rx_in);\n                        end else begin  // Odd parity\n                            rx_parity_error <= (rx_parity_calc == rx_in);\n                        end\n                        \n                        rx_state <= STOP_BIT;\n                    end\n                end\n                \n                STOP_BIT: begin\n                    if (rx_clk_count < CLKS_PER_BIT - 1) begin\n                        rx_clk_count <= rx_clk_count + 1;\n                    end else begin\n                        rx_clk_count <= 0;\n                        \n                        if (rx_in == 1'b1) begin  // Valid stop bit\n                            if (STOP_BITS == 2 && rx_bit_index == 0) begin\n                                rx_bit_index <= 1;\n                            end else begin\n                                rx_state <= CLEANUP;\n                                rx_data_ready <= 1'b1;\n                                rx_bit_index <= 0;\n                            end\n                        end else begin  // Framing error\n                            rx_frame_error <= 1'b1;\n                            rx_state <= CLEANUP;\n                        end\n                    end\n                end\n                \n                CLEANUP: begin\n                    rx_state <= IDLE;\n                end\n                \n                default: rx_state <= IDLE;\n            endcase\n        end\n    end\n    \n    // Output assignments\n    assign UART_Ready = ~UART_Busy;\n    \n    // Data output register\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            data_out <= 8'b0;\n        end else if (rx_data_ready && !rx_frame_error && (!PARITY_EN || !rx_parity_error)) begin\n            data_out <= rx_data_reg;\n        end\n    end\n    \n    // Error flag\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            UART_Error <= 1'b0;\n        end else begin\n            if (rx_frame_error || (PARITY_EN && rx_parity_error)) begin\n                UART_Error <= 1'b1;\n            end else if (rx_state == IDLE) begin\n                UART_Error <= 1'b0;\n            end\n        end\n    end\n\nendmodule\n```\n\nThis UART controller implementation includes:\n\n1. **Configurable Parameters**:\n   - Clock frequency and baud rate\n   - Data bits (7 or 8)\n   - Parity enable and type (even/odd)\n   - Stop bits (1 or 2)\n\n2. **Full-Duplex Operation**:\n   - Independent transmitter and receiver FSMs\n   - Can transmit and receive simultaneously\n\n3. **Transmitter Features**:\n   - Start bit generation\n   - Data bit transmission\n   - Optional parity bit\n   - Configurable stop bits\n   - Busy flag during transmission\n\n4. **Receiver Features**:\n   - Start bit detection with validation\n   - Data bit sampling at mid-point\n   - Parity checking (if enabled)\n   - Framing error detection\n   - Input synchronization for metastability\n\n5. **Error Handling**:\n   - Framing errors (invalid stop bit)\n   - Parity errors (if parity enabled)\n   - False start bit detection\n\nThe module uses finite state machines for both TX and RX operations, ensuring reliable data transmission and reception. The baud rate is generated by counting system clock cycles based on the configured parameters.",
    "prompt_1": "Write a SystemVerilog module to implement a UART (Universal Asynchronous Receiver-Transmitter) controller. The module should support configurable baud rates, transmit and receive functionality, and proper start, data, parity (optional), and 2 stop bit handling. The UART should operate in full-duplex mode and adhere to the following interface:\nmodule UART_driver( input  logic       clk,        // System clock input  logic       rst,        // Asynchronous reset input  logic       UART_Start, // Signal to initiate transmission input  logic [8:0] data_in,    // Data to be transmitted input  logic       RX,         // UART receive line output logic       TX,         // UART transmit line output logic [8:0] data_out,   // Received data output logic       UART_Ready, // Ready to transmit next byte output logic       UART_Busy,  // Indicates UART is currently transmitting output logic       UART_Error  // High if framing or parity error detected ); ",
    "answer_1": "Here's a SystemVerilog implementation of a UART controller with the specified interface:\n\n```systemverilog\nmodule UART_driver(\n    input  logic       clk,        // System clock\n    input  logic       rst,        // Asynchronous reset\n    input  logic       UART_Start, // Signal to initiate transmission\n    input  logic [8:0] data_in,    // Data to be transmitted (bit 8 is parity enable)\n    input  logic       RX,         // UART receive line\n    output logic       TX,         // UART transmit line\n    output logic [8:0] data_out,   // Received data\n    output logic       UART_Ready, // Ready to transmit next byte\n    output logic       UART_Busy,  // Indicates UART is currently transmitting\n    output logic       UART_Error  // High if framing or parity error detected\n);\n\n    // Parameters for baud rate configuration\n    parameter CLK_FREQ = 50_000_000;  // 50 MHz system clock\n    parameter BAUD_RATE = 115200;     // Desired baud rate\n    parameter BAUD_DIV = CLK_FREQ / BAUD_RATE;\n    parameter BAUD_DIV_HALF = BAUD_DIV / 2;\n\n    // State definitions for TX FSM\n    typedef enum logic [2:0] {\n        TX_IDLE,\n        TX_START,\n        TX_DATA,\n        TX_PARITY,\n        TX_STOP1,\n        TX_STOP2\n    } tx_state_t;\n\n    // State definitions for RX FSM\n    typedef enum logic [2:0] {\n        RX_IDLE,\n        RX_START,\n        RX_DATA,\n        RX_PARITY,\n        RX_STOP1,\n        RX_STOP2\n    } rx_state_t;\n\n    // Internal signals\n    tx_state_t tx_state, tx_next_state;\n    rx_state_t rx_state, rx_next_state;\n    \n    // TX signals\n    logic [15:0] tx_baud_cnt;\n    logic tx_baud_tick;\n    logic [3:0] tx_bit_cnt;\n    logic [7:0] tx_shift_reg;\n    logic tx_parity_bit;\n    logic tx_parity_enable;\n    \n    // RX signals\n    logic [15:0] rx_baud_cnt;\n    logic rx_baud_tick;\n    logic [3:0] rx_bit_cnt;\n    logic [7:0] rx_shift_reg;\n    logic rx_parity_bit;\n    logic rx_parity_enable;\n    logic rx_parity_error;\n    logic rx_frame_error;\n    logic RX_sync, RX_sync_d;\n    \n    // Synchronize RX input to avoid metastability\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            RX_sync <= 1'b1;\n            RX_sync_d <= 1'b1;\n        end else begin\n            RX_sync <= RX;\n            RX_sync_d <= RX_sync;\n        end\n    end\n    \n    // TX Baud rate generator\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tx_baud_cnt <= 16'd0;\n            tx_baud_tick <= 1'b0;\n        end else begin\n            if (tx_state == TX_IDLE) begin\n                tx_baud_cnt <= 16'd0;\n                tx_baud_tick <= 1'b0;\n            end else if (tx_baud_cnt == BAUD_DIV - 1) begin\n                tx_baud_cnt <= 16'd0;\n                tx_baud_tick <= 1'b1;\n            end else begin\n                tx_baud_cnt <= tx_baud_cnt + 1'b1;\n                tx_baud_tick <= 1'b0;\n            end\n        end\n    end\n    \n    // RX Baud rate generator with mid-bit sampling\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_baud_cnt <= 16'd0;\n            rx_baud_tick <= 1'b0;\n        end else begin\n            if (rx_state == RX_IDLE) begin\n                rx_baud_cnt <= 16'd0;\n                rx_baud_tick <= 1'b0;\n            end else if (rx_state == RX_START && rx_baud_cnt == BAUD_DIV_HALF - 1) begin\n                // Sample at mid-bit for start bit\n                rx_baud_cnt <= 16'd0;\n                rx_baud_tick <= 1'b1;\n            end else if (rx_baud_cnt == BAUD_DIV - 1) begin\n                rx_baud_cnt <= 16'd0;\n                rx_baud_tick <= 1'b1;\n            end else begin\n                rx_baud_cnt <= rx_baud_cnt + 1'b1;\n                rx_baud_tick <= 1'b0;\n            end\n        end\n    end\n    \n    // TX FSM - State register\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            tx_state <= TX_IDLE;\n        else\n            tx_state <= tx_next_state;\n    end\n    \n    // TX FSM - Next state logic\n    always_comb begin\n        tx_next_state = tx_state;\n        \n        case (tx_state)\n            TX_IDLE: begin\n                if (UART_Start)\n                    tx_next_state = TX_START;\n            end\n            \n            TX_START: begin\n                if (tx_baud_tick)\n                    tx_next_state = TX_DATA;\n            end\n            \n            TX_DATA: begin\n                if (tx_baud_tick && tx_bit_cnt == 4'd7) begin\n                    if (tx_parity_enable)\n                        tx_next_state = TX_PARITY;\n                    else\n                        tx_next_state = TX_STOP1;\n                end\n            end\n            \n            TX_PARITY: begin\n                if (tx_baud_tick)\n                    tx_next_state = TX_STOP1;\n            end\n            \n            TX_STOP1: begin\n                if (tx_baud_tick)\n                    tx_next_state = TX_STOP2;\n            end\n            \n            TX_STOP2: begin\n                if (tx_baud_tick)\n                    tx_next_state = TX_IDLE;\n            end\n            \n            default: tx_next_state = TX_IDLE;\n        endcase\n    end\n    \n    // TX data path\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            TX <= 1'b1;\n            tx_shift_reg <= 8'd0;\n            tx_bit_cnt <= 4'd0;\n            tx_parity_bit <= 1'b0;\n            tx_parity_enable <= 1'b0;\n        end else begin\n            case (tx_state)\n                TX_IDLE: begin\n                    TX <= 1'b1;\n                    if (UART_Start) begin\n                        tx_shift_reg <= data_in[7:0];\n                        tx_parity_enable <= data_in[8];\n                        tx_parity_bit <= ^data_in[7:0]; // Even parity\n                        tx_bit_cnt <= 4'd0;\n                    end\n                end\n                \n                TX_START: begin\n                    TX <= 1'b0; // Start bit\n                end\n                \n                TX_DATA: begin\n                    TX <= tx_shift_reg[0];\n                    if (tx_baud_tick) begin\n                        tx_shift_reg <= {1'b0, tx_shift_reg[7:1]};\n                        tx_bit_cnt <= tx_bit_cnt + 1'b1;\n                    end\n                end\n                \n                TX_PARITY: begin\n                    TX <= tx_parity_bit;\n                end\n                \n                TX_STOP1, TX_STOP2: begin\n                    TX <= 1'b1; // Stop bits\n                end\n            endcase\n        end\n    end\n    \n    // RX FSM - State register\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            rx_state <= RX_IDLE;\n        else\n            rx_state <= rx_next_state;\n    end\n    \n    // RX FSM - Next state logic\n    always_comb begin\n        rx_next_state = rx_state;\n        \n        case (rx_state)\n            RX_IDLE: begin\n                if (!RX_sync_d) // Start bit detected\n                    rx_next_state = RX_START;\n            end\n            \n            RX_START: begin\n                if (rx_baud_tick) begin\n                    if (!RX_sync_d) // Verify start bit\n                        rx_next_state = RX_DATA;\n                    else\n                        rx_next_state = RX_IDLE; // False start\n                end\n            end\n            \n            RX_DATA: begin\n                if (rx_baud_tick && rx_bit_cnt == 4'd7) begin\n                    if (rx_parity_enable)\n                        rx_next_state = RX_PARITY;\n                    else\n                        rx_next_state = RX_STOP1;\n                end\n            end\n            \n            RX_PARITY: begin\n                if (rx_baud_tick)\n                    rx_next_state = RX_STOP1;\n            end\n            \n            RX_STOP1: begin\n                if (rx_baud_tick)\n                    rx_next_state = RX_STOP2;\n            end\n            \n            RX_STOP2: begin\n                if (rx_baud_tick)\n                    rx_next_state = RX_IDLE;\n            end\n            \n            default: rx_next_state = RX_IDLE;\n        endcase\n    end\n    \n    // RX data path\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_shift_reg <= 8'd0;\n            rx_bit_cnt <= 4'd0;\n            rx_parity_bit <= 1'b0;\n            rx_parity_enable <= 1'b0;\n            rx_parity_error <= 1'b0;\n            rx_frame_error <= 1'b0;\n            data_out <= 9'd0;\n        end else begin\n            case (rx_state)\n                RX_IDLE: begin\n                    rx_bit_cnt <= 4'd0;\n                    rx_parity_error <= 1'b0;\n                    rx_frame_error <= 1'b0;\n                    rx_parity_enable <= 1'b0; // Can be configured\n                end\n                \n                RX_DATA: begin\n                    if (rx_baud_tick) begin\n                        rx_shift_reg <= {RX_sync_d, rx_shift_reg[7:1]};\n                        rx_bit_cnt <= rx_bit_cnt + 1'b1;\n                    end\n                end\n                \n                RX_PARITY: begin\n                    if (rx_baud_tick) begin\n                        rx_parity_bit <= RX_sync_d;\n                        // Check parity\n                        if ((^rx_shift_reg) != RX_sync_d)\n                            rx_parity_error <= 1'b1;\n                    end\n                end\n                \n                RX_STOP1: begin\n                    if (rx_baud_tick && !RX_sync_d)\n                        rx_frame_error <= 1'b1;\n                end\n                \n                RX_STOP2: begin\n                    if (rx_baud_tick) begin\n                        if (!RX_sync_d)\n                            rx_frame_error <= 1'b1;\n                        else if (!rx_frame_error) begin\n                            data_out <= {rx_parity_enable, rx_shift_reg};\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n    \n    // Output assignments\n    assign UART_Ready = (tx_state == TX_IDLE);\n    assign UART_Busy = (tx_state != TX_IDLE);\n    assign UART_Error = rx_parity_error | rx_frame_error;\n\nendmodule\n```\n\nThis UART controller implementation includes:\n\n1. **Full-duplex operation**: Independent TX and RX state machines\n2. **Configurable baud rate**: Through parameters CLK_FREQ and BAUD_RATE\n3. **Start bit, data bits, optional parity, and 2 stop bits**: As per standard UART protocol\n4. **Parity support**: Bit 8 of data_in enables parity for transmission\n5. **Error detection**: Frame errors (incorrect stop bits) and parity errors\n6. **Synchronization**: RX input is synchronized to avoid metastability\n7. **Mid-bit sampling**: RX samples data at the middle of each bit for better reliability\n\nThe module can be easily configured for different baud rates by changing the parameters. The parity bit is optional and controlled by bit 8 of the data_in signal."
}
