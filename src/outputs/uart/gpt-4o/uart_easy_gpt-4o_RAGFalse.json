{
    "prompt_0": "Write a SystemVerilog module to implement a UART (Universal Asynchronous Receiver-Transmitter) controller. The module should support configurable baud rates, transmit and receive functionality, and proper start, data, parity (optional), and stop bit handling. The UART should operate in full-duplex mode and adhere to the following interface:\nmodule UART_driver( input  logic       clk,        // System clock input  logic       rst,        // Asynchronous reset input  logic       UART_Start, // Signal to initiate transmission input  logic [7:0] data_in,    // Data to be transmitted input  logic       RX,         // UART receive line output logic       TX,         // UART transmit line output logic [7:0] data_out,   // Received data output logic       UART_Ready, // Ready to transmit next byte output logic       UART_Busy,  // Indicates UART is currently transmitting output logic       UART_Error  // High if framing or parity error detected ); ",
    "answer_0": "```systemverilog\nmodule UART_driver(\n    input  logic       clk,        // System clock\n    input  logic       rst,        // Asynchronous reset\n    input  logic       UART_Start, // Signal to initiate transmission\n    input  logic [7:0] data_in,    // Data to be transmitted\n    input  logic       RX,         // UART receive line\n    output logic       TX,         // UART transmit line\n    output logic [7:0] data_out,   // Received data\n    output logic       UART_Ready, // Ready to transmit next byte\n    output logic       UART_Busy,  // Indicates UART is currently transmitting\n    output logic       UART_Error  // High if framing or parity error detected\n);\n\n    parameter BAUD_RATE    = 9600;     // Baud rate parameter\n    parameter CLOCK_FREQ   = 50000000; // System clock frequency in Hz\n    parameter DATA_BITS    = 8;\n    parameter PARITY_ENABLE = 0;       // Set to 1 to enable parity\n    parameter PARITY_ODD   = 0;       // Set to 1 for odd parity, 0 for even parity\n\n    localparam integer CLKS_PER_BIT = CLOCK_FREQ / BAUD_RATE;\n\n    typedef enum logic [2:0] {\n        IDLE,\n        START,\n        DATA,\n        PARITY,\n        STOP\n    } state_t;\n\n    logic [DATA_BITS-1:0] tx_shift_reg;\n    logic [DATA_BITS-1:0] rx_shift_reg;\n    logic [3:0] bit_count;\n    logic [15:0] clk_count;\n    state_t tx_state, rx_state;\n    logic parity_bit;\n\n    // Transmitter logic\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tx_state <= IDLE;\n            TX <= 1'b1;\n            UART_Busy <= 1'b0;\n            bit_count <= 4'b0;\n            clk_count <= 16'b0;\n            tx_shift_reg <= 8'b0;\n        end else begin\n            case (tx_state)\n                IDLE: begin\n                    UART_Busy <= 1'b0;\n                    if (UART_Start) begin\n                        tx_state <= START;\n                        tx_shift_reg <= data_in;\n                        parity_bit <= ^data_in ^ PARITY_ODD;\n                        clk_count <= 16'b0;\n                        bit_count <= 4'b0;\n                    end\n                end\n                START: begin\n                    TX <= 1'b0; // Start bit\n                    UART_Busy <= 1'b1;\n                    if (clk_count == CLKS_PER_BIT - 1) begin\n                        tx_state <= DATA;\n                        clk_count <= 16'b0;\n                    end else begin\n                        clk_count <= clk_count + 1;\n                    end\n                end\n                DATA: begin\n                    TX <= tx_shift_reg[0];\n                    if (clk_count == CLKS_PER_BIT - 1) begin\n                        clk_count <= 16'b0;\n                        tx_shift_reg <= tx_shift_reg >> 1;\n                        bit_count <= bit_count + 1;\n                        if (bit_count == DATA_BITS-1) begin\n                            if (PARITY_ENABLE) begin\n                                tx_state <= PARITY;\n                            end else begin\n                                tx_state <= STOP;\n                            end\n                        end\n                    end else begin\n                        clk_count <= clk_count + 1;\n                    end\n                end\n                PARITY: begin\n                    TX <= parity_bit;\n                    if (clk_count == CLKS_PER_BIT - 1) begin\n                        clk_count <= 16'b0;\n                        tx_state <= STOP;\n                    end else begin\n                        clk_count <= clk_count + 1;\n                    end\n                end\n                STOP: begin\n                    TX <= 1'b1; // Stop bit\n                    if (clk_count == CLKS_PER_BIT - 1) begin\n                        tx_state <= IDLE;\n                        UART_Ready <= 1'b1;\n                    end else begin\n                        clk_count <= clk_count + 1;\n                    end\n                end\n                default: tx_state <= IDLE;\n            endcase\n        end\n    end\n\n    // Receiver logic\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_state <= IDLE;\n            data_out <= 8'b0;\n            bit_count <= 4'b0;\n            clk_count <= 16'b0;\n            UART_Error <= 1'b0;\n        end else begin\n            case (rx_state)\n                IDLE: begin\n                    if (!RX) begin // Detect start bit\n                        rx_state <= START;\n                        clk_count <= 16'b0;\n                    end\n                end\n                START: begin\n                    if (clk_count == CLKS_PER_BIT-1) begin\n                        if (!RX) begin\n                            rx_state <= DATA;\n                            clk_count <= 16'b0;\n                            bit_count <= 4'b0;\n                        end else begin\n                            rx_state <= IDLE; // False start\n                        end\n                    end else begin\n                        clk_count <= clk_count + 1;\n                    end\n                end\n                DATA: begin\n                    if (clk_count == CLKS_PER_BIT/2 - 1) begin\n                        rx_shift_reg[bit_count] <= RX;\n                        clk_count <= 16'b0;\n                        bit_count <= bit_count + 1;\n                        if (bit_count == DATA_BITS-1) begin\n                            if (PARITY_ENABLE) begin\n                                rx_state <= PARITY;\n                            end else begin\n                                rx_state <= STOP;\n                            end\n                        end\n                    end else begin\n                        clk_count <= clk_count + 1;\n                    end\n                end\n                PARITY: begin\n                    if (clk_count == CLKS_PER_BIT-1) begin\n                        // Check parity\n                        parity_bit <= ^rx_shift_reg ^ PARITY_ODD;\n                        if (parity_bit != RX) begin\n                            UART_Error <= 1'b1;\n                        end\n                        rx_state <= STOP;\n                        clk_count <= 16'b0;\n                    end else begin\n                        clk_count <= clk_count + 1;\n                    end\n                end\n                STOP: begin\n                    if (clk_count == CLKS_PER_BIT-1) begin\n                        if (RX) begin\n                            data_out <= rx_shift_reg;\n                        end else begin\n                            UART_Error <= 1'b1; // Framing error\n                        end\n                        rx_state <= IDLE;\n                    end else begin\n                        clk_count <= clk_count + 1;\n                    end\n                end\n                default: rx_state <= IDLE;\n            endcase\n        end\n    end\nendmodule\n```\n",
    "prompt_1": "Write a SystemVerilog module to implement a UART (Universal Asynchronous Receiver-Transmitter) controller. The module should support configurable baud rates, transmit and receive functionality, and proper start, data, parity (optional), and 2 stop bit handling. The UART should operate in full-duplex mode and adhere to the following interface:\nmodule UART_driver( input  logic       clk,        // System clock input  logic       rst,        // Asynchronous reset input  logic       UART_Start, // Signal to initiate transmission input  logic [8:0] data_in,    // Data to be transmitted input  logic       RX,         // UART receive line output logic       TX,         // UART transmit line output logic [8:0] data_out,   // Received data output logic       UART_Ready, // Ready to transmit next byte output logic       UART_Busy,  // Indicates UART is currently transmitting output logic       UART_Error  // High if framing or parity error detected ); ",
    "answer_1": "```systemverilog\nmodule UART_driver(\n    input  logic       clk,        // System clock\n    input  logic       rst,        // Asynchronous reset\n    input  logic       UART_Start, // Signal to initiate transmission\n    input  logic [8:0] data_in,    // Data to be transmitted\n    input  logic       RX,         // UART receive line\n    output logic       TX,         // UART transmit line\n    output logic [8:0] data_out,   // Received data\n    output logic       UART_Ready, // Ready to transmit next byte\n    output logic       UART_Busy,  // Indicates UART is currently transmitting\n    output logic       UART_Error  // High if framing or parity error detected\n);\n\n    // Parameters\n    parameter BAUD_RATE = 9600;\n    parameter CLOCK_FREQ = 50000000;\n    \n    // Internal variables\n    logic [3:0] bit_cnt;           // Bit counter for data bits\n    logic [13:0] clk_div_cnt;      // Clock divider counter for generating baud rate\n    logic        sending;          // Transaction in progress flag\n    logic [9:0]  tx_shift_reg;     // TX shift register\n    logic [9:0]  rx_shift_reg;     // RX shift register\n    logic [3:0]  rx_bit_cnt;       // RX bit counter\n    logic        rx_sample;        // Sample RX line\n    \n    // Calculate clock divisor\n    localparam integer CLK_DIV = CLOCK_FREQ / (BAUD_RATE * 16);\n\n    // Initial assignments\n    initial begin\n        UART_Ready = 1'b1;\n        UART_Busy  = 1'b0;\n        UART_Error = 1'b0;\n        TX         = 1'b1;        // Idle state\n    end\n\n    // TX Process\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            bit_cnt      <= 4'b0;\n            clk_div_cnt  <= 14'b0;\n            sending      <= 1'b0;\n            UART_Busy    <= 1'b0;\n            UART_Ready   <= 1'b1;\n            TX           <= 1'b1;\n            tx_shift_reg <= 10'b1111111111;\n        end else begin\n            if (UART_Start && !sending) begin\n                // Load data into shift register with start and stop bits\n                tx_shift_reg <= {1'b1, data_in, 1'b0};\n                sending      <= 1'b1;\n                UART_Ready   <= 1'b0;\n                UART_Busy    <= 1'b1;\n                bit_cnt      <= 4'b0;\n            end\n\n            if (sending) begin\n                if (clk_div_cnt < CLK_DIV - 1) begin\n                    clk_div_cnt <= clk_div_cnt + 1'b1;\n                end else begin\n                    clk_div_cnt <= 14'b0;\n                    TX          <= tx_shift_reg[0];  // Output the current bit\n                    tx_shift_reg <= {1'b1, tx_shift_reg[9:1]}; // Shift the register\n\n                    if (bit_cnt == 4'd10) begin // End of transmission\n                        sending    <= 1'b0;\n                        UART_Ready <= 1'b1;\n                        UART_Busy  <= 1'b0;\n                    end else begin\n                        bit_cnt <= bit_cnt + 1'b1;\n                    end\n                end\n            end\n        end\n    end\n\n    // RX Process\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_bit_cnt <= 4'b0;\n            clk_div_cnt <= 14'b0;\n            rx_sample   <= 1'b1;\n            UART_Error  <= 1'b0;\n        end else begin\n            if (~RX && rx_bit_cnt == 4'b0) begin // Start bit detected\n                rx_bit_cnt <= 4'b1;\n                clk_div_cnt <= CLK_DIV / 2; // Adjust for middle of start bit sampling\n            end else if (rx_bit_cnt > 0) begin\n                if (clk_div_cnt < CLK_DIV - 1) begin\n                    clk_div_cnt <= clk_div_cnt + 1'b1;\n                end else begin\n                    clk_div_cnt <= 14'b0;\n                    rx_shift_reg <= {RX, rx_shift_reg[9:1]};  // Shift RX data in\n\n                    if (rx_bit_cnt == 4'b10) begin // Stop bit position\n                        if (RX == 1'b0) begin\n                            UART_Error <= 1'b1; // Framing or stop bit error\n                        end else begin\n                            UART_Error <= 1'b0;\n                            data_out   <= rx_shift_reg[8:1]; // Extract data bits\n                        end\n                        rx_bit_cnt <= 4'b0; // Reset for next reception\n                    end else begin\n                        rx_bit_cnt <= rx_bit_cnt + 1'b1;\n                    end\n                end\n            end\n        end\n    end\n\nendmodule\n```\n\nThis SystemVerilog module implements the core functionalities of a UART driver with full-duplex capabilities. It divides the clock to generate the baud rate, manages transmission and reception of data, and handles start, data, and stop bits correctly. Parity checking is optional and not included, but can be added if needed."
}
