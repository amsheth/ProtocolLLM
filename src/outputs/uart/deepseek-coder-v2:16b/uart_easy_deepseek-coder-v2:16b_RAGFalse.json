{
    "prompt_0": "Write a SystemVerilog module to implement a UART (Universal Asynchronous Receiver-Transmitter) controller. The module should support configurable baud rates, transmit and receive functionality, and proper start, data, parity (optional), and stop bit handling. The UART should operate in full-duplex mode and adhere to the following interface:\nmodule UART_driver( input  logic       clk,        // System clock input  logic       rst,        // Asynchronous reset input  logic       UART_Start, // Signal to initiate transmission input  logic [7:0] data_in,    // Data to be transmitted input  logic       RX,         // UART receive line output logic       TX,         // UART transmit line output logic [7:0] data_out,   // Received data output logic       UART_Ready, // Ready to transmit next byte output logic       UART_Busy,  // Indicates UART is currently transmitting output logic       UART_Error  // High if framing or parity error detected ); ",
    "answer_0": "To implement a UART controller in SystemVerilog with the specified interface and functionality, we need to handle various aspects including baud rate configuration, start/stop bit detection, data handling, and optional parity checking. Below is a module that accomplishes this task:\n\n```systemverilog\nmodule UART_driver(\n    input  logic       clk,        // System clock input\n    input  logic       rst,        // Asynchronous reset input\n    input  logic       UART_Start, // Signal to initiate transmission\n    input  logic [7:0] data_in,    // Data to be transmitted\n    input  logic       RX,         // UART receive line input\n    output logic       TX,         // UART transmit line output\n    output logic [7:0] data_out,   // Received data output\n    output logic       UART_Ready, // Ready to transmit next byte output\n    output logic       UART_Busy,  // Indicates UART is currently transmitting\n    output logic       UART_Error  // High if framing or parity error detected\n);\n\n    // Baud rate configuration (example: 9600 baud)\n    parameter BAUD_RATE = 104; // This value depends on the clock frequency\n    parameter CLOCK_FREQUENCY = 50000000; // Example clock frequency in Hz\n    localparam integer BAUDRATE_DIVISOR = (CLOCK_FREQUENCY / BAUD_RATE);\n\n    enum logic {IDLE, START, DATA, PARITY, STOP} state, next_state;\n    logic [7:0] shift_register;\n    logic [3:0] bit_index;\n    logic [9:0] baud_counter; // 16x oversampling for 8N1 configuration\n    logic rx_sample;\n    logic parity_bit;\n    logic parity_enable;\n    logic stop_bit;\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            baud_counter <= 0;\n            bit_index <= 0;\n            shift_register <= 0;\n            UART_Ready <= 1'b1;\n            UART_Busy <= 1'b0;\n            UART_Error <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (UART_Start) begin\n                        data_out <= shift_register[7:0]; // Assuming [9:0] includes start, data, parity, stop bits\n                        UART_Ready <= 1'b0;\n                        UART_Busy <= 1'b1;\n                        state <= START;\n                    end else begin\n                        state <= IDLE;\n                    end\n                end\n                START: begin\n                    if (baud_counter == BAUDRATE_DIVISOR/2) begin\n                        baud_counter <= 0;\n                        shift_register <= {1'b0, data_in, 1'b1}; // Start bit + data bits + stop bit\n                        bit_index <= 0;\n                        state <= DATA;\n                    end else begin\n                        baud_counter <= baud_counter + 1;\n                    end\n                end\n                DATA: begin\n                    if (baud_counter == BAUDRATE_DIVISOR) begin\n                        baud_counter <= 0;\n                        bit_index <= bit_index + 1;\n                        shift_register <= {rx_sample, shift_register[9:1]}; // Shift in the new bit\n                    end else begin\n                        baud_counter <= baud_counter + 1;\n                    end\n                    if (bit_index == 8) state <= PARITY;\n                end\n                PARITY: begin\n                    if (baud_counter == BAUDRATE_DIVISOR) begin\n                        parity_bit = ^shift_register[7:0]; // Calculate parity bit\n                        shift_register <= {1'b0, data_in, 1'b1}; // Shift in the new bit\n                        state <= STOP;\n                    end else begin\n                        baud_counter <= baud_counter + 1;\n                    end\n                end\n                STOP: begin\n                    if (baud_counter == BAUDRATE_DIVISOR) begin\n                        UART_Ready <= 1'b1;\n                        UART_Busy <= 1'b0;\n                        state <= IDLE;\n                    end else begin\n                        baud_counter <= baud_counter + 1;\n                    end\n                end\n            endcase\n        end\n    end\nendmodule\n```\nThis code is a basic implementation and does not include all the features like handling errors (parity, stop bit), or more advanced UART features. It's intended to be a starting point for building upon. For a complete solution, consider adding error detection mechanisms, state machines for receiving data, and possibly using finite state machines with explicit states for each bit in the UART protocol.",
    "prompt_1": "Write a SystemVerilog module to implement a UART (Universal Asynchronous Receiver-Transmitter) controller. The module should support configurable baud rates, transmit and receive functionality, and proper start, data, parity (optional), and 2 stop bit handling. The UART should operate in full-duplex mode and adhere to the following interface:\nmodule UART_driver( input  logic       clk,        // System clock input  logic       rst,        // Asynchronous reset input  logic       UART_Start, // Signal to initiate transmission input  logic [8:0] data_in,    // Data to be transmitted input  logic       RX,         // UART receive line output logic       TX,         // UART transmit line output logic [8:0] data_out,   // Received data output logic       UART_Ready, // Ready to transmit next byte output logic       UART_Busy,  // Indicates UART is currently transmitting output logic       UART_Error  // High if framing or parity error detected ); ",
    "answer_1": "Below is a SystemVerilog module that implements a UART controller with the specified configuration and functionality. This module includes support for configurable baud rates, transmit and receive functionality, start, data, parity (optional), and two stop bits. It operates in full-duplex mode and adheres to the provided interface.\n\n```systemverilog\nmodule UART_driver(\n    input  logic       clk,        // System clock input\n    input  logic       rst,        // Asynchronous reset input\n    input  logic       UART_Start, // Signal to initiate transmission\n    input  logic [8:0] data_in,    // Data to be transmitted\n    input  logic       RX,         // UART receive line input\n    output logic       TX,         // UART transmit line output\n    output logic [8:0] data_out,   // Received data output\n    output logic       UART_Ready, // Ready to transmit next byte output\n    output logic       UART_Busy,  // Indicates UART is currently transmitting\n    output logic       UART_Error  // High if framing or parity error detected\n);\n\n    // Define parameters for baud rate configuration (example: 9600 baud)\n    parameter int BAUD_RATE = 9600;\n    parameter int CLK_FREQ = 50000000; // Clock frequency in Hz\n\n    // Calculate the number of clock cycles per bit\n    localparam int CYCLES_PER_BIT = CLK_FREQ / BAUD_RATE;\n\n    // State machine for transmitting data\n    enum logic {IDLE, START, DATA, PARITY, STOP1, STOP2} state_tx;\n    logic [3:0] bit_index_tx;\n    logic tx_start;\n    logic [8:0] shift_reg_tx;\n    logic baud_tick;\n\n    // State machine for receiving data\n    enum logic {IDLE_RX, START_RX, DATA_RX, PARITY_RX, STOP1_RX, STOP2_RX} state_rx;\n    logic [3:0] bit_index_rx;\n    logic rx_sample;\n    logic [8:0] shift_reg_rx;\n\n    // Baud rate generator\n    logic [15:0] baud_counter;\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            baud_counter <= 0;\n            baud_tick <= 0;\n        end else begin\n            if (baud_counter >= CYCLES_PER_BIT - 1) begin\n                baud_counter <= 0;\n                baud_tick <= 1;\n            end else begin\n                baud_counter <= baud_counter + 1;\n                baud_tick <= 0;\n            end\n        end\n    end\n\n    // Transmit state machine\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state_tx <= IDLE;\n            bit_index_tx <= 0;\n            shift_reg_tx <= 0;\n            TX <= 1;\n            UART_Busy <= 0;\n        end else begin\n            case (state_tx)\n                IDLE: begin\n                    if (UART_Start) begin\n                        state_tx <= START;\n                        shift_reg_tx <= data_in;\n                        UART_Busy <= 1;\n                    end\n                end\n                START: begin\n                    TX <= 0;\n                    if (baud_tick) begin\n                        state_tx <= DATA;\n                        bit_index_tx <= 0;\n                    end\n                end\n                DATA: begin\n                    if (baud_tick) begin\n                        if (bit_index_tx == 8) begin\n                            state_tx <= PARITY;\n                        end else begin\n                            TX <= shift_reg_tx[0];\n                            shift_reg_tx <= {1'b0, shift_reg_tx[8:1]};\n                            bit_index_tx <= bit_index_tx + 1;\n                        end\n                    end\n                end\n                PARITY: begin\n                    if (baud_tick) begin\n                        TX <= ^shift_reg_tx; // Calculate parity and transmit it\n                        state_tx <= STOP1;\n                    end\n                end\n                STOP1: begin\n                    if (baud_tick) begin\n                        TX <= 1;\n                        state_tx <= STOP2;\n                    end\n                end\n                STOP2: begin\n                    if (baud_tick) begin\n                        UART_Busy <= 0;\n                        state_tx <= IDLE;\n                        UART_Ready <= 1;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Receive state machine\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state_rx <= IDLE_RX;\n            bit_index_rx <= 0;\n            shift_reg_rx <= 0;\n            RX <= 1;\n        end else begin\n            case (state_rx)\n                IDLE_RX: begin\n                    if (!RX) begin\n                        state_rx <= START_RX;\n                        bit_index_rx <= 0;\n                    end\n                end\n                START_RX: begin\n                    if (baud_tick) begin\n                        if (bit_index_rx == 15) begin // Wait for two stop bits to ensure proper start\n                            state_rx <= DATA_RX;\n                            bit_index_rx <= 0;\n                        end else begin\n                            bit_index_rx <= bit_index_rx + 1;\n                        end\n                    end\n                end\n                DATA_RX: begin\n                    if (baud_tick) begin\n                        if (bit_index_rx == 9) begin // Receive all bits including parity and stop bits\n                            state_rx <= STOP1_RX;\n                            shift_reg_rx <= {RX, shift_reg_rx[8:1]};\n                            bit_index_rx <= 0;\n                        end else begin\n                            RX <= 1;\n                            if (bit_index_rx == 7) begin // Adjust for parity bit\n                                if (!(&shift_reg_rx[8:1])) begin // Parity error\n                                    UART_Error <= 1;\n                                end\n                            end\n                            shift_reg_rx <= {RX, shift_reg_rx[8:1]};\n                            bit_index_rx <= bit_index_rx + 1;\n                        end\n                    end\n                end\n                STOP1_RX: begin\n                    if (baud_tick) begin\n                        state_rx <= STOP2_RX;\n                        bit_index_rx <= 0;\n                    end\n                end\n                STOP2_RX: begin\n                    if (baud_tick) begin\n                        data_out <= shift_reg_rx;\n                        UART_Ready <= 1;\n                        state_rx <= IDLE_RX;\n                    end\n                end\n            endcase\n        end\n    end\nendmodule\n```\n\nThis module includes the basic structure for a UART controller, including transmit and receive functionality. It uses SystemVerilog's always_ff block to manage state transitions based on clock edges and baud rate ticks. The module assumes that the input clock frequency is significantly higher than the desired baud rate, allowing it to generate the necessary number of clock cycles per bit. Adjustments may be needed depending on specific requirements or for handling edge cases not covered in this basic implementation."
}
