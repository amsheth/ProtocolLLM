{
    "prompt_0": "Write a SystemVerilog module to implement a UART (Universal Asynchronous Receiver-Transmitter) controller. The module should support configurable baud rates, transmit and receive functionality, and proper start, data, parity (optional), and stop bit handling. The UART should operate in full-duplex mode and adhere to the following interface:\nmodule UART_driver( input  logic       clk,        // System clock input  logic       rst,        // Asynchronous reset input  logic       UART_Start, // Signal to initiate transmission input  logic [7:0] data_in,    // Data to be transmitted input  logic       RX,         // UART receive line output logic       TX,         // UART transmit line output logic [7:0] data_out,   // Received data output logic       UART_Ready, // Ready to transmit next byte output logic       UART_Busy,  // Indicates UART is currently transmitting output logic       UART_Error  // High if framing or parity error detected ); ",
    "answer_0": "```systemverilog\n//============================================================\n//  UART_driver.sv\n//\n//  Full-duplex, 8-bit asynchronous UART controller\n//  \u2011 1 start bit\n//  \u2011 8 data bits (LSB first)\n//  \u2011 Optional parity (even / odd / none)\n//  \u2011 1 stop bit\n//  Parameterisable clock-rate, baud-rate and oversampling\n//============================================================\n`timescale 1ns/1ps\nmodule UART_driver\n#(\n    // ------------------------------------------\n    // User parameters\n    // ------------------------------------------\n    parameter longint  CLOCK_FREQ  = 50_000_000,  // Hz\n    parameter longint  BAUD_RATE   = 115_200,     // bps\n    parameter int      OVERSAMPLE  = 16,          // Must be power-of-2 \u2265 8\n    parameter string   PARITY      = \"NONE\"       // \"NONE\",\"EVEN\",\"ODD\"\n)\n(\n    input  logic       clk,         // System clock\n    input  logic       rst,         // Asynchronous reset (active-high)\n\n    // Transmit interface\n    input  logic       UART_Start,  // Pulse to start TX of data_in\n    input  logic [7:0] data_in,     // Byte to transmit\n    output logic       UART_Ready,  // High when idle / ready\n    output logic       UART_Busy,   // High while shifting a frame\n    output logic       TX,          // UART TX line (idle = 1)\n\n    // Receive interface\n    input  logic       RX,          // UART RX line (idle = 1)\n    output logic [7:0] data_out,    // Last correctly received byte\n    output logic       UART_Error   // Parity or framing error flag\n);\n\n    // ---------------------------------------------------------\n    //  Derived constants\n    // ---------------------------------------------------------\n    localparam longint BAUD_DIV     = CLOCK_FREQ / BAUD_RATE;              // TX bit-time divider\n    localparam longint SAMPLE_DIV   = CLOCK_FREQ / (BAUD_RATE * OVERSAMPLE); // RX oversample divider\n\n    localparam bit PARITY_EN  = (PARITY != \"NONE\");\n    localparam bit PARITY_EVN = (PARITY == \"EVEN\");\n\n    // ---------------------------------------------------------\n    //  Baud-rate generator (shared)\n    // ---------------------------------------------------------\n    logic [31:0] baud_cnt;\n    logic        baud_tick;\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            baud_cnt  <= '0;\n            baud_tick <= 1'b0;\n        end else if (baud_cnt == BAUD_DIV - 1) begin\n            baud_cnt  <= '0;\n            baud_tick <= 1'b1;\n        end else begin\n            baud_cnt  <= baud_cnt + 1;\n            baud_tick <= 1'b0;\n        end\n    end\n\n    // ---------------------------------------------------------\n    //  TRANSMITTER\n    // ---------------------------------------------------------\n    localparam int EXTRA_BITS  = PARITY_EN ? 1 : 0;\n    localparam int FRAME_BITS  = 1 /*start*/ + 8 /*data*/ + EXTRA_BITS + 1 /*stop*/;\n\n    typedef enum logic [1:0] { TX_IDLE, TX_SHIFT } tx_state_t;\n    tx_state_t            tx_state;\n    logic [FRAME_BITS-1:0] tx_shift_reg;\n    logic [$clog2(FRAME_BITS):0] tx_bit_cnt;\n\n    // ready / busy flags\n    assign UART_Ready = (tx_state == TX_IDLE);\n    assign UART_Busy  = (tx_state != TX_IDLE);\n\n    // TX output register (idle high)\n    assign TX = tx_shift_reg[0];\n\n    // Build frame and start\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tx_state      <= TX_IDLE;\n            tx_shift_reg  <= {FRAME_BITS{1'b1}};\n            tx_bit_cnt    <= '0;\n        end else begin\n            case (tx_state)\n                //-------------------------------------------------\n                TX_IDLE : begin\n                    tx_shift_reg <= {FRAME_BITS{1'b1}}; // keep line high\n                    if (UART_Start) begin\n                        // Calculate parity when enabled\n                        logic parity_bit;\n                        if (PARITY_EN) begin\n                            parity_bit = ^data_in;               // even parity by default\n                            if (!PARITY_EVN) parity_bit = ~parity_bit; // odd parity\n                        end\n                        // Assemble frame (LSB first)\n                        tx_shift_reg <= {\n                            1'b1,                           // Stop bit (MSB shifted last)\n                            (PARITY_EN ? parity_bit : 1'b1),// Parity (ignored if disabled)\n                            data_in,                        // 8 data bits\n                            1'b0                            // Start bit (LSB shifted first)\n                        };\n                        tx_bit_cnt   <= FRAME_BITS;\n                        tx_state     <= TX_SHIFT;\n                    end\n                end\n                //-------------------------------------------------\n                TX_SHIFT : begin\n                    if (baud_tick) begin\n                        tx_shift_reg <= {1'b1, tx_shift_reg[FRAME_BITS-1:1]}; // logical right shift\n                        if (tx_bit_cnt == 1) begin\n                            tx_state <= TX_IDLE;\n                        end\n                        tx_bit_cnt <= tx_bit_cnt - 1;\n                    end\n                end\n                //-------------------------------------------------\n            endcase\n        end\n    end\n\n    // ---------------------------------------------------------\n    //  RECEIVER\n    // ---------------------------------------------------------\n    typedef enum logic [2:0] { RX_IDLE, RX_START, RX_DATA, RX_PARITY, RX_STOP } rx_state_t;\n    rx_state_t      rx_state;\n\n    logic [7:0]     rx_shift_reg;\n    logic [3:0]     rx_bit_cnt;               // Counts 8 data bits\n    logic [3:0]     os_cnt;                   // Oversample counter (0 .. OVERSAMPLE-1)\n    logic [31:0]    sample_cnt;               // Divider counter -> sample_tick\n    logic           sample_tick;              // Tick at the oversample rate\n    logic           rx_parity_bit;\n    logic           parity_err, framing_err;\n\n    // -------------------------------------------------\n    // Oversample clock (sample_tick)\n    // -------------------------------------------------\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sample_cnt  <= '0;\n            sample_tick <= 1'b0;\n        end else if (sample_cnt == SAMPLE_DIV - 1) begin\n            sample_cnt  <= '0;\n            sample_tick <= 1'b1;\n        end else begin\n            sample_cnt  <= sample_cnt + 1;\n            sample_tick <= 1'b0;\n        end\n    end\n\n    // -------------------------------------------------\n    // Receiver FSM\n    // -------------------------------------------------\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_state     <= RX_IDLE;\n            os_cnt       <= '0;\n            rx_bit_cnt   <= '0;\n            rx_shift_reg <= '0;\n            rx_parity_bit<= 1'b0;\n            parity_err   <= 1'b0;\n            framing_err  <= 1'b0;\n            data_out     <= 8'h00;\n        end else if (sample_tick) begin\n            case (rx_state)\n                //-------------------------------------------------\n                RX_IDLE : begin\n                    parity_err  <= 1'b0;\n                    framing_err <= 1'b0;\n                    if (!RX) begin              // Detect start bit (logic 0)\n                        rx_state <= RX_START;\n                        os_cnt   <= 0;\n                    end\n                end\n                //-------------------------------------------------\n                RX_START : begin\n                    if (os_cnt == (OVERSAMPLE/2 - 1)) begin // Mid-bit sample\n                        if (!RX) begin       // Validate start bit still low\n                            rx_state <= RX_DATA;\n                            os_cnt   <= 0;\n                            rx_bit_cnt <= 0;\n                        end else begin       // False start, go back idle\n                            rx_state <= RX_IDLE;\n                        end\n                    end else begin\n                        os_cnt <= os_cnt + 1;\n                    end\n                end\n                //-------------------------------------------------\n                RX_DATA : begin\n                    if (os_cnt == OVERSAMPLE - 1) begin\n                        os_cnt <= 0;\n                        rx_shift_reg <= {RX, rx_shift_reg[7:1]}; // LSB first\n                        rx_bit_cnt   <= rx_bit_cnt + 1;\n                        if (rx_bit_cnt == 7) begin\n                            if (PARITY_EN)\n                                rx_state <= RX_PARITY;\n                            else\n                                rx_state <= RX_STOP;\n                        end\n                    end else begin\n                        os_cnt <= os_cnt + 1;\n                    end\n                end\n                //-------------------------------------------------\n                RX_PARITY : begin\n                    if (os_cnt == OVERSAMPLE - 1) begin\n                        os_cnt <= 0;\n                        rx_parity_bit <= RX;\n                        // Check parity at the end of stop bit to avoid extra logic\n                        rx_state <= RX_STOP;\n                    end else begin\n                        os_cnt <= os_cnt + 1;\n                    end\n                end\n                //-------------------------------------------------\n                RX_STOP : begin\n                    if (os_cnt == OVERSAMPLE - 1) begin\n                        os_cnt <= 0;\n                        // Framing error if stop bit is not high\n                        framing_err <= ~RX;\n                        // Parity check\n                        if (PARITY_EN) begin\n                            logic calc_parity = ^rx_shift_reg;\n                            if (!PARITY_EVN)  // ODD parity\n                                calc_parity = ~calc_parity;\n                            parity_err <= (calc_parity != rx_parity_bit);\n                        end\n                        // Latch received byte\n                        if (!framing_err && !parity_err)\n                            data_out <= rx_shift_reg;\n                        rx_state <= RX_IDLE;\n                    end else begin\n                        os_cnt <= os_cnt + 1;\n                    end\n                end\n                //-------------------------------------------------\n            endcase\n        end\n    end\n\n    // ---------------------------------------------------------\n    //  Error flag output (sticky until next correctly received byte)\n    // ---------------------------------------------------------\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            UART_Error <= 1'b0;\n        end else if (parity_err || framing_err) begin\n            UART_Error <= 1'b1;\n        end else if (rx_state == RX_IDLE && sample_tick && !parity_err && !framing_err) begin\n            UART_Error <= 1'b0;  // Clear on good frame\n        end\n    end\n\nendmodule\n```",
    "prompt_1": "Write a SystemVerilog module to implement a UART (Universal Asynchronous Receiver-Transmitter) controller. The module should support configurable baud rates, transmit and receive functionality, and proper start, data, parity (optional), and 2 stop bit handling. The UART should operate in full-duplex mode and adhere to the following interface:\nmodule UART_driver( input  logic       clk,        // System clock input  logic       rst,        // Asynchronous reset input  logic       UART_Start, // Signal to initiate transmission input  logic [8:0] data_in,    // Data to be transmitted input  logic       RX,         // UART receive line output logic       TX,         // UART transmit line output logic [8:0] data_out,   // Received data output logic       UART_Ready, // Ready to transmit next byte output logic       UART_Busy,  // Indicates UART is currently transmitting output logic       UART_Error  // High if framing or parity error detected ); ",
    "answer_1": "```systemverilog\n// -----------------------------------------------------------------------------\n// Universal Asynchronous Receiver / Transmitter (UART) \u2013 full-duplex\n//  \u2022 8 data bits\n//  \u2022 optional parity bit (even / odd)\n//  \u2022 2 stop bits\n//  \u2022 parameterised baud-rate\n//\n// Interface -------------------------------------------------------------------\n//   clk         : System clock\n//   rst         : Asynchronous reset (active-high)\n//   UART_Start  : Pulse-high to start a transmission of data_in\n//   data_in [8] :  {parity , 8-bit data}   \u2013 parity bit is ignored when\n//                  PARITY_ENABLE = 0.  LSB is the first bit sent on the line\n//   RX          : Serial data from external device\n//   TX          : Serial data to   external device\n//   data_out[8] : {parity , 8-bit data} captured after a complete frame\n//   UART_Ready  : High when transmitter can accept a new byte\n//   UART_Busy   : High while a byte is being transmitted\n//   UART_Error  : One-clock-cycle-wide pulse on framing or parity error\n// -----------------------------------------------------------------------------\nmodule UART_driver #(\n    parameter int CLOCK_FREQ     = 50_000_000,      // Hz\n    parameter int BAUD_RATE      =     115_200,     // bps\n    parameter bit PARITY_ENABLE  = 1'b1,            // 1 = parity bit present\n    parameter bit PARITY_EVEN    = 1'b1             // 1 = even, 0 = odd\n)(\n    input  logic        clk,\n    input  logic        rst,\n\n    // transmitter side\n    input  logic        UART_Start,\n    input  logic [8:0]  data_in,          // {parity,data[7:0]}\n\n    // receiver side\n    input  logic        RX,\n\n    // outputs\n    output logic        TX,\n    output logic [8:0]  data_out,         // {parity,data[7:0]}\n    output logic        UART_Ready,\n    output logic        UART_Busy,\n    output logic        UART_Error\n);\n\n    //--------------------------------------------------------------------------\n    //  Common baud-tick generator\n    //--------------------------------------------------------------------------\n    localparam int BAUD_DIV = CLOCK_FREQ / BAUD_RATE;        // \u22651\n    localparam int CNT_W    = $clog2(BAUD_DIV);\n\n    logic [CNT_W-1:0] baud_cnt;\n    logic             baud_tick;\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            baud_cnt  <= '0;\n            baud_tick <= 1'b0;\n        end\n        else if (baud_cnt == BAUD_DIV-1) begin\n            baud_cnt  <= '0;\n            baud_tick <= 1'b1;\n        end\n        else begin\n            baud_cnt  <= baud_cnt + 1'b1;\n            baud_tick <= 1'b0;\n        end\n    end\n\n    //--------------------------------------------------------------------------\n    //  TRANSMITTER\n    //--------------------------------------------------------------------------\n    typedef enum logic [2:0] { TX_IDLE, TX_START, TX_DATA,\n                               TX_PARITY, TX_STOP1, TX_STOP2 } tx_state_t;\n\n    tx_state_t   tx_state;\n    logic [3:0]  tx_bit_idx;        // counts data bits (0-7)\n    logic [8:0]  tx_shift;          // {parity/data}\n    logic        calc_parity;\n\n    assign UART_Ready = (tx_state == TX_IDLE);\n    assign UART_Busy  = ~UART_Ready;\n\n    // generate TX line\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tx_state    <= TX_IDLE;\n            tx_shift    <= '0;\n            tx_bit_idx  <= '0;\n            calc_parity <= 1'b0;\n            TX          <= 1'b1;            // line is high when idle\n        end\n        else begin\n            if (tx_state == TX_IDLE) begin\n                TX <= 1'b1;                 // keep line high\n                if (UART_Start) begin\n                    // load data and advance to START\n                    tx_shift[7:0] <= data_in[7:0];\n                    if (PARITY_ENABLE) begin\n                        // compute parity on 8 data bits\n                        calc_parity        <= ^data_in[7:0] ^ PARITY_EVEN; // even/odd\n                        tx_shift[8]        <= '0;   // placeholder\n                    end\n                    tx_bit_idx  <= 4'd0;\n                    tx_state    <= TX_START;\n                end\n            end\n\n            else if (baud_tick) begin\n                unique case (tx_state)\n\n                    TX_START: begin\n                        TX       <= 1'b0;                       // start bit\n                        tx_state <= TX_DATA;\n                    end\n\n                    TX_DATA: begin\n                        TX <= tx_shift[tx_bit_idx];             // LSB first\n                        if (tx_bit_idx == 4'd7) begin\n                            tx_state <= PARITY_ENABLE ? TX_PARITY : TX_STOP1;\n                        end\n                        tx_bit_idx <= tx_bit_idx + 1'b1;\n                    end\n\n                    TX_PARITY: begin\n                        TX       <= calc_parity;\n                        tx_state <= TX_STOP1;\n                    end\n\n                    TX_STOP1: begin\n                        TX       <= 1'b1;\n                        tx_state <= TX_STOP2;\n                    end\n\n                    TX_STOP2: begin\n                        TX       <= 1'b1;\n                        tx_state <= TX_IDLE;\n                    end\n\n                    default: tx_state <= TX_IDLE;\n                endcase\n            end\n        end\n    end\n\n    //--------------------------------------------------------------------------\n    //  RECEIVER\n    //--------------------------------------------------------------------------\n    typedef enum logic [2:0] { RX_IDLE, RX_START, RX_DATA,\n                               RX_PARITY, RX_STOP1, RX_STOP2 } rx_state_t;\n\n    rx_state_t  rx_state;\n    logic [3:0] rx_bit_idx;\n    logic [7:0] rx_shift;\n    logic       rx_parity_bit;\n    logic       sample_tick;                    // tick centred in bit time\n    logic [CNT_W-1:0] bit_cnt;                  // local counter for centring\n\n    // centering counter : generate sample_tick in the middle of each bit\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            bit_cnt     <= '0;\n            sample_tick <= 1'b0;\n        end\n        else begin\n            sample_tick <= 1'b0;\n            if (rx_state == RX_IDLE) begin\n                bit_cnt <= BAUD_DIV/2;          // vigilantly centre first sample\n            end\n            else if (bit_cnt == BAUD_DIV-1) begin\n                bit_cnt     <= '0';\n                sample_tick <= 1'b1;            // strobe to grab RX\n            end\n            else begin\n                bit_cnt <= bit_cnt + 1'b1;\n            end\n        end\n    end\n\n    // main receiver FSM\n    logic framing_error, parity_error;\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_state      <= RX_IDLE;\n            rx_bit_idx    <= '0;\n            rx_shift      <= '0;\n            rx_parity_bit <= 1'b0;\n            framing_error <= 1'b0;\n            parity_error  <= 1'b0;\n            data_out      <= '0;\n            UART_Error    <= 1'b0;\n        end\n        else begin\n            UART_Error <= 1'b0;                // default \u2013 pulse only on error\n\n            case (rx_state)\n\n                RX_IDLE: begin\n                    if (~RX) begin              // detect start bit (falling edge)\n                        rx_state   <= RX_START;\n                        bit_cnt    <= BAUD_DIV/2;  // already started; recalc\n                    end\n                end\n\n                RX_START: if (sample_tick) begin\n                    if (~RX) begin              // still low? valid start\n                        rx_bit_idx <= 4'd0;\n                        rx_state   <= RX_DATA;\n                    end\n                    else begin                  // false start\n                        rx_state <= RX_IDLE;\n                    end\n                end\n\n                RX_DATA: if (sample_tick) begin\n                    rx_shift[rx_bit_idx] <= RX; // LSB first\n                    if (rx_bit_idx == 4'd7) begin\n                        rx_state <= PARITY_ENABLE ? RX_PARITY : RX_STOP1;\n                    end\n                    rx_bit_idx <= rx_bit_idx + 1'b1;\n                end\n\n                RX_PARITY: if (sample_tick) begin\n                    rx_parity_bit <= RX;\n                    rx_state      <= RX_STOP1;\n                end\n\n                RX_STOP1: if (sample_tick) begin\n                    if (RX) begin\n                        rx_state <= RX_STOP2;\n                    end\n                    else begin\n                        framing_error <= 1'b1;\n                        rx_state      <= RX_IDLE;\n                    end\n                end\n\n                RX_STOP2: if (sample_tick) begin\n                    if (RX) begin\n                        // frame finished \u2013 check parity & output byte\n                        if (PARITY_ENABLE) begin\n                            parity_error <= (rx_parity_bit ^\n                                             (^rx_shift) ^\n                                             PARITY_EVEN);\n                        end\n                        else parity_error <= 1'b0;\n\n                        data_out <= {rx_parity_bit, rx_shift};\n\n                        if (framing_error | parity_error) begin\n                            UART_Error <= 1'b1;\n                        end\n                    end\n                    else framing_error <= 1'b1;\n\n                    // Go back idle for next byte\n                    rx_state       <= RX_IDLE;\n                    framing_error  <= 1'b0;\n                    parity_error   <= 1'b0;\n                end\n\n                default: rx_state <= RX_IDLE;\n\n            endcase\n        end\n    end\n\nendmodule\n```"
}
