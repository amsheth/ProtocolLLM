{
    "prompt_0": "protocol and the second tests the binary protocol. The test bench uses a register file model to simulate write and read operations. The following table summarizes the synthesis results of the core for different FPGA families. ManufacturerFamilyDevice Device UtilizationElements UtilizationFmax XilinxSpartan 3xc3s50-5pq208 24.00%186 Slices>150MHz XilinxVirtex 5xc5vlx30-3ff324 2.00%111 Slices>200MHz AlteraCyclone IIIep3c5f256c6 5.00%255 LEs>200MHz AlteraStartix IIIep3sl50f484c2 <1%167 Registers 218 ALUTs>200MHz Lattice1MachXOLCMXO2280C- 4T144C10.00%116 Slices> 100MHz Table 1: Synthesis Results for Different FPGA Devices The above results where obtained using the following software versions: \u2022Xilinx ISE Webpack 11.4 \u2022Altera Quartus Web Edition 9.1sp2 NOTE: The UART to Bus core is not Wishbone compatible although modifying it for Wishbone is probably possible. 1Lattice device synthesis results provided by Paul V. Shatov. Results provided before adding bus request/grant mechanism. UART to Bus Core Specifications Page 4 of 10 February 25, 2012 3.Architecture The UART to Bus architecture is fairly simple. The core is includes a UART interface module, which includes both receive and transmit modules, and the command parser. The following figure depicts a block diagram of the core. Figure 1: UART to Bus Core Block Diagram The UART interface is based on an implementation found in the c16 project in OpenCores (http://www.opencores.org/project,c16 ). The interface includes a UART receive and transmit modules that share a single baud rate generator module. The baud rate is set using two constants defined at the core top module which are calculated as follows: D_BAUD_FREQ=16\u22c5BaudRate gcd\ue09eGlobalClockFreq,16\u2217BaudRate\ue09f D_BAUD_LIMIT=GlobalClockFreq gcd\ue09eGlobalClockFreq,16\u22c5BaudRate\ue09f\u2212D_BAUD_FREQ A short Scilab script which calculates the above parameters is added under the \u201cscilab\u201d directory with the core files. The interface between the \u201cuart_parser.v\u201d module and the \u201cuart_top.v\u201d is very simple and uses only five signals. For cases where the UART interface is not possible or another interface is preferred, the \u201cuart_parser.v\u201d module can be used as is with a different interface implementation. UART to Bus Core Specifications Page 5 of 10 uart_tx.v uart_rx.v baud_gen.vuart_top.v uart_parser.vuart2bus_top.v ser_out ser_inint_address int_wr_data16 8 int_write int_read int_rd_data 8 clock resetint_req int_gntFebruary 25, 2012 4.Operation This section describes the protocols used to access the internal bus from the UART interface. As mentioned above the parser supports two modes of operation: text & binary commands. To distinguish between the two protocols all binary commands start with a value of zero which will not be sent when using the text protocol. The following drawing depicts a simplified state machine of the parser. The figure does not include some transitions used to abort illegal command sequences. Figure 2: Parser State Diagram In the state diagram above the states on the right are used for the text mode protocol and the states on the left are used for the binary mode protocol. The following sub-sections describe each of the protocols. 4.1.Text Mode Protocol The text mode protocol includes only two commands: address read and address write. All values are in HEX format. The parser checks for both upper and lower characters, detects both space (0x20) and tab (0x09) as white spaces and both LF (0x0A) and CR (0x0D) as end of\nUART to Bus Core Specifications Written for publication on: File name: UART to Bus Core Specifications Version: 1.0 Creation Date: February 12, 2010 Update Date: February 25, 2012 Author: Moti Litochevski February 25, 2012 Table of Contents 1. Preface.............................................................................................................................................. 3 1.1. Scope........................................................................................................................................ 3 1.2. Revision History ....................................................................................................................... 3 1.3. Abbreviations........................................................................................................................... 3 2. Introduction...................................................................................................................................... 4 3. Architecture...................................................................................................................................... 5 4. Operation.......................................................................................................................................... 6 4.1. Text Mode Protocol .................................................................................................................. 6 4.2. Binary Mode Protocol .............................................................................................................. 7 5. Core Interfaces................................................................................................................................. 9 6. Test Bench Description .................................................................................................................. 10 Index of Tables Table 1: Synthesis Results for Different FPGA Devices ..................................................................... 4 Table 2: Text Protocol Read Command Format .................................................................................. 7 Table 3: Text Protocol Write Command Format ................................................................................. 7 Table 4: Binary Protocol Command Format ........................................................................................ 8 Table 5: Binary Protocol Return Message Format .............................................................................. 8 Table 6: Core Interfaces Description ................................................................................................... 9 Index of Figures Figure 1: UART to Bus Core Block Diagram ..................................................................................... 5 Figure 2: Parser State Diagram ............................................................................................................ 6 UART to Bus Core Specifications Page 2 of 10 February 25, 2012 1.Preface 1.1.Scope This document describes the UART to Bus IP core operation, architecture and interfaces. 1.2.Revision History RevDateAuthor Description 0.102/13/10Moti Litochevski First Draft 0.204/02/10Moti Litochevski Adding test bench description section 0.304/15/11Moti Litochevski Added Lattice MachXO device utilization provided by Paul V. Shatov. 1.002/25/12Moti Litochevski Updated interface description and synthesis results after adding bus request/grant mechanism. 1.3.Abbreviations UARTUniversal Asynchronous Receiver / Transmitter UART to Bus Core Specifications Page 3 of 10 February 25, 2012 2.Introduction The UART to Bus IP Core is a simple command parser that can be used to access an internal bus via a UART interface. This core can be used during initial board debugging or as a permanent solution when high speed interfaces are not required. The internal bus is designed with address bus of 16 bits and data bus of 8 bits. The core implements a very basic UART transmit & receive blocks which share a common baud rate generator and a command parser. The parser supports two modes of operation: text mode commands and binary mode commands. Text mode commands are designed to be used with a hyper terminal software and enable easy access to the internal bus. Binary mode commands are more efficient and also support buffered read & write operations with or without automatic address increment. The core was verified using Icarus Verilog simulator with two test benches: the first tests the text mode protocol and the second tests the binary protocol. The test bench uses a register file model to simulate write and read operations. The following table summarizes the synthesis results of the core for different FPGA families. ManufacturerFamilyDevice Device UtilizationElements UtilizationFmax XilinxSpartan 3xc3s50-5pq208 24.00%186 Slices>150MHz XilinxVirtex 5xc5vlx30-3ff324 2.00%111 Slices>200MHz AlteraCyclone IIIep3c5f256c6 5.00%255 LEs>200MHz AlteraStartix IIIep3sl50f484c2 <1%167 Registers 218 ALUTs>200MHz Lattice1MachXOLCMXO2280C- 4T144C10.00%116 Slices> 100MHz Table 1: Synthesis Results for Different FPGA Devices The above results where obtained using the following software versions: \u2022Xilinx ISE Webpack 11.4 \u2022Altera Quartus Web Edition 9.1sp2 NOTE: The UART to Bus core is not Wishbone compatible although\nbe written to. int_readoutput1An active high read control signal. This signal shall only be valid for a single clock cycle per address to be read from. int_rd_datainput8Data value read from address. This signal is sampled by the core on the next clock cycle following int_read signal active cycle. int_reqoutput1Internal bus access request signal. The core will assert this signal to request access to the internal bus before every bus access. This signal will be asserted until bus access is granted. int_gntinput1Internal bus grant signal. The core will release the request signal and execute the bus access when this signal is asserted. To disable bus request/grant mechanism set this to logic '1'. Table 6: Core Interfaces Description Note: The port direction in the table above is as defined in the core top module. UART to Bus Core Specifications Page 9 of 10 February 25, 2012 6.Test Bench Description The 'verilog\\bench' directory contains two test benches files and required tasks and modules. Compilation batch files are included in the 'verilog\\sim\\icarus' directory used to simulate the core using Icarus Verilog. The directory inclues two compilation batch files: one for binary mode protocol simulation and the second for text mode protocol simulation. The directory also includes batch file to run the simulation, 'run.bat', and another to call gtkwave to view the simulation VCD output file. Note that for binary mode protocol simulation the test bench reads the commands from 'test.bin' file also included in the directory. The file structure is straight forward and is explained in the respective test bench file. UART to Bus Core Specifications Page 10 of 10\nWrite a SystemVerilog module to implement a UART (Universal Asynchronous Receiver-Transmitter) controller. The module should support configurable baud rates, transmit and receive functionality, and proper start, data, parity (optional), and stop bit handling. The UART should operate in full-duplex mode and adhere to the following interface:\nmodule UART_driver( input  logic       clk,        // System clock input  logic       rst,        // Asynchronous reset input  logic       UART_Start, // Signal to initiate transmission input  logic [7:0] data_in,    // Data to be transmitted input  logic       RX,         // UART receive line output logic       TX,         // UART transmit line output logic [7:0] data_out,   // Received data output logic       UART_Ready, // Ready to transmit next byte output logic       UART_Busy,  // Indicates UART is currently transmitting output logic       UART_Error  // High if framing or parity error detected ); ",
    "answer_0": "```systemverilog\n/*****************************************************************************************\n*  UART_driver \u2013 Full-duplex UART with configurable baud, parity and stop-bits\n*\n*  \u2022 8-bit data, optional parity (even/odd), 1 or 2 stop bits\n*  \u2022 Independent TX/RX finite-state-machines\n*  \u2022 Single baud-rate generator shared by both directions\n*\n*  Notes\n*  -----\n*  1. `CLK_FREQ` and `BAUD_RATE` **must** be chosen such that  \n*        CLK_FREQ / BAUD_RATE / OVERSAMPLE  \u2265 1   and is an integer.\n*\n*  2. RX path uses 16\u00d7 oversampling and samples incoming bits in the centre\n*     of each bit-period (8th tick of the 16).  \n*     TX path shifts on the first tick of each bit.\n*\n******************************************************************************************/\nmodule UART_driver #(\n    // ------------------------------------------------------------------\n    // USER CONFIGURABLE GENERICS\n    // ------------------------------------------------------------------\n    parameter int CLK_FREQ    = 50_000_000,  // System clock  (Hz)\n    parameter int BAUD_RATE   = 115_200,     // Desired baud  (bps)\n    parameter bit PARITY_EN   = 0,           // 0 \u2013 none , 1 \u2013 parity on\n    parameter bit PARITY_EVEN = 1,           // 1 \u2013 even , 0 \u2013 odd   (if enabled)\n    parameter int STOP_BITS   = 1            // 1 or 2 stop bits\n) (\n    // ------------------------------------------------------------------\n    // PORTS\n    // ------------------------------------------------------------------\n    input  logic       clk,            // System clock\n    input  logic       rst,            // Asynchronous reset \u2013 active high\n    // TX interface\n    input  logic       UART_Start,     // Pulse to start TX of data_in\n    input  logic [7:0] data_in,        // Data to transmit\n    output logic       UART_Ready,     // 1 = ready/idle\n    output logic       UART_Busy,      // 1 = currently transmitting\n    output logic       TX,             // UART Tx line\n    // RX interface\n    input  logic       RX,             // UART Rx line\n    output logic [7:0] data_out,       // Most recently received byte\n    output logic       UART_Error      // 1 = frame/parity error detected\n);\n\n    // ------------------------------------------------------------------\n    // CONSTANTS\n    // ------------------------------------------------------------------\n    localparam int OVERSAMPLE  = 16;                           // RX oversampling factor\n    localparam int BAUD_DIV    = CLK_FREQ / BAUD_RATE;         // 1\u00d7 baud tick divider\n    localparam int SAMPLE_DIV  = BAUD_DIV / OVERSAMPLE;        // 16\u00d7 tick divider\n\n    // ------------------------------------------------------------------\n    // SHARED BAUD GENERATOR (1\u00d7 tick and 16\u00d7 tick)\n    // ------------------------------------------------------------------\n    logic [31:0] baud_cnt, sample_cnt;\n    logic        baud_tick, sample_tick;\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            baud_cnt   <= 0;\n            sample_cnt <= 0;\n            baud_tick  <= 0;\n            sample_tick<= 0;\n        end else begin\n            // --- 1\u00d7 baud tick (for TX) -------------------------------\n            if (baud_cnt == BAUD_DIV-1) begin\n                baud_cnt  <= 0;\n                baud_tick <= 1;\n            end else begin\n                baud_cnt  <= baud_cnt + 1;\n                baud_tick <= 0;\n            end\n            // --- 16\u00d7 tick (for RX oversampling) ----------------------\n            if (sample_cnt == SAMPLE_DIV-1) begin\n                sample_cnt  <= 0;\n                sample_tick <= 1;\n            end else begin\n                sample_cnt  <= sample_cnt + 1;\n                sample_tick <= 0;\n            end\n        end\n    end\n\n    // ------------------------------------------------------------------\n    // TRANSMITTER\n    // ------------------------------------------------------------------\n    typedef enum logic [2:0] {TX_IDLE, TX_START, TX_DATA, TX_PAR, TX_STOP} tx_state_t;\n    tx_state_t tx_state;\n\n    logic [2:0]     bit_idx;     // Counts data bits\n    logic [7:0]     tx_shift;\n    logic [1:0]     stop_cnt;    // 1 or 2 stop bits\n\n    // next parity calculation\n    function automatic logic parity_bit (input logic [7:0] d);\n        logic p;\n        begin\n            p = ^d;                               // XOR reduction\n            if (PARITY_EVEN == 1) parity_bit = p; // even parity\n            else                  parity_bit = ~p; // odd parity\n        end\n    endfunction\n\n    // TX FSM -----------------------------------------------------------\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tx_state   <= TX_IDLE;\n            TX         <= 1'b1;       // idle line high\n            UART_Ready <= 1'b1;\n            UART_Busy  <= 1'b0;\n            bit_idx    <= 3'd0;\n            stop_cnt   <= 2'd0;\n            tx_shift   <= 8'h00;\n        end else begin\n            if (baud_tick) begin\n                case (tx_state)\n                    TX_IDLE: begin\n                        if (UART_Start) begin\n                            UART_Ready <= 1'b0;\n                            UART_Busy  <= 1'b1;\n                            tx_shift   <= data_in;\n                            bit_idx    <= 3'd0;\n                            TX         <= 1'b0;   // start bit\n                            tx_state   <= TX_START;\n                        end\n                    end\n\n                    TX_START: begin\n                        TX       <= tx_shift[0];  // first data bit\n                        tx_shift <= {1'b0, tx_shift[7:1]};\n                        bit_idx  <= 3'd1;\n                        tx_state <= TX_DATA;\n                    end\n\n                    TX_DATA: begin\n                        if (bit_idx != 3'd7) begin\n                            TX       <= tx_shift[0];\n                            tx_shift <= {1'b0, tx_shift[7:1]};\n                            bit_idx  <= bit_idx + 1;\n                        end else begin\n                            // Last data bit sent this cycle\n                            if (PARITY_EN) begin\n                                TX       <= parity_bit(data_in);\n                                tx_state <= TX_PAR;\n                            end else begin\n                                TX       <= 1'b1;   // stop bit\n                                stop_cnt <= STOP_BITS-1;\n                                tx_state <= TX_STOP;\n                            end\n                        end\n                    end\n\n                    TX_PAR: begin\n                        TX       <= 1'b1;          // first stop bit\n                        stop_cnt <= STOP_BITS-1;\n                        tx_state <= TX_STOP;\n                    end\n\n                    TX_STOP: begin\n                        if (stop_cnt != 0) begin\n                            stop_cnt <= stop_cnt - 1;\n                            TX       <= 1'b1;\n                        end else begin\n                            UART_Ready <= 1'b1;\n                            UART_Busy  <= 1'b0;\n                            tx_state   <= TX_IDLE;\n                            TX         <= 1'b1;\n                        end\n                    end\n                    default: tx_state <= TX_IDLE;\n                endcase\n            end\n        end\n    end\n\n    // ------------------------------------------------------------------\n    // RECEIVER\n    // ------------------------------------------------------------------\n    typedef enum logic [2:0] {RX_IDLE, RX_START, RX_DATA, RX_PAR, RX_STOP} rx_state_t;\n    rx_state_t rx_state;\n\n    logic [3:0] sample_ctr;   // 0..15\n    logic [2:0] rx_bit_idx;\n    logic [7:0] rx_shift;\n    logic       calc_parity, rx_parity;\n    logic       frame_err, parity_err;\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_state     <= RX_IDLE;\n            sample_ctr   <= 4'd0;\n            rx_bit_idx   <= 3'd0;\n            rx_shift     <= 8'h00;\n            data_out     <= 8'h00;\n            UART_Error   <= 1'b0;\n        end else begin\n            UART_Error <= frame_err | parity_err;  // sticky until next good frame\n\n            if (sample_tick) begin\n                case (rx_state)\n                    //--------------------------------------------------\n                    RX_IDLE: begin\n                        frame_err   <= 1'b0;\n                        parity_err  <= 1'b0;\n                        if (RX == 1'b0) begin        // start bit detected\n                            rx_state   <= RX_START;\n                            sample_ctr <= 4'd0;\n                        end\n                    end\n                    //--------------------------------------------------\n                    RX_START: begin\n                        if (sample_ctr == 4'd7) begin // mid of start bit\n                            if (RX == 1'b0) begin     // valid start\n                                sample_ctr <= 4'd0;\n                                rx_bit_idx <= 3'd0;\n                                rx_state   <= RX_DATA;\n                            end else begin            // false start\n                                rx_state <= RX_IDLE;\n                            end\n                        end else begin\n                            sample_ctr <= sample_ctr + 1;\n                        end\n                    end\n                    //--------------------------------------------------\n                    RX_DATA: begin\n                        if (sample_ctr == OVERSAMPLE-1) begin\n                            sample_ctr      <= 4'd0;\n                            rx_shift[rx_bit_idx] <= RX; // sample in middle\n                            if (rx_bit_idx == 3'd7) begin\n                                if (PARITY_EN) begin\n                                    rx_state <= RX_PAR;\n                                end else begin\n                                    rx_state <= RX_STOP;\n                                end\n                            end\n                            rx_bit_idx <= rx_bit_idx + 1;\n                        end else begin\n                            sample_ctr <= sample_ctr + 1;\n                        end\n                    end\n                    //--------------------------------------------------\n                    RX_PAR: begin\n                        if (sample_ctr == OVERSAMPLE-1) begin\n                            sample_ctr  <= 4'd0;\n                            rx_parity   <= RX;\n                            // compute parity\n                            calc_parity <= parity_bit(rx_shift);\n                            parity_err  <= (rx_parity != calc_parity);\n                            rx_state    <= RX_STOP;\n                        end else begin\n                            sample_ctr <= sample_ctr + 1;\n                        end\n                    end\n                    //--------------------------------------------------\n                    RX_STOP: begin\n                        if (sample_ctr == OVERSAMPLE-1) begin\n                            sample_ctr <= 4'd0;\n                            if (RX != 1'b1) frame_err <= 1'b1; // stop bit must be high\n                            if (STOP_BITS == 2) begin\n                                // wait one more stop bit\n                                if (RX != 1'b1) frame_err <= 1'b1;\n                            end\n                            data_out <= rx_shift;\n                            rx_state <= RX_IDLE;\n                        end else begin\n                            sample_ctr <= sample_ctr + 1;\n                        end\n                    end\n                    default: rx_state <= RX_IDLE;\n                endcase\n            end\n        end\n    end\nendmodule\n```\n",
    "prompt_1": "protocol and the second tests the binary protocol. The test bench uses a register file model to simulate write and read operations. The following table summarizes the synthesis results of the core for different FPGA families. ManufacturerFamilyDevice Device UtilizationElements UtilizationFmax XilinxSpartan 3xc3s50-5pq208 24.00%186 Slices>150MHz XilinxVirtex 5xc5vlx30-3ff324 2.00%111 Slices>200MHz AlteraCyclone IIIep3c5f256c6 5.00%255 LEs>200MHz AlteraStartix IIIep3sl50f484c2 <1%167 Registers 218 ALUTs>200MHz Lattice1MachXOLCMXO2280C- 4T144C10.00%116 Slices> 100MHz Table 1: Synthesis Results for Different FPGA Devices The above results where obtained using the following software versions: \u2022Xilinx ISE Webpack 11.4 \u2022Altera Quartus Web Edition 9.1sp2 NOTE: The UART to Bus core is not Wishbone compatible although modifying it for Wishbone is probably possible. 1Lattice device synthesis results provided by Paul V. Shatov. Results provided before adding bus request/grant mechanism. UART to Bus Core Specifications Page 4 of 10 February 25, 2012 3.Architecture The UART to Bus architecture is fairly simple. The core is includes a UART interface module, which includes both receive and transmit modules, and the command parser. The following figure depicts a block diagram of the core. Figure 1: UART to Bus Core Block Diagram The UART interface is based on an implementation found in the c16 project in OpenCores (http://www.opencores.org/project,c16 ). The interface includes a UART receive and transmit modules that share a single baud rate generator module. The baud rate is set using two constants defined at the core top module which are calculated as follows: D_BAUD_FREQ=16\u22c5BaudRate gcd\ue09eGlobalClockFreq,16\u2217BaudRate\ue09f D_BAUD_LIMIT=GlobalClockFreq gcd\ue09eGlobalClockFreq,16\u22c5BaudRate\ue09f\u2212D_BAUD_FREQ A short Scilab script which calculates the above parameters is added under the \u201cscilab\u201d directory with the core files. The interface between the \u201cuart_parser.v\u201d module and the \u201cuart_top.v\u201d is very simple and uses only five signals. For cases where the UART interface is not possible or another interface is preferred, the \u201cuart_parser.v\u201d module can be used as is with a different interface implementation. UART to Bus Core Specifications Page 5 of 10 uart_tx.v uart_rx.v baud_gen.vuart_top.v uart_parser.vuart2bus_top.v ser_out ser_inint_address int_wr_data16 8 int_write int_read int_rd_data 8 clock resetint_req int_gntFebruary 25, 2012 4.Operation This section describes the protocols used to access the internal bus from the UART interface. As mentioned above the parser supports two modes of operation: text & binary commands. To distinguish between the two protocols all binary commands start with a value of zero which will not be sent when using the text protocol. The following drawing depicts a simplified state machine of the parser. The figure does not include some transitions used to abort illegal command sequences. Figure 2: Parser State Diagram In the state diagram above the states on the right are used for the text mode protocol and the states on the left are used for the binary mode protocol. The following sub-sections describe each of the protocols. 4.1.Text Mode Protocol The text mode protocol includes only two commands: address read and address write. All values are in HEX format. The parser checks for both upper and lower characters, detects both space (0x20) and tab (0x09) as white spaces and both LF (0x0A) and CR (0x0D) as end of\nUART to Bus Core Specifications Written for publication on: File name: UART to Bus Core Specifications Version: 1.0 Creation Date: February 12, 2010 Update Date: February 25, 2012 Author: Moti Litochevski February 25, 2012 Table of Contents 1. Preface.............................................................................................................................................. 3 1.1. Scope........................................................................................................................................ 3 1.2. Revision History ....................................................................................................................... 3 1.3. Abbreviations........................................................................................................................... 3 2. Introduction...................................................................................................................................... 4 3. Architecture...................................................................................................................................... 5 4. Operation.......................................................................................................................................... 6 4.1. Text Mode Protocol .................................................................................................................. 6 4.2. Binary Mode Protocol .............................................................................................................. 7 5. Core Interfaces................................................................................................................................. 9 6. Test Bench Description .................................................................................................................. 10 Index of Tables Table 1: Synthesis Results for Different FPGA Devices ..................................................................... 4 Table 2: Text Protocol Read Command Format .................................................................................. 7 Table 3: Text Protocol Write Command Format ................................................................................. 7 Table 4: Binary Protocol Command Format ........................................................................................ 8 Table 5: Binary Protocol Return Message Format .............................................................................. 8 Table 6: Core Interfaces Description ................................................................................................... 9 Index of Figures Figure 1: UART to Bus Core Block Diagram ..................................................................................... 5 Figure 2: Parser State Diagram ............................................................................................................ 6 UART to Bus Core Specifications Page 2 of 10 February 25, 2012 1.Preface 1.1.Scope This document describes the UART to Bus IP core operation, architecture and interfaces. 1.2.Revision History RevDateAuthor Description 0.102/13/10Moti Litochevski First Draft 0.204/02/10Moti Litochevski Adding test bench description section 0.304/15/11Moti Litochevski Added Lattice MachXO device utilization provided by Paul V. Shatov. 1.002/25/12Moti Litochevski Updated interface description and synthesis results after adding bus request/grant mechanism. 1.3.Abbreviations UARTUniversal Asynchronous Receiver / Transmitter UART to Bus Core Specifications Page 3 of 10 February 25, 2012 2.Introduction The UART to Bus IP Core is a simple command parser that can be used to access an internal bus via a UART interface. This core can be used during initial board debugging or as a permanent solution when high speed interfaces are not required. The internal bus is designed with address bus of 16 bits and data bus of 8 bits. The core implements a very basic UART transmit & receive blocks which share a common baud rate generator and a command parser. The parser supports two modes of operation: text mode commands and binary mode commands. Text mode commands are designed to be used with a hyper terminal software and enable easy access to the internal bus. Binary mode commands are more efficient and also support buffered read & write operations with or without automatic address increment. The core was verified using Icarus Verilog simulator with two test benches: the first tests the text mode protocol and the second tests the binary protocol. The test bench uses a register file model to simulate write and read operations. The following table summarizes the synthesis results of the core for different FPGA families. ManufacturerFamilyDevice Device UtilizationElements UtilizationFmax XilinxSpartan 3xc3s50-5pq208 24.00%186 Slices>150MHz XilinxVirtex 5xc5vlx30-3ff324 2.00%111 Slices>200MHz AlteraCyclone IIIep3c5f256c6 5.00%255 LEs>200MHz AlteraStartix IIIep3sl50f484c2 <1%167 Registers 218 ALUTs>200MHz Lattice1MachXOLCMXO2280C- 4T144C10.00%116 Slices> 100MHz Table 1: Synthesis Results for Different FPGA Devices The above results where obtained using the following software versions: \u2022Xilinx ISE Webpack 11.4 \u2022Altera Quartus Web Edition 9.1sp2 NOTE: The UART to Bus core is not Wishbone compatible although\nbe written to. int_readoutput1An active high read control signal. This signal shall only be valid for a single clock cycle per address to be read from. int_rd_datainput8Data value read from address. This signal is sampled by the core on the next clock cycle following int_read signal active cycle. int_reqoutput1Internal bus access request signal. The core will assert this signal to request access to the internal bus before every bus access. This signal will be asserted until bus access is granted. int_gntinput1Internal bus grant signal. The core will release the request signal and execute the bus access when this signal is asserted. To disable bus request/grant mechanism set this to logic '1'. Table 6: Core Interfaces Description Note: The port direction in the table above is as defined in the core top module. UART to Bus Core Specifications Page 9 of 10 February 25, 2012 6.Test Bench Description The 'verilog\\bench' directory contains two test benches files and required tasks and modules. Compilation batch files are included in the 'verilog\\sim\\icarus' directory used to simulate the core using Icarus Verilog. The directory inclues two compilation batch files: one for binary mode protocol simulation and the second for text mode protocol simulation. The directory also includes batch file to run the simulation, 'run.bat', and another to call gtkwave to view the simulation VCD output file. Note that for binary mode protocol simulation the test bench reads the commands from 'test.bin' file also included in the directory. The file structure is straight forward and is explained in the respective test bench file. UART to Bus Core Specifications Page 10 of 10\nWrite a SystemVerilog module to implement a UART (Universal Asynchronous Receiver-Transmitter) controller. The module should support configurable baud rates, transmit and receive functionality, and proper start, data, parity (optional), and 2 stop bit handling. The UART should operate in full-duplex mode and adhere to the following interface:\nmodule UART_driver( input  logic       clk,        // System clock input  logic       rst,        // Asynchronous reset input  logic       UART_Start, // Signal to initiate transmission input  logic [8:0] data_in,    // Data to be transmitted input  logic       RX,         // UART receive line output logic       TX,         // UART transmit line output logic [8:0] data_out,   // Received data output logic       UART_Ready, // Ready to transmit next byte output logic       UART_Busy,  // Indicates UART is currently transmitting output logic       UART_Error  // High if framing or parity error detected ); ",
    "answer_1": "```systemverilog\n//==============================================================\n//  UART_driver.sv\n//\n//  Generic, full-duplex UART with\n//      \u2022 Run-time selectable baud rate\n//      \u2022 8 data bits, optional parity, 2 stop bits\n//      \u2022 Separate TX / RX state-machines\n//      \u2022 Framing & parity error detection\n//\n//  Interface is exactly the one requested in the problem\n//==============================================================\n\nmodule UART_driver\n#(\n    //------------------------------------------------------------------\n    //  GENERICS\n    //------------------------------------------------------------------\n    //  System clock frequency       (Hz)\n    parameter int unsigned CLK_FREQ_HZ   = 50_000_000,\n    //  Default baud-rate            (bit/s)\n    parameter int unsigned BAUD_RATE     = 115_200,\n    //  Oversampling (must be \u2265 3 ; 16 is common)\n    parameter int unsigned OVERSAMPLE    = 16,\n    //  Parity : 0 = none , 1 = even , 2 = odd\n    parameter int unsigned PARITY_MODE   = 0\n)\n(\n    //------------------------------------------------------------------\n    //  PORTS\n    //------------------------------------------------------------------\n    input  logic        clk,            // System clock\n    input  logic        rst,            // Asynchronous reset, active high\n\n    //  TX interface\n    input  logic        UART_Start,     // Pulse => send data_in\n    input  logic [8:0]  data_in,        // 8 data bits, bit 8 ignored\n    output logic        UART_Ready,     // High when TX idle\n    output logic        UART_Busy,      // High while frame in progress\n    output logic        TX,             // UART TX line\n\n    //  RX interface\n    input  logic        RX,             // UART RX line\n    output logic [8:0]  data_out,       // Received byte, parity bit in [8]\n    output logic        UART_Error      // Framing / parity error\n);\n\n    //------------------------------------------------------------------\n    //  CONSTANTS\n    //------------------------------------------------------------------\n    localparam  int unsigned BAUD_DIV = CLK_FREQ_HZ / (BAUD_RATE * OVERSAMPLE); // clock cycles / oversample tick\n    localparam  int unsigned BAUD_DIV_W = $clog2(BAUD_DIV);\n\n    //------------------------------------------------------------------\n    //  GLOBAL TICK:  OVERSAMPLE * BAUD_RATE  ticks / second\n    //------------------------------------------------------------------\n    logic [BAUD_DIV_W-1:0] baud_cnt;\n    logic                  baud_tick;     // 1-cycle pulse every clk/(BAUD_RATE*OVERSAMPLE)\n\n    always_ff @(posedge clk or posedge rst)\n    begin\n        if (rst) begin\n            baud_cnt  <= '0;\n            baud_tick <= 1'b0;\n        end else begin\n            if (baud_cnt == BAUD_DIV-1) begin\n                baud_cnt  <= '0;\n                baud_tick <= 1'b1;\n            end else begin\n                baud_cnt  <= baud_cnt + 1;\n                baud_tick <= 1'b0;\n            end\n        end\n    end\n\n    //==============================================================\n    //  TRANSMITTER\n    //==============================================================\n    typedef enum logic [2:0] {TX_IDLE, TX_START, TX_DATA, TX_PARITY, TX_STOP1, TX_STOP2} tx_state_t;\n    tx_state_t  tx_state;\n\n    logic [3:0] tx_bit_cnt;      // counts 0-7 data bits\n    logic [7:0] tx_shift;        // shift register\n    logic       tx_parity_bit;   // computed parity\n    logic [3:0] tx_ovr_cnt;      // oversample counter within each bit\n    logic       tx_line;         // registered TX line\n\n    //  Parity computation helper\n    function logic calc_parity( input logic [7:0] b );\n        if (PARITY_MODE == 1)     // even\n            calc_parity = ^b;     // even parity = XOR = 1 when #ones odd\n        else                      // odd\n            calc_parity = ~(^b);\n    endfunction\n\n    assign TX         = tx_line;\n    assign UART_Ready = (tx_state == TX_IDLE);\n    assign UART_Busy  = ~UART_Ready;\n\n    always_ff @(posedge clk or posedge rst)\n    begin\n        if (rst) begin\n            tx_state     <= TX_IDLE;\n            tx_bit_cnt   <= 0;\n            tx_shift     <= '0;\n            tx_parity_bit<= 1'b0;\n            tx_ovr_cnt   <= 0;\n            tx_line      <= 1'b1;       // idle level\n        end\n        else if (baud_tick) begin\n            //------------------------------------------------------\n            //  oversample counter \u2013 generates 1 bit-time every\n            //  OVERSAMPLE baud ticks\n            //------------------------------------------------------\n            if (tx_state == TX_IDLE) begin\n                tx_ovr_cnt <= 0;\n            end else if (tx_ovr_cnt == (OVERSAMPLE-1)) begin\n                tx_ovr_cnt <= 0;\n            end else begin\n                tx_ovr_cnt <= tx_ovr_cnt + 1;\n            end\n\n            //------------------------------------------------------\n            //  Only change line once per full bit\n            //------------------------------------------------------\n            if ( (tx_state != TX_IDLE) && (tx_ovr_cnt != 0) )\n                // not at the start of a new bit : keep output\n                tx_line <= tx_line;\n            else begin\n                //--------------------------------------------------\n                //  State machine\n                //--------------------------------------------------\n                unique case (tx_state)\n                    //--------------------------------------------------\n                    TX_IDLE : begin\n                        tx_line <= 1'b1;               // idle high\n                        if (UART_Start) begin\n                            tx_shift      <= data_in[7:0];\n                            tx_parity_bit <= (PARITY_MODE==0)? 1'b1 : calc_parity(data_in[7:0]);\n                            tx_bit_cnt    <= 0;\n                            tx_state      <= TX_START;\n                        end\n                    end\n                    //--------------------------------------------------\n                    TX_START : begin\n                        tx_line  <= 1'b0;               // start bit\n                        tx_state <= TX_DATA;\n                    end\n                    //--------------------------------------------------\n                    TX_DATA : begin\n                        tx_line <= tx_shift[0];\n                        tx_shift<= {1'b0,tx_shift[7:1]};\n                        if (tx_bit_cnt == 7) begin\n                            tx_bit_cnt <= 0;\n                            if (PARITY_MODE==0)\n                                tx_state <= TX_STOP1;\n                            else\n                                tx_state <= TX_PARITY;\n                        end else begin\n                            tx_bit_cnt <= tx_bit_cnt + 1;\n                        end\n                    end\n                    //--------------------------------------------------\n                    TX_PARITY : begin\n                        tx_line  <= tx_parity_bit;\n                        tx_state <= TX_STOP1;\n                    end\n                    //--------------------------------------------------\n                    TX_STOP1 : begin\n                        tx_line  <= 1'b1;               // stop bit #1\n                        tx_state <= TX_STOP2;\n                    end\n                    //--------------------------------------------------\n                    TX_STOP2 : begin\n                        tx_line  <= 1'b1;               // stop bit #2\n                        tx_state <= TX_IDLE;\n                    end\n                endcase\n            end // bit boundary\n        end // baud_tick\n    end // always_ff TX\n\n    //==============================================================\n    //  RECEIVER\n    //==============================================================\n    typedef enum logic [3:0]\n    {\n        RX_IDLE, RX_START, RX_DATA, RX_PARITY, RX_STOP1, RX_STOP2, RX_DONE, RX_ERROR\n    } rx_state_t;\n\n    rx_state_t  rx_state;\n    logic [3:0] rx_bit_cnt;          // counts received data bits\n    logic [7:0] rx_shift;\n    logic [3:0] rx_ovr_cnt;          // samples within one bit\n    logic [3:0] rx_mid_sample;       // middle of bit (OVERSAMPLE/2)\n    logic       rx_samp;             // synchronised sample of RX pin\n    logic       parity_calc;         // running parity\n    logic       framing_err, parity_err;\n\n    //  Middle sample tick : when ov_cnt == OVERSAMPLE/2\n    assign rx_mid_sample = OVERSAMPLE >> 1;\n\n    //  Simple metastability filter (double-register)\n    logic rx_sync1, rx_sync2;\n    always_ff @(posedge clk) begin\n        rx_sync1 <= RX;\n        rx_sync2 <= rx_sync1;\n    end\n    assign rx_samp = rx_sync2;\n\n    //  Output registers\n    always_ff @(posedge clk or posedge rst)\n    begin\n        if (rst) begin\n            data_out    <= '0;\n            UART_Error  <= 1'b0;\n        end else if (rx_state == RX_DONE) begin\n            data_out    <= {parity_calc, rx_shift}; // parity in bit[8]\n            UART_Error  <= framing_err | parity_err;\n        end\n    end\n\n    always_ff @(posedge clk or posedge rst)\n    begin\n        if (rst) begin\n            rx_state      <= RX_IDLE;\n            rx_bit_cnt    <= 0;\n            rx_shift      <= '0;\n            rx_ovr_cnt    <= 0;\n            parity_calc   <= 1'b0;\n            framing_err   <= 1'b0;\n            parity_err    <= 1'b0;\n        end\n        else if (baud_tick) begin\n            //------------------------------------------------------\n            //  oversample counter\n            //------------------------------------------------------\n            if (rx_state == RX_IDLE)\n                rx_ovr_cnt <= 0;\n            else if (rx_ovr_cnt == (OVERSAMPLE-1))\n                rx_ovr_cnt <= 0;\n            else\n                rx_ovr_cnt <= rx_ovr_cnt + 1;\n\n            //------------------------------------------------------\n            //  sample at middle of the bit\n            //------------------------------------------------------\n            logic sample_now;\n            sample_now = (rx_ovr_cnt == rx_mid_sample);\n\n            //------------------------------------------------------\n            //  State machine\n            //------------------------------------------------------\n            unique case (rx_state)\n                //--------------------------------------------------\n                RX_IDLE : begin\n                    framing_err <= 1'b0;\n                    parity_err  <= 1'b0;\n                    if (~rx_samp) begin          // start bit detected (line low)\n                        rx_state   <= RX_START;\n                        rx_ovr_cnt <= 0;\n                    end\n                end\n                //--------------------------------------------------\n                RX_START : begin\n                    if (sample_now) begin\n                        if (~rx_samp) begin      // confirm start bit still low\n                            rx_bit_cnt  <= 0;\n                            parity_calc <= 1'b0;\n                            rx_state    <= RX_DATA;\n                        end else begin           // false start\n                            rx_state <= RX_ERROR;\n                            framing_err <= 1'b1;\n                        end\n                    end\n                end\n                //--------------------------------------------------\n                RX_DATA : begin\n                    if (sample_now) begin\n                        rx_shift <= {rx_samp, rx_shift[7:1]};\n                        parity_calc <= parity_calc ^ rx_samp;\n                        if (rx_bit_cnt == 7) begin\n                            if (PARITY_MODE == 0)\n                                rx_state <= RX_STOP1;\n                            else\n                                rx_state <= RX_PARITY;\n                        end\n                        rx_bit_cnt <= rx_bit_cnt + 1;\n                    end\n                end\n                //--------------------------------------------------\n                RX_PARITY : begin\n                    if (sample_now) begin\n                        //  Check even / odd\n                        logic expected_parity;\n                        expected_parity   = (PARITY_MODE==1) ? parity_calc : ~parity_calc;\n                        parity_err        = (rx_samp != expected_parity);\n                        rx_state          <= RX_STOP1;\n                    end\n                end\n                //--------------------------------------------------\n                RX_STOP1 : begin\n                    if (sample_now) begin\n                        if (~rx_samp) framing_err <= 1'b1;\n                        rx_state <= RX_STOP2;\n                    end\n                end\n                //--------------------------------------------------\n                RX_STOP2 : begin\n                    if (sample_now) begin\n                        if (~rx_samp) framing_err <= 1'b1;\n                        rx_state <= RX_DONE;\n                    end\n                end\n                //--------------------------------------------------\n                RX_DONE : begin\n                    rx_state <= RX_IDLE;     // Data valid for 1 cycle\n                end\n                //--------------------------------------------------\n                RX_ERROR : begin\n                    rx_state <= RX_IDLE;     // resync\n                end\n            endcase\n        end // baud_tick\n    end // always_ff RX\n\nendmodule\n```\n\nHow to use\n1. Instantiate `UART_driver`, optionally overriding `CLK_FREQ_HZ`, `BAUD_RATE`, `OVERSAMPLE`, and `PARITY_MODE`.\n2. Drive `UART_Start` high for one `clk` to transmit the value on `data_in[7:0]`.\n3. Monitor `UART_Ready` (idle) and `UART_Busy` (active) for TX flow-control.\n4. Received bytes are presented on `data_out` for one cycle after the RX state-machine finishes; bit 8 holds the received parity sample.  \n5. Any framing or parity violation raises `UART_Error` for one clock."
}
