{
    "prompt_0": "Write a SystemVerilog module to implement a UART (Universal Asynchronous Receiver-Transmitter) controller. The module should support configurable baud rates, transmit and receive functionality, and proper start, data, parity (optional), and stop bit handling. The UART should operate in full-duplex mode and adhere to the following interface:\nmodule UART_driver( input  logic       clk,        // System clock input  logic       rst,        // Asynchronous reset input  logic       UART_Start, // Signal to initiate transmission input  logic [7:0] data_in,    // Data to be transmitted input  logic       RX,         // UART receive line output logic       TX,         // UART transmit line output logic [7:0] data_out,   // Received data output logic       UART_Ready, // Ready to transmit next byte output logic       UART_Busy,  // Indicates UART is currently transmitting output logic       UART_Error  // High if framing or parity error detected ); ",
    "answer_0": "```systemverilog\nmodule UART_driver #(\n    parameter BAUD_RATE = 115200,      // Default baud rate\n    parameter CLOCK_FREQ = 50000000,   // System clock frequency\n    parameter PARITY_EN = 0,           // 0: No parity, 1: Even parity, 2: Odd parity\n    parameter PARITY_TYPE = 0          // 0: Even, 1: Odd (used if PARITY_EN != 0)\n)(\n    input  logic       clk,        // System clock\n    input  logic       rst,        // Asynchronous reset\n    input  logic       UART_Start, // Signal to initiate transmission\n    input  logic [7:0] data_in,    // Data to be transmitted\n    input  logic       RX,         // UART receive line\n    output logic       TX,         // UART transmit line\n    output logic [7:0] data_out,   // Received data\n    output logic       UART_Ready, // Ready to transmit next byte\n    output logic       UART_Busy,  // Indicates UART is currently transmitting\n    output logic       UART_Error  // High if framing or parity error detected\n);\n\n    // Baud rate generator\n    localparam integer BAUD_DIV = CLOCK_FREQ / BAUD_RATE;\n    logic [$clog2(BAUD_DIV)-1:0] baud_cnt;\n    logic baud_tick;\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            baud_cnt <= 0;\n            baud_tick <= 0;\n        end else if (baud_cnt == BAUD_DIV-1) begin\n            baud_cnt <= 0;\n            baud_tick <= 1;\n        end else begin\n            baud_cnt <= baud_cnt + 1;\n            baud_tick <= 0;\n        end\n    end\n\n    // Transmitter\n    typedef enum logic [2:0] {\n        TX_IDLE,\n        TX_START,\n        TX_DATA,\n        TX_PARITY,\n        TX_STOP\n    } tx_state_t;\n\n    tx_state_t tx_state;\n    logic [3:0] tx_bit_cnt;\n    logic [7:0] tx_shift_reg;\n    logic       tx_parity_bit;\n    logic       tx_busy;\n    logic       tx_ready;\n    logic       tx_line;\n\n    assign TX = tx_line;\n    assign UART_Busy = tx_busy;\n    assign UART_Ready = tx_ready;\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tx_state      <= TX_IDLE;\n            tx_bit_cnt    <= 0;\n            tx_shift_reg  <= 0;\n            tx_parity_bit <= 0;\n            tx_busy       <= 0;\n            tx_ready      <= 1;\n            tx_line       <= 1; // Idle is high\n        end else begin\n            if (tx_state == TX_IDLE) begin\n                tx_line  <= 1;\n                tx_busy  <= 0;\n                tx_ready <= 1;\n                if (UART_Start) begin\n                    tx_shift_reg  <= data_in;\n                    tx_bit_cnt    <= 0;\n                    tx_busy       <= 1;\n                    tx_ready      <= 0;\n                    // Parity calculation\n                    if (PARITY_EN != 0) begin\n                        tx_parity_bit <= ^data_in; // Even parity by default\n                        if (PARITY_TYPE == 1)\n                            tx_parity_bit <= ~tx_parity_bit; // Odd parity\n                    end\n                    tx_state <= TX_START;\n                end\n            end else if (baud_tick) begin\n                case (tx_state)\n                    TX_START: begin\n                        tx_line <= 0; // Start bit\n                        tx_state <= TX_DATA;\n                        tx_bit_cnt <= 0;\n                    end\n                    TX_DATA: begin\n                        tx_line <= tx_shift_reg[0];\n                        tx_shift_reg <= {1'b0, tx_shift_reg[7:1]};\n                        tx_bit_cnt <= tx_bit_cnt + 1;\n                        if (tx_bit_cnt == 7) begin\n                            if (PARITY_EN != 0)\n                                tx_state <= TX_PARITY;\n                            else\n                                tx_state <= TX_STOP;\n                        end\n                    end\n                    TX_PARITY: begin\n                        tx_line <= tx_parity_bit;\n                        tx_state <= TX_STOP;\n                    end\n                    TX_STOP: begin\n                        tx_line <= 1; // Stop bit\n                        tx_state <= TX_IDLE;\n                    end\n                endcase\n            end\n        end\n    end\n\n    // Receiver\n    typedef enum logic [2:0] {\n        RX_IDLE,\n        RX_START,\n        RX_DATA,\n        RX_PARITY,\n        RX_STOP\n    } rx_state_t;\n\n    rx_state_t rx_state;\n    logic [3:0] rx_bit_cnt;\n    logic [7:0] rx_shift_reg;\n    logic       rx_parity_bit;\n    logic       rx_sample_tick;\n    logic [7:0] rx_data_out;\n    logic       rx_error;\n    logic       rx_busy;\n    logic [$clog2(BAUD_DIV)-1:0] rx_baud_cnt;\n    logic [1:0] rx_sync;\n    logic       rx_sampled;\n\n    assign data_out = rx_data_out;\n    assign UART_Error = rx_error;\n\n    // Double-sampling RX for metastability\n    always_ff @(posedge clk) begin\n        rx_sync <= {rx_sync[0], RX};\n        rx_sampled <= rx_sync[1];\n    end\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_state      <= RX_IDLE;\n            rx_bit_cnt    <= 0;\n            rx_shift_reg  <= 0;\n            rx_parity_bit <= 0;\n            rx_baud_cnt   <= 0;\n            rx_data_out   <= 0;\n            rx_error      <= 0;\n            rx_busy       <= 0;\n        end else begin\n            rx_error <= 0;\n            case (rx_state)\n                RX_IDLE: begin\n                    rx_busy <= 0;\n                    if (~rx_sampled) begin // Start bit detected (falling edge)\n                        rx_state <= RX_START;\n                        rx_baud_cnt <= BAUD_DIV/2; // Sample in the middle of start bit\n                    end\n                end\n                RX_START: begin\n                    if (rx_baud_cnt == 0) begin\n                        if (~rx_sampled) begin // Confirm still low\n                            rx_state <= RX_DATA;\n                            rx_bit_cnt <= 0;\n                            rx_baud_cnt <= BAUD_DIV-1;\n                        end else begin\n                            rx_state <= RX_IDLE; // False start\n                        end\n                    end else begin\n                        rx_baud_cnt <= rx_baud_cnt - 1;\n                    end\n                end\n                RX_DATA: begin\n                    if (rx_baud_cnt == 0) begin\n                        rx_shift_reg <= {rx_sampled, rx_shift_reg[7:1]};\n                        rx_bit_cnt <= rx_bit_cnt + 1;\n                        rx_baud_cnt <= BAUD_DIV-1;\n                        if (rx_bit_cnt == 7) begin\n                            if (PARITY_EN != 0)\n                                rx_state <= RX_PARITY;\n                            else\n                                rx_state <= RX_STOP;\n                        end\n                    end else begin\n                        rx_baud_cnt <= rx_baud_cnt - 1;\n                    end\n                end\n                RX_PARITY: begin\n                    if (rx_baud_cnt == 0) begin\n                        rx_parity_bit <= rx_sampled;\n                        rx_state <= RX_STOP;\n                        rx_baud_cnt <= BAUD_DIV-1;\n                    end else begin\n                        rx_baud_cnt <= rx_baud_cnt - 1;\n                    end\n                end\n                RX_STOP: begin\n                    if (rx_baud_cnt == 0) begin\n                        if (rx_sampled) begin // Stop bit should be high\n                            // Parity check\n                            if (PARITY_EN != 0) begin\n                                logic parity_calc;\n                                parity_calc = ^rx_shift_reg;\n                                if (PARITY_TYPE == 1)\n                                    parity_calc = ~parity_calc;\n                                if (rx_parity_bit != parity_calc)\n                                    rx_error <= 1;\n                            end\n                            rx_data_out <= rx_shift_reg;\n                        end else begin\n                            rx_error <= 1; // Framing error\n                        end\n                        rx_state <= RX_IDLE;\n                    end else begin\n                        rx_baud_cnt <= rx_baud_cnt - 1;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule\n```\n**Notes:**\n- `BAUD_RATE`, `CLOCK_FREQ`, and parity options are configurable via parameters.\n- Parity is optional and can be set to even or odd.\n- Full-duplex operation: TX and RX are independent.\n- `UART_Ready` is high when ready for a new transmission.\n- `UART_Busy` is high during transmission.\n- `UART_Error` is high for one clock after a framing or parity error.\n- RX is double-sampled for metastability.\n- Only 1 stop bit is implemented; can be extended if needed.",
    "prompt_1": "Write a SystemVerilog module to implement a UART (Universal Asynchronous Receiver-Transmitter) controller. The module should support configurable baud rates, transmit and receive functionality, and proper start, data, parity (optional), and 2 stop bit handling. The UART should operate in full-duplex mode and adhere to the following interface:\nmodule UART_driver( input  logic       clk,        // System clock input  logic       rst,        // Asynchronous reset input  logic       UART_Start, // Signal to initiate transmission input  logic [8:0] data_in,    // Data to be transmitted input  logic       RX,         // UART receive line output logic       TX,         // UART transmit line output logic [8:0] data_out,   // Received data output logic       UART_Ready, // Ready to transmit next byte output logic       UART_Busy,  // Indicates UART is currently transmitting output logic       UART_Error  // High if framing or parity error detected ); ",
    "answer_1": "```systemverilog\nmodule UART_driver(\n    input  logic        clk,         // System clock\n    input  logic        rst,         // Asynchronous reset\n    input  logic        UART_Start,  // Signal to initiate transmission\n    input  logic [8:0]  data_in,     // Data to be transmitted (8 bits + parity enable in [8])\n    input  logic        RX,          // UART receive line\n    output logic        TX,          // UART transmit line\n    output logic [8:0]  data_out,    // Received data (8 bits + parity enable in [8])\n    output logic        UART_Ready,  // Ready to transmit next byte\n    output logic        UART_Busy,   // Indicates UART is currently transmitting\n    output logic        UART_Error   // High if framing or parity error detected\n);\n\n    // === Configurable Parameters ===\n    parameter integer CLK_FREQ_HZ = 50_000_000; // System clock frequency\n    parameter integer BAUD_RATE   = 115200;     // Default baud rate\n\n    // Derived constants\n    localparam integer BAUD_DIV = CLK_FREQ_HZ / BAUD_RATE;\n\n    // === Transmit State Machine ===\n    typedef enum logic [2:0] {\n        TX_IDLE,\n        TX_START,\n        TX_DATA,\n        TX_PARITY,\n        TX_STOP1,\n        TX_STOP2\n    } tx_state_t;\n\n    tx_state_t tx_state;\n    logic [3:0] tx_bit_cnt;\n    logic [7:0] tx_shift_reg;\n    logic       tx_parity_bit;\n    logic       tx_parity_en;\n    logic [15:0] tx_baud_cnt;\n\n    // === Receive State Machine ===\n    typedef enum logic [2:0] {\n        RX_IDLE,\n        RX_START,\n        RX_DATA,\n        RX_PARITY,\n        RX_STOP1,\n        RX_STOP2\n    } rx_state_t;\n\n    rx_state_t rx_state;\n    logic [3:0] rx_bit_cnt;\n    logic [7:0] rx_shift_reg;\n    logic       rx_parity_bit;\n    logic       rx_parity_en;\n    logic [15:0] rx_baud_cnt;\n    logic [15:0] rx_baud_half;\n    logic       rx_sampled;\n    logic       rx_error;\n\n    // === Output Registers ===\n    logic [8:0] rx_data_out;\n    logic       tx_busy, tx_ready;\n    logic       rx_data_valid;\n\n    // === Assign Outputs ===\n    assign UART_Ready = tx_ready;\n    assign UART_Busy  = tx_busy;\n    assign UART_Error = rx_error;\n    assign data_out   = rx_data_out;\n    assign TX         = (tx_state == TX_IDLE) ? 1'b1 : // Idle line is high\n                        (tx_state == TX_START) ? 1'b0 : // Start bit\n                        (tx_state == TX_DATA)  ? tx_shift_reg[0] :\n                        (tx_state == TX_PARITY)? tx_parity_bit :\n                        1'b1; // Stop bits\n\n    // === Transmit Logic ===\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tx_state      <= TX_IDLE;\n            tx_bit_cnt    <= 0;\n            tx_shift_reg  <= 0;\n            tx_parity_bit <= 0;\n            tx_parity_en  <= 0;\n            tx_baud_cnt   <= 0;\n            tx_busy       <= 0;\n            tx_ready      <= 1;\n        end else begin\n            case (tx_state)\n                TX_IDLE: begin\n                    tx_busy  <= 0;\n                    tx_ready <= 1;\n                    tx_baud_cnt <= 0;\n                    if (UART_Start) begin\n                        tx_shift_reg  <= data_in[7:0];\n                        tx_parity_en  <= data_in[8];\n                        tx_parity_bit <= ^data_in[7:0]; // Even parity\n                        tx_bit_cnt    <= 0;\n                        tx_state      <= TX_START;\n                        tx_busy       <= 1;\n                        tx_ready      <= 0;\n                    end\n                end\n                TX_START: begin\n                    if (tx_baud_cnt == BAUD_DIV-1) begin\n                        tx_baud_cnt <= 0;\n                        tx_state    <= TX_DATA;\n                    end else begin\n                        tx_baud_cnt <= tx_baud_cnt + 1;\n                    end\n                end\n                TX_DATA: begin\n                    if (tx_baud_cnt == BAUD_DIV-1) begin\n                        tx_baud_cnt <= 0;\n                        tx_shift_reg <= {1'b0, tx_shift_reg[7:1]};\n                        tx_bit_cnt <= tx_bit_cnt + 1;\n                        if (tx_bit_cnt == 7) begin\n                            if (tx_parity_en)\n                                tx_state <= TX_PARITY;\n                            else\n                                tx_state <= TX_STOP1;\n                        end\n                    end else begin\n                        tx_baud_cnt <= tx_baud_cnt + 1;\n                    end\n                end\n                TX_PARITY: begin\n                    if (tx_baud_cnt == BAUD_DIV-1) begin\n                        tx_baud_cnt <= 0;\n                        tx_state    <= TX_STOP1;\n                    end else begin\n                        tx_baud_cnt <= tx_baud_cnt + 1;\n                    end\n                end\n                TX_STOP1: begin\n                    if (tx_baud_cnt == BAUD_DIV-1) begin\n                        tx_baud_cnt <= 0;\n                        tx_state    <= TX_STOP2;\n                    end else begin\n                        tx_baud_cnt <= tx_baud_cnt + 1;\n                    end\n                end\n                TX_STOP2: begin\n                    if (tx_baud_cnt == BAUD_DIV-1) begin\n                        tx_baud_cnt <= 0;\n                        tx_state    <= TX_IDLE;\n                    end else begin\n                        tx_baud_cnt <= tx_baud_cnt + 1;\n                    end\n                end\n                default: tx_state <= TX_IDLE;\n            endcase\n        end\n    end\n\n    // === Receive Logic ===\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_state      <= RX_IDLE;\n            rx_bit_cnt    <= 0;\n            rx_shift_reg  <= 0;\n            rx_parity_bit <= 0;\n            rx_parity_en  <= 0;\n            rx_baud_cnt   <= 0;\n            rx_baud_half  <= 0;\n            rx_data_out   <= 0;\n            rx_data_valid <= 0;\n            rx_error      <= 0;\n        end else begin\n            rx_data_valid <= 0;\n            case (rx_state)\n                RX_IDLE: begin\n                    rx_error <= 0;\n                    if (~RX) begin // Start bit detected (line goes low)\n                        rx_baud_cnt  <= 0;\n                        rx_baud_half <= BAUD_DIV/2;\n                        rx_state     <= RX_START;\n                    end\n                end\n                RX_START: begin\n                    if (rx_baud_cnt == rx_baud_half) begin\n                        if (~RX) begin // Confirm start bit still low\n                            rx_baud_cnt <= 0;\n                            rx_bit_cnt  <= 0;\n                            rx_state    <= RX_DATA;\n                        end else begin\n                            rx_state <= RX_IDLE; // False start bit\n                        end\n                    end else begin\n                        rx_baud_cnt <= rx_baud_cnt + 1;\n                    end\n                end\n                RX_DATA: begin\n                    if (rx_baud_cnt == BAUD_DIV-1) begin\n                        rx_baud_cnt <= 0;\n                        rx_shift_reg <= {RX, rx_shift_reg[7:1]};\n                        rx_bit_cnt <= rx_bit_cnt + 1;\n                        if (rx_bit_cnt == 7) begin\n                            rx_parity_en <= 0; // Default: no parity\n                            rx_state <= RX_STOP1;\n                        end\n                    end else begin\n                        rx_baud_cnt <= rx_baud_cnt + 1;\n                    end\n                end\n                RX_PARITY: begin\n                    if (rx_baud_cnt == BAUD_DIV-1) begin\n                        rx_baud_cnt <= 0;\n                        rx_parity_bit <= RX;\n                        rx_state <= RX_STOP1;\n                    end else begin\n                        rx_baud_cnt <= rx_baud_cnt + 1;\n                    end\n                end\n                RX_STOP1: begin\n                    if (rx_baud_cnt == BAUD_DIV-1) begin\n                        rx_baud_cnt <= 0;\n                        if (RX) begin\n                            rx_state <= RX_STOP2;\n                        end else begin\n                            rx_error <= 1; // Framing error\n                            rx_state <= RX_IDLE;\n                        end\n                    end else begin\n                        rx_baud_cnt <= rx_baud_cnt + 1;\n                    end\n                end\n                RX_STOP2: begin\n                    if (rx_baud_cnt == BAUD_DIV-1) begin\n                        rx_baud_cnt <= 0;\n                        if (RX) begin\n                            // Parity check (if enabled)\n                            if (rx_parity_en) begin\n                                if (rx_parity_bit != ^rx_shift_reg) begin\n                                    rx_error <= 1; // Parity error\n                                end\n                            end\n                            rx_data_out   <= {rx_parity_en, rx_shift_reg};\n                            rx_data_valid <= 1;\n                        end else begin\n                            rx_error <= 1; // Framing error\n                        end\n                        rx_state <= RX_IDLE;\n                    end else begin\n                        rx_baud_cnt <= rx_baud_cnt + 1;\n                    end\n                end\n                default: rx_state <= RX_IDLE;\n            endcase\n        end\n    end\n\nendmodule\n```\n\n**Notes:**\n- `data_in[8]` and `data_out[8]` are used as the \"parity enable\" bit. If set, parity is used.\n- Parity is even parity (`^data_in[7:0]`).\n- Two stop bits are always sent and expected.\n- `UART_Ready` is high when ready for a new transmit.\n- `UART_Busy` is high during transmission.\n- `UART_Error` is high for one cycle if a framing or parity error is detected.\n- Baud rate is set by `BAUD_RATE` and `CLK_FREQ_HZ` parameters.\n- The receiver samples the start bit at the middle of the bit period for robustness.\n- The module is full-duplex: transmit and receive logic are independent.\n\n**You may need to adapt the parity enable logic if you want to dynamically configure parity per byte or globally.**"
}
