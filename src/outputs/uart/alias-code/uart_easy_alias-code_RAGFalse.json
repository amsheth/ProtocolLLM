{
    "prompt_0": "Write a SystemVerilog module to implement a UART (Universal Asynchronous Receiver-Transmitter) controller. The module should support configurable baud rates, transmit and receive functionality, and proper start, data, parity (optional), and stop bit handling. The UART should operate in full-duplex mode and adhere to the following interface:\nmodule UART_driver( input  logic       clk,        // System clock input  logic       rst,        // Asynchronous reset input  logic       UART_Start, // Signal to initiate transmission input  logic [7:0] data_in,    // Data to be transmitted input  logic       RX,         // UART receive line output logic       TX,         // UART transmit line output logic [7:0] data_out,   // Received data output logic       UART_Ready, // Ready to transmit next byte output logic       UART_Busy,  // Indicates UART is currently transmitting output logic       UART_Error  // High if framing or parity error detected ); ",
    "answer_0": "```systemverilog\nmodule UART_driver(\n    input  logic       clk,        // System clock\n    input  logic       rst,        // Asynchronous reset\n    input  logic       UART_Start, // Signal to initiate transmission\n    input  logic [7:0] data_in,    // Data to be transmitted\n    input  logic       RX,         // UART receive line\n    output logic       TX,         // UART transmit line\n    output logic [7:0] data_out,   // Received data\n    output logic       UART_Ready, // Ready to transmit next byte\n    output logic       UART_Busy,  // Indicates UART is currently transmitting\n    output logic       UART_Error  // High if framing or parity error detected\n);\n\n    // Parameters\n    parameter BAUD_RATE = 9600; // Default baud rate\n    parameter CLK_FREQ = 50_000_000; // System clock frequency\n\n    // Internal signals\n    logic [31:0] baud_count;\n    logic [7:0] tx_data;\n    logic [7:0] rx_data;\n    logic tx_start;\n    logic rx_start;\n    logic tx_done;\n    logic rx_done;\n    logic tx_error;\n    logic rx_error;\n    logic [2:0] bit_count;\n    logic [2:0] rx_bit_count;\n    logic [1:0] parity;\n    logic parity_error;\n\n    // Baud rate generator\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            baud_count <= 32'h0;\n        end else if (baud_count == (CLK_FREQ / (16 * BAUD_RATE)) - 1) begin\n            baud_count <= 32'h0;\n        end else begin\n            baud_count <= baud_count + 1;\n        end\n    end\n\n    // Transmit logic\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tx_data <= 8'h0;\n            tx_start <= 1'b0;\n            tx_done <= 1'b0;\n            tx_error <= 1'b0;\n            bit_count <= 3'b0;\n        end else if (UART_Start) begin\n            tx_data <= data_in;\n            tx_start <= 1'b1;\n            tx_done <= 1'b0;\n            tx_error <= 1'b0;\n            bit_count <= 3'b0;\n        end else if (tx_start && baud_count == (CLK_FREQ / (16 * BAUD_RATE)) - 1) begin\n            if (bit_count < 8) begin\n                TX <= tx_data[bit_count];\n                tx_data <= {tx_data[6:0], 1'b0};\n                bit_count <= bit_count + 1;\n            end else begin\n                TX <= 1'b1;\n                tx_start <= 1'b0;\n                tx_done <= 1'b1;\n            end\n        end\n    end\n\n    // Receive logic\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_data <= 8'h0;\n            rx_start <= 1'b0;\n            rx_done <= 1'b0;\n            rx_error <= 1'b0;\n            rx_bit_count <= 3'b0;\n        end else if (RX == 1'b0 && baud_count == (CLK_FREQ / (16 * BAUD_RATE)) - 1) begin\n            if (rx_bit_count < 8) begin\n                rx_data <= {rx_data[6:0], RX};\n                rx_bit_count <= rx_bit_count + 1;\n            end else begin\n                rx_data <= {rx_data[6:0], RX};\n                rx_start <= 1'b1;\n                rx_done <= 1'b0;\n                rx_bit_count <= 3'b0;\n            end\n        end else if (rx_start && baud_count == (CLK_FREQ / (16 * BAUD_RATE)) - 1) begin\n            if (rx_bit_count < 8) begin\n                rx_data <= {rx_data[6:0], RX};\n                rx_bit_count <= rx_bit_count + 1;\n            end else begin\n                rx_data <= {rx_data[6:0], RX};\n                rx_start <= 1'b0;\n                rx_done <= 1'b1;\n            end\n        end\n    end\n\n    // Parity logic\n    always_comb begin\n        parity = 2'b00;\n        for (int i = 0; i < 8; i++) begin\n            parity = parity ^ rx_data[i];\n        end\n    end\n\n    // Error detection\n    always_comb begin\n        if (rx_done) begin\n            if (RX != 1'b1) begin\n                rx_error = 1'b1;\n            end else if (parity != parity_error) begin\n                rx_error = 1'b1;\n            end else begin\n                rx_error = 1'b0;\n            end\n        end else begin\n            rx_error = 1'b0;\n        end\n    end\n\n    // Output logic\n    assign UART_Ready = !tx_start && !rx_start;\n    assign UART_Busy = tx_start || rx_start;\n    assign UART_Error = rx_error;\n    assign data_out = rx_data;\n\nendmodule\n```\n\nThis SystemVerilog module implements a UART controller with configurable baud rates, transmit and receive functionality, and proper start, data, parity (optional), and stop bit handling. The UART operates in full-duplex mode and adheres to the specified interface. The module includes a baud rate generator, transmit logic, receive logic, parity logic, and error detection."
}
