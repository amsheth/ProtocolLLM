{
    "prompt_0": "Write a SystemVerilog module to implement a UART (Universal Asynchronous Receiver-Transmitter) controller. The module should support configurable baud rates, transmit and receive functionality, and proper start, data, parity (optional), and stop bit handling. The UART should operate in full-duplex mode and adhere to the following interface:\nmodule UART_driver( input  logic       clk,        // System clock input  logic       rst,        // Asynchronous reset input  logic       UART_Start, // Signal to initiate transmission input  logic [7:0] data_in,    // Data to be transmitted input  logic       RX,         // UART receive line output logic       TX,         // UART transmit line output logic [7:0] data_out,   // Received data output logic       UART_Ready, // Ready to transmit next byte output logic       UART_Busy,  // Indicates UART is currently transmitting output logic       UART_Error  // High if framing or parity error detected ); ",
    "answer_0": "Below is a simplified SystemVerilog module for a UART controller. This module supports basic UART functionality including configurable baud rates, transmit and receive operations, and handles start, data, and stop bits. Parity bit handling is optional and can be enabled/disabled by setting the `USE_PARITY` parameter. The module operates in full-duplex mode.\n\n```systemverilog\nmodule UART_driver #(\n    parameter int BAUD_RATE = 9600, // Baud rate\n    parameter int CLK_FREQ = 50_000_000, // System clock frequency\n    parameter bit USE_PARITY = 0 // Set to 1 to enable parity bit\n)(\n    input  logic       clk,        // System clock input\n    input  logic       rst,        // Asynchronous reset input\n    input  logic       UART_Start, // Signal to initiate transmission\n    input  logic [7:0] data_in,    // Data to be transmitted\n    input  logic       RX,         // UART receive line\n    output logic       TX,         // UART transmit line\n    output logic [7:0] data_out,   // Received data\n    output logic       UART_Ready, // Ready to transmit next byte\n    output logic       UART_Busy,  // Indicates UART is currently transmitting\n    output logic       UART_Error  // High if framing or parity error detected\n);\n\n    // Internal signals\n    logic [15:0] baud_divisor;\n    logic [3:0] bit_counter;\n    logic [7:0] tx_buffer;\n    logic [7:0] rx_buffer;\n    logic tx_start;\n    logic rx_start;\n    logic tx_done;\n    logic rx_done;\n    logic parity_bit;\n    logic parity_error;\n    logic framing_error;\n\n    // Baud rate divisor calculation\n    assign baud_divisor = (CLK_FREQ / BAUD_RATE) / 2;\n\n    // UART transmitter\n    UART_TX #(\n        .BAUD_RATE(BAUD_RATE),\n        .CLK_FREQ(CLK_FREQ),\n        .USE_PARITY(USE_PARITY)\n    ) uart_tx (\n        .clk(clk),\n        .rst(rst),\n        .start(tx_start),\n        .data_in(tx_buffer),\n        .tx(TX),\n        .done(tx_done),\n        .busy(UART_Busy)\n    );\n\n    // UART receiver\n    UART_RX #(\n        .BAUD_RATE(BAUD_RATE),\n        .CLK_FREQ(CLK_FREQ),\n        .USE_PARITY(USE_PARITY)\n    ) uart_rx (\n        .clk(clk),\n        .rst(rst),\n        .rx(RX),\n        .data_out(rx_buffer),\n        .parity_error(parity_error),\n        .framing_error(framing_error),\n        .done(rx_done)\n    );\n\n    // Transmit control logic\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tx_start <= 0;\n            UART_Ready <= 1;\n        end else begin\n            if (UART_Start && UART_Ready) begin\n                tx_start <= 1;\n                tx_buffer <= data_in;\n                UART_Ready <= 0;\n            end else if (tx_done) begin\n                tx_start <= 0;\n                UART_Ready <= 1;\n            end\n        end\n    end\n\n    // Receive control logic\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            data_out <= 0;\n            UART_Error <= 0;\n        end else begin\n            if (rx_done) begin\n                data_out <= rx_buffer;\n                UART_Error <= parity_error || framing_error;\n            end\n        end\n    end\n\nendmodule\n\n// UART_TX module\nmodule UART_TX #(\n    parameter int BAUD_RATE = 9600,\n    parameter int CLK_FREQ = 50_000_000,\n    parameter bit USE_PARITY = 0\n)(\n    input  logic       clk,\n    input  logic       rst,\n    input  logic       start,\n    input  logic [7:0] data_in,\n    output logic       tx,\n    output logic       done,\n    output logic       busy\n);\n\n    // Internal signals\n    logic [15:0] baud_counter;\n    logic [3:0] bit_counter;\n    logic [8:0] tx_shift_reg;\n    logic parity_bit;\n\n    // Parity bit calculation\n    assign parity_bit = USE_PARITY ? ^data_in : 1'b0;\n\n    // Transmit state machine\n    typedef enum logic [2:0] {\n        IDLE,\n        START,\n        DATA,\n        PARITY,\n        STOP\n    } tx_state_t;\n\n    tx_state_t state, next_state;\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            baud_counter <= 0;\n            bit_counter <= 0;\n            tx_shift_reg <= 0;\n            tx <= 1;\n            done <= 0;\n            busy <= 0;\n        end else begin\n            state <= next_state;\n            done <= 0;\n            case (state)\n                IDLE: begin\n                    if (start) begin\n                        baud_counter <= baud_divisor;\n                        bit_counter <= 0;\n                        tx_shift_reg <= {parity_bit, data_in, 1'b0}; // Start bit is 0\n                        tx <= 0;\n                        busy <= 1;\n                    end\n                end\n                START: begin\n                    if (baud_counter == 0) begin\n                        baud_counter <= baud_divisor;\n                        bit_counter <= bit_counter + 1;\n                        tx <= tx_shift_reg[0];\n                        tx_shift_reg <= tx_shift_reg >> 1;\n                    end else begin\n                        baud_counter <= baud_counter - 1;\n                    end\n                end\n                DATA: begin\n                    if (baud_counter == 0) begin\n                        baud_counter <= baud_divisor;\n                        bit_counter <= bit_counter + 1;\n                        tx <= tx_shift_reg[0];\n                        tx_shift_reg <= tx_shift_reg >> 1;\n                        if (bit_counter == 7) begin\n                            next_state <= USE_PARITY ? PARITY : STOP;\n                        end\n                    end else begin\n                        baud_counter <= baud_counter - 1;\n                    end\n                end\n                PARITY: begin\n                    if (baud_counter == 0) begin\n                        baud_counter <= baud_divisor;\n                        tx <= parity_bit;\n                        next_state <= STOP;\n                    end else begin\n                        baud_counter <= baud_counter - 1;\n                    end\n                end\n                STOP: begin\n                    if (baud_counter == 0) begin\n                        baud_counter <= baud_divisor;\n                        tx <= 1;\n                        done <= 1;\n                        busy <= 0;\n                        next_state <= IDLE;\n                    end else begin\n                        baud_counter <= baud_counter - 1;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule\n\n// UART_RX module\nmodule UART_RX #(\n    parameter int BAUD_RATE = 9600,\n    parameter int CLK_FREQ = 50_000_000,\n    parameter bit USE_PARITY = 0\n)(\n    input  logic       clk,\n    input  logic       rst,\n    input  logic       rx,\n    output logic [7:0] data_out,\n    output logic       parity_error,\n    output logic       framing_error,\n    output logic       done\n);\n\n    // Internal signals\n    logic [15:0] baud_counter;\n    logic [3:0] bit_counter;\n    logic [8:0] rx_shift_reg;\n    logic expected_parity;\n\n    // Receive state machine\n    typedef enum logic [2:0] {\n        IDLE,\n        START,\n        DATA,\n        PARITY,\n        STOP\n    } rx_state_t;\n\n    rx_state_t state, next_state;\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            baud_counter <= 0;\n            bit_counter <= 0;\n            rx_shift_reg <= 0;\n            data_out <= 0;\n            parity_error <= 0;\n            framing_error <= 0;\n            done <= 0;\n        end else begin\n            state <= next_state;\n            done <= 0;\n            case (state)\n                IDLE: begin\n                    if (rx == 0) begin // Start bit detection\n                        baud_counter <= baud_divisor;\n                        bit_counter <= 0;\n                        rx_shift_reg <= 0;\n                        next_state <= START;\n                    end\n                end\n                START: begin\n                    if (baud_counter == 0) begin\n                        baud_counter <= baud_divisor;\n                        if (rx == 0) begin // Confirm start bit\n                            next_state <= DATA;\n                        end else begin\n                            next_state <= IDLE;\n                        end\n                    end else begin\n                        baud_counter <= baud_counter - 1;\n                    end\n                end\n                DATA: begin\n                    if (baud_counter == 0) begin\n                        baud_counter <= baud_divisor;\n                        bit_counter <= bit_counter + 1;\n                        rx_shift_reg <= {rx, rx_shift_reg[8:1]};\n                        if (bit_counter == 7) begin\n                            next_state <= USE_PARITY ? PARITY : STOP;\n                        end\n                    end else begin\n                        baud_counter <= baud_counter - 1;\n                    end\n                end\n                PARITY: begin\n                    if (baud_counter == 0) begin\n                        baud_counter <= baud_divisor;\n                        expected_parity <= ^rx_shift_reg[7:0];\n                        if (rx != expected_parity) begin\n                            parity_error <= 1;\n                        end\n                        next_state <= STOP;\n                    end else begin\n                        baud_counter <= baud_counter - 1;\n                    end\n                end\n                STOP: begin\n                    if (baud_counter == 0) begin\n                        baud_counter <= baud_divisor;\n                        if (rx == 1) begin // Confirm stop bit\n                            data_out <= rx_shift_reg[7:0];\n                            done <= 1;\n                        end else begin\n                            framing_error <= 1;\n                        end\n                        next_state <= IDLE;\n                    end else begin\n                        baud_counter <= baud_counter - 1;\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule\n```\n\nThis code provides a basic UART controller with configurable baud rates and optional parity bit support. The `UART_TX` and `UART_RX` submodules handle the transmission and reception of data, respectively. The main `UART_driver` module manages the control logic for these submodules, including handling the UART_Start signal and providing the UART_Ready, UART_Busy, and UART_Error outputs. Note that this is a simplified implementation and may require further refinement for production use, such as handling edge cases, optimizing timing, and adding more robust error detection and handling."
}
