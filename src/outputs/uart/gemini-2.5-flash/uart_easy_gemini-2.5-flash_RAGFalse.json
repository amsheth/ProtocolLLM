{
    "prompt_0": "Write a SystemVerilog module to implement a UART (Universal Asynchronous Receiver-Transmitter) controller. The module should support configurable baud rates, transmit and receive functionality, and proper start, data, parity (optional), and stop bit handling. The UART should operate in full-duplex mode and adhere to the following interface:\nmodule UART_driver( input  logic       clk,        // System clock input  logic       rst,        // Asynchronous reset input  logic       UART_Start, // Signal to initiate transmission input  logic [7:0] data_in,    // Data to be transmitted input  logic       RX,         // UART receive line output logic       TX,         // UART transmit line output logic [7:0] data_out,   // Received data output logic       UART_Ready, // Ready to transmit next byte output logic       UART_Busy,  // Indicates UART is currently transmitting output logic       UART_Error  // High if framing or parity error detected ); ",
    "answer_0": "To implement the UART (Universal Asynchronous Receiver-Transmitter) controller in SystemVerilog, we will design a full-duplex module with separate transmit (TX) and receive (RX) state machines. The module will support configurable baud rates, optional parity, and flexible stop bit configurations.\n\n**Key Features and Design Choices:**\n\n1.  **Configurable Parameters:**\n    *   `CLK_FREQ`: System clock frequency in Hz.\n    *   `BAUD_RATE`: Desired baud rate in bits per second.\n    *   `PARITY_EN`: Enables/disables parity (0 for no parity, 1 for parity).\n    *   `PARITY_TYPE`: Configures parity type (0 for even, 1 for odd, if `PARITY_EN` is 1).\n    *   `STOP_BITS`: Configures the number of stop bits (1 or 2).\n\n2.  **Baud Rate Generation:**\n    *   A `BAUD_DIVISOR` is calculated (`CLK_FREQ / BAUD_RATE`) to determine the number of clock cycles per bit period.\n    *   Internal counters (`tx_baud_count`, `rx_baud_count`) are used to time each bit period.\n\n3.  **Transmit (TX) Logic:**\n    *   **State Machine:** `TX_IDLE`, `TX_START`, `TX_DATA`, `TX_PARITY`, `TX_STOP`.\n    *   **`UART_Start`:** This input is edge-detected (rising edge) to initiate a single byte transmission. This prevents re-triggering if the signal is held high.\n    *   **Data Transmission:** Data is transmitted LSB (Least Significant Bit) first. A shift register (`tx_data_shift_reg`) is used for this purpose.\n    *   **Parity:** If enabled, the parity bit is calculated based on `data_in` and `PARITY_TYPE` and transmitted after the data bits.\n    *   **Stop Bits:** One or two stop bits (logic high) are transmitted after data/parity.\n    *   **Outputs:** `TX` (the UART transmit line), `UART_Busy` (high during transmission), and `UART_Ready` (high when ready for a new byte).\n\n4.  **Receive (RX) Logic:**\n    *   **State Machine:** `RX_IDLE`, `RX_START`, `RX_DATA`, `RX_PARITY`, `RX_STOP`.\n    *   **Input Synchronization:** The `RX` input is synchronized using a 2-flop synchronizer (`rx_sync_reg_1`, `rx_sync_reg_2`) to prevent metastability issues.\n    *   **Start Bit Detection:** A falling edge on the synchronized `RX` line triggers the start of reception.\n    *   **Bit Sampling:** All bits (start, data, parity, stop) are sampled approximately in the middle of their respective bit periods for maximum reliability.\n    *   **Data Reception:** Received bits are shifted into `rx_data_shift_reg`. Since UART transmits LSB first, the received byte is stored in reverse order in the shift register and then re-ordered before being presented on `data_out`.\n    *   **Error Detection:**\n        *   **Framing Error:** Detected if the start bit is not low, or if a stop bit is not high.\n        *   **Parity Error:** If parity is enabled, the calculated parity of the received data is compared with the received parity bit.\n    *   **Outputs:** `data_out` (the received 8-bit data), and `UART_Error` (high if a framing or parity error is detected). `UART_Error` is sticky until a new reception attempt begins.\n\n**SystemVerilog Module:**\n\n\n```systemverilog\nmodule UART_driver #(\n    parameter CLK_FREQ    = 50_000_000, // System clock frequency in Hz (e.g., 50 MHz)\n    parameter BAUD_RATE   = 115200,     // Desired baud rate (e.g., 115200 bps)\n    parameter PARITY_EN   = 0,          // 0: No parity, 1: Parity enabled\n    parameter PARITY_TYPE = 0,          // 0: Even parity, 1: Odd parity (if PARITY_EN = 1)\n    parameter STOP_BITS   = 1           // 1: One stop bit, 2: Two stop bits\n) (\n    input  logic       clk,        // System clock\n    input  logic       rst,        // Asynchronous reset (active high)\n    input  logic       UART_Start, // Signal to initiate transmission (rising edge)\n    input  logic [7:0] data_in,    // Data to be transmitted\n    input  logic       RX,         // UART receive line\n    output logic       TX,         // UART transmit line\n    output logic [7:0] data_out,   // Received data\n    output logic       UART_Ready, // Ready to transmit next byte\n    output logic       UART_Busy,  // Indicates UART is currently transmitting\n    output logic       UART_Error  // High if framing or parity error detected\n);\n\n    // Calculate baud rate divisor\n    localparam BAUD_DIVISOR = CLK_FREQ / BAUD_RATE;\n    localparam BAUD_DIVISOR_HALF = BAUD_DIVISOR / 2;\n\n    // Check for valid baud rate divisor\n    initial begin\n        if (BAUD_DIVISOR < 16) begin // A common rule of thumb for reliable sampling (at least 8-16 samples per bit)\n            $error(\"BAUD_DIVISOR is too small for reliable UART operation. Increase CLK_FREQ or decrease BAUD_RATE.\");\n        end\n    end\n\n    // Internal signals for TX\n    typedef enum logic [2:0] {\n        TX_IDLE,\n        TX_START,\n        TX_DATA,\n        TX_PARITY,\n        TX_STOP\n    } tx_state_t;\n\n    tx_state_t tx_state_reg, tx_state_next;\n    logic [7:0] tx_data_shift_reg;\n    logic [3:0] tx_bit_count; // 0-7 for data, 8 for parity, 9 for stop1, 10 for stop2\n    logic [$clog2(BAUD_DIVISOR)-1:0] tx_baud_count;\n    logic tx_parity_bit;\n    logic tx_busy_internal; // Internal busy signal for TX\n    logic tx_ready_internal; // Internal ready signal for TX\n\n    // UART_Start edge detection for TX trigger\n    logic uart_start_sync_1, uart_start_sync_2;\n    logic uart_start_pulse;\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            uart_start_sync_1 <= 1'b0;\n            uart_start_sync_2 <= 1'b0;\n        end else begin\n            uart_start_sync_1 <= UART_Start;\n            uart_start_sync_2 <= uart_start_sync_1;\n        end\n    end\n    assign uart_start_pulse = uart_start_sync_1 && ~uart_start_sync_2; // Rising edge detector\n\n    // Internal signals for RX\n    typedef enum logic [2:0] {\n        RX_IDLE,\n        RX_START,\n        RX_DATA,\n        RX_PARITY,\n        RX_STOP\n    } rx_state_t;\n\n    rx_state_t rx_state_reg, rx_state_next;\n    logic [7:0] rx_data_shift_reg;\n    logic [3:0] rx_bit_count;\n    logic [$clog2(BAUD_DIVISOR)-1:0] rx_baud_count;\n    logic rx_sync_reg_1, rx_sync_reg_2; // For input synchronization\n    logic rx_start_edge; // Detects falling edge for start bit\n    logic rx_parity_calc;\n    logic rx_error_internal; // Internal error signal for RX\n    logic rx_data_valid; // Indicates new data is available\n    logic [7:0] data_out_reg; // Register to hold received data before output\n\n    // Output assignments\n    assign UART_Busy  = tx_busy_internal;\n    assign UART_Ready = tx_ready_internal;\n    assign UART_Error = rx_error_internal;\n    assign data_out   = data_out_reg; // Assign from register\n\n    // Synchronize RX input\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_sync_reg_1 <= 1'b1; // Default to high (idle)\n            rx_sync_reg_2 <= 1'b1;\n        end else begin\n            rx_sync_reg_1 <= RX;\n            rx_sync_reg_2 <= rx_sync_reg_1;\n        end\n    end\n\n    // Detect falling edge on synchronized RX for start bit\n    assign rx_start_edge = (~rx_sync_reg_2) && rx_sync_reg_1; // rx_sync_reg_1 is current, rx_sync_reg_2 is previous\n\n    // =====================================================================\n    // Transmit (TX) Logic\n    // =====================================================================\n\n    // TX State Register\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tx_state_reg <= TX_IDLE;\n        end else begin\n            tx_state_reg <= tx_state_next;\n        end\n    end\n\n    // TX Next State Logic and Output Logic\n    always_comb begin\n        tx_state_next = tx_state_reg;\n        TX = 1'b1; // Default to high (idle state)\n        tx_busy_internal = 1'b0;\n        tx_ready_internal = 1'b1; // Default ready\n\n        // Default values for counters and registers (keep current values)\n        tx_baud_count = tx_baud_count;\n        tx_bit_count = tx_bit_count;\n        tx_data_shift_reg = tx_data_shift_reg;\n        tx_parity_bit = tx_parity_bit;\n\n        case (tx_state_reg)\n            TX_IDLE: begin\n                TX = 1'b1; // Idle high\n                tx_busy_internal = 1'b0;\n                tx_ready_internal = 1'b1;\n                tx_baud_count = '0; // Reset baud counter\n                tx_bit_count = '0;  // Reset bit counter\n\n                if (uart_start_pulse) begin // Trigger on rising edge of UART_Start\n                    tx_state_next = TX_START;\n                    tx_data_shift_reg = data_in; // Load data for transmission\n                    // Calculate parity for data_in\n                    if (PARITY_EN) begin\n                        logic parity_sum = 1'b0;\n                        for (int i = 0; i < 8; i++) begin\n                            parity_sum = parity_\nsum ^ data_in[i];\n                        end\n                        tx_parity_bit = (PARITY_TYPE == 0) ? parity_sum : ~parity_sum; // Even or Odd\n                    end else begin\n                        tx_parity_bit = 1'b0; // Not used if parity disabled\n                    end\n                end\n            end\n\n            TX_START: begin\n                TX = 1'b0; // Start bit (low)\n                tx_busy_internal = 1'b1;\n                tx_ready_internal = 1'b0; // Not ready during transmission\n\n                if (tx_baud_count == BAUD_DIVISOR - 1) begin\n                    tx_baud_count = '0;\n                    tx_state_next = TX_DATA;\n                    tx_bit_count = '0; // Reset for data bits\n                end else begin\n                    tx_baud_count = tx_baud_count + 1;\n                end\n            end\n\n            TX_DATA: begin\n                TX = tx_data_shift_reg[0]; // Transmit LSB first\n                tx_busy_internal = 1'b1;\n                tx_ready_internal = 1'b0;\n\n                if (tx_baud_count == BAUD_DIVISOR - 1) begin\n                    tx_baud_count = '0;\n                    tx_data_shift_reg = tx_data_shift_reg >> 1; // Shift right for next bit\n                    if (tx_bit_count == 7) begin // All 8 data bits sent\n                        if (PARITY_EN) begin\n                            tx_state_next = TX_PARITY;\n                        end else begin\n                            tx_state_next = TX_STOP;\n                            tx_bit_count = '0; // Reset for stop bits\n                        end\n                    end else begin\n                        tx_bit_count = tx_bit_count + 1;\n                    end\n                end else begin\n                    tx_baud_count = tx_baud_count + 1;\n                end\n            end\n\n            TX_PARITY: begin\n                TX = tx_parity_bit; // Transmit parity bit\n                tx_busy_internal = 1'b1;\n                tx_ready_internal = 1'b0;\n\n                if (tx_baud_count == BAUD_DIVISOR - 1) begin\n                    tx_baud_count = '0;\n                    tx_state_next = TX_STOP;\n                    tx_bit_count = '0; // Reset for stop bits\n                end else begin\n                    tx_baud_count = tx_baud_count + 1;\n                end\n            end\n\n            TX_STOP: begin\n                TX = 1'b1; // Stop bit (high)\n                tx_busy_internal = 1'b1;\n                tx_ready_internal = 1'b0;\n\n                if (tx_baud_count == BAUD_DIVISOR - 1) begin\n                    tx_baud_count = '0;\n                    if (tx_bit_count == STOP_BITS - 1) begin // All stop bits sent\n                        tx_state_next = TX_IDLE;\n                    end else begin\n                        tx_bit_count = tx_bit_count + 1;\n                    end\n                end else begin\n                    tx_baud_count = tx_baud_count + 1;\n                end\n            end\n\n            default: begin\n                tx_state_next = TX_IDLE; // Should not happen\n            end\n        endcase\n    end\n\n    // =====================================================================\n    // Receive (RX) Logic\n    // =====================================================================\n\n    // RX State Register and Output Data Register\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_state_reg <= RX_IDLE;\n            rx_error_internal <= 1'b0;\n            rx_data_valid <= 1'b0;\n            data_out_reg <= '0;\n        end else begin\n            rx_state_reg <= rx_state_next;\n            // Clear error on new reception attempt (entering IDLE from non-IDLE)\n            // or if a new start bit is detected while in IDLE\n            if ((rx_state_next == RX_IDLE && rx_state_reg != RX_IDLE) || (rx_state_reg == RX_IDLE && rx_start_edge)) begin\n                rx_error_internal <= 1'b0;\n            end\n            if (rx_data_valid) begin\n                // Reverse the bits of rx_data_shift_reg for data_out_reg\n                // rx_data_shift_reg has LSB at bit 7, MSB at bit 0 (due to shifting in MSB first)\n                // We want data_out_reg[0] to be LSB, data_out_reg[7] to be MSB\n                for (int i = 0; i < 8; i++) begin\n                    data_out_reg[i] <= rx_data_shift_reg[7-i];\n                end\n                rx_data_valid <= 1'b0; // Clear data valid after one cycle\n            end\n        end\n    end\n\n    // RX Next State Logic and Data Capture\n    always_comb begin\n        rx_state_next = rx_state_reg;\n        rx_baud_count = rx_baud_count;\n        rx_bit_count = rx_bit_count;\n        rx_data_shift_reg = rx_data_shift_reg;\n        rx_parity_calc = rx_parity_calc;\n\n        case (rx_state_reg)\n            RX_IDLE: begin\n                rx_baud_count = '0;\n                rx_bit_count = '0;\n                rx_data_shift_reg = '0;\n\n                if (rx_start_edge) begin // Detect falling edge for start bit\n                    rx_state_next = RX_START;\n                end\n            end\n\n            RX_START: begin\n                if (rx_baud_count == BAUD_DIVISOR_HALF - 1) begin // Sample in the middle of the start bit\n                    if (rx_sync_reg_2 == 1'b1) begin // Should be low, if high, it's a false start\n                        rx_error_internal = 1'b1;\n                        rx_state_next = RX_IDLE; // Go back to idle immediately\n                    end\n                end\n\n                if (rx_baud_count == BAUD_DIVISOR - 1) begin // End of start bit period\n                    rx_baud_count = '0; // Reset for next bit\n                    rx_state_next = RX_DATA;\n                    rx_bit_count = '0;\n                end else begin\n                    rx_baud_count = rx_baud_count + 1;\n                end\n            end\n\n            RX_DATA: begin\n                if (rx_baud_count == BAUD_DIVISOR_HALF - 1) begin // Sample in the middle of the data bit\n                    rx_data_shift_reg = {rx_sync_reg_2, rx_data_shift_reg[7:1]}; // Shift in new bit (MSB first)\n                end\n\n                if (rx_baud_count == BAUD_DIVISOR - 1) begin // End of data bit period\n                    rx_baud_count = '0; // Reset for next bit\n                    if (rx_bit_count == 7) begin // All 8 data bits received\n                        if (PARITY_EN) begin\n                            rx_state_next = RX_PARITY;\n                            // Calculate parity for received data\n                            logic parity_sum = 1'b0;\n                            for (int i = 0; i < 8; i++) begin\n                                parity_sum = parity_sum ^ rx_data_shift_reg[i];\n                            end\n                            rx_parity_calc = (PARITY_TYPE == 0) ? parity_sum : ~parity_sum; // Even or Odd\n                        end else begin\n                            rx_state_next = RX_STOP;\n                            rx_bit_count = '0; // Reset for stop bits\n                        end\n                    end else begin\n                        rx_bit_count = rx_bit_count + 1;\n                    end\n                end else begin\n                    rx_baud_count = rx_baud_count + 1;\n                end\n            end\n\n            RX_PARITY: begin\n                if (rx_baud_count == BAUD_DIVISOR_HALF - 1) begin // Sample parity bit\n                    if (PARITY_EN && (rx_sync_reg_2 != rx_parity_calc)) begin // Check only if parity is enabled\n                        rx_error_internal = 1'b1; // Parity error\n                    end\n                end\n\n                if (rx_baud_count == BAUD_DIVISOR - 1) begin // End of parity bit period\n                    rx_baud_count = '0;\n                    rx_state_next = RX_STOP;\n                    rx_bit_count = '0; // Reset for stop bits\n                end else begin\n                    rx_baud_count = rx_baud_count + 1;\n                end\n            end\n\n            RX_STOP: begin\n                if (rx_baud_count == BAUD_DIVISOR_HALF - 1) begin // Sample stop bit\n                    if (rx_sync_reg_2 == 1'b0) begin // Stop bit must be high, if low, it's a framing error\n                        rx_error_internal = 1'b1;\n                    end\n                end\n\n                if (rx_baud_count == BAUD_DIVISOR - 1) begin // End of stop bit period\n                    rx_baud_count = '0;\n                    if (rx_bit_count == STOP_BITS - 1) begin // All stop bits received\n                        rx_state_next = RX_IDLE;\n                        rx_data_valid = 1'b1; // Indicate new data is ready\n                    end else begin\n                        rx_bit_count = rx_bit_count + 1;\n                    end\n                end else begin\n                    rx_baud_count = rx_baud_count + 1;\n                end\n            end\n\n            default: begin\n                rx_state_next = RX_IDLE;\n            end\n        endcase\n    end\n\nendmodule\n\n```",
    "prompt_1": "Write a SystemVerilog module to implement a UART (Universal Asynchronous Receiver-Transmitter) controller. The module should support configurable baud rates, transmit and receive functionality, and proper start, data, parity (optional), and 2 stop bit handling. The UART should operate in full-duplex mode and adhere to the following interface:\nmodule UART_driver( input  logic       clk,        // System clock input  logic       rst,        // Asynchronous reset input  logic       UART_Start, // Signal to initiate transmission input  logic [8:0] data_in,    // Data to be transmitted input  logic       RX,         // UART receive line output logic       TX,         // UART transmit line output logic [8:0] data_out,   // Received data output logic       UART_Ready, // Ready to transmit next byte output logic       UART_Busy,  // Indicates UART is currently transmitting output logic       UART_Error  // High if framing or parity error detected ); ",
    "answer_1": "Here's a SystemVerilog module for a full-duplex UART controller, designed according to your specifications.\n\nThis module includes:\n*   **Configurable Parameters:** `SYS_CLK_FREQ`, `BAUD_RATE`, `DATA_BITS`, and `PARITY_EN`.\n*   **Transmit (TX) Functionality:** Handles start bit, data bits (LSB first), optional parity, and 2 stop bits.\n*   **Receive (RX) Functionality:** Detects start bit, samples data bits (LSB first), optional parity, and 2 stop bits. It uses 16x oversampling for robust reception and includes a synchronizer for the `RX` input.\n*   **Error Detection:** Flags `UART_Error` for framing errors (incorrect stop bits) or parity errors.\n*   **Full-Duplex Operation:** TX and RX operate independently.\n*   **Interface Adherence:** Implements all specified input and output signals.\n\n**Key Design Choices and Notes:**\n\n*   **Baud Rate Generation:** Separate counters are used for TX (1x baud rate) and RX (16x oversampling). The `BAUD_DIV_TX` and `BAUD_DIV_RX_16X` parameters are calculated using integer division, which might introduce a small, typically acceptable, baud rate error.\n*   **TX State Machine:** Manages the serial transmission process from idle to sending stop bits.\n*   **RX State Machine:** Manages the reception process, including start bit detection, data sampling, and error checking.\n*   **RX Synchronizer:** A two-flop synchronizer is used for the `RX` input to prevent metastability issues when crossing clock domains (from asynchronous UART line to synchronous system clock).\n*   **Data Bit Order:** Both TX and RX handle data in LSB-first order, which is standard for UART.\n*   **Parity:** Supports no parity (`PARITY_EN = 0`), even parity (`PARITY_EN = 1`), and odd parity (`PARITY_EN = 2`).\n*   **Stop Bits:** Fixed to 2 stop bits as per the requirement.\n*   **`UART_Ready` and `UART_Busy`:** These signals primarily reflect the TX status. `UART_Ready` is high when the transmitter is idle and ready for new data. `UART_Busy` is high when the transmitter is actively sending a frame.\n*   **`data_out` and `UART_Error`:** The `data_out` signal will hold the last successfully received byte. `UART_Error` will go high if the *last* received frame had a framing or parity error and will remain high until the RX line goes idle (high) or a new valid start bit is detected. There is no explicit `data_out_valid` signal in the provided interface, so the user must infer data validity by checking `UART_Error` or by knowing the timing of reception.\n\n\n```systemverilog\nmodule UART_driver #(\n    parameter SYS_CLK_FREQ  = 50_000_000, // System clock frequency in Hz (e.g., 50 MHz)\n    parameter BAUD_RATE     = 115200,     // Desired baud rate (e.g., 9600, 115200)\n    parameter DATA_BITS     = 8,          // Number of data bits (8 or 9)\n    parameter PARITY_EN     = 0           // 0: No parity, 1: Even parity, 2: Odd parity\n) (\n    input  logic       clk,        // System clock\n    input  logic       rst,        // Asynchronous reset (active high)\n    input  logic       UART_Start, // Signal to initiate transmission (rising edge triggered)\n    input  logic [8:0] data_in,    // Data to be transmitted (LSB at data_in[0])\n    input  logic       RX,         // UART receive line\n    output logic       TX,         // UART transmit line\n    output logic [8:0] data_out,   // Received data (LSB at data_out[0])\n    output logic       UART_Ready, // Ready to transmit next byte\n    output logic       UART_Busy,  // Indicates UART is currently transmitting\n    output logic       UART_Error  // High if framing or parity error detected\n);\n\n    // --- Internal Parameter Calculations ---\n    // Baud rate divisor for TX (1x clock)\n    localparam BAUD_DIV_TX = SYS_CLK_FREQ / BAUD_RATE;\n    // Baud rate divisor for RX (16x oversampling clock)\n    localparam BAUD_DIV_RX_16X = SYS_CLK_FREQ / (BAUD_RATE * 16);\n\n    // --- TX (Transmitter) Logic ---\n    typedef enum logic [2:0] {\n        TX_IDLE,\n        TX_START_BIT,\n        TX_DATA_BITS,\n        TX_PARITY_BIT,\n        TX_STOP_BITS\n    } tx_state_e;\n\n    tx_state_e tx_state, tx_next_state;\n    logic [clog2(BAUD_DIV_TX)-1:0] tx_baud_cnt; // Counter for 1x baud rate\n    logic                          tx_baud_tick; // Pulse at 1x baud rate\n    logic [DATA_BITS-1:0]          tx_data_reg;  // Shift register for data to transmit\n    logic [3:0]                    tx_bit_cnt;   // Counter for bits transmitted\n    logic                          tx_parity_bit; // Calculated parity bit\n    logic                          tx_busy_internal; // Internal TX busy signal\n\n    // UART_Start edge detection\n    logic tx_start_reg;\n    logic tx_start_pulse;\n\n    // TX Baud Rate Generator (1x clock)\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tx_baud_cnt  <= '0;\n            tx_baud_tick <= 1'b0;\n        end else begin\n            if (tx_baud_cnt == BAUD_DIV_TX - 1) begin\n                tx_baud_cnt  <= '0;\n                tx_baud_tick <= 1'b1;\n            end else begin\n                tx_baud_cnt  <= tx_baud_cnt + 1;\n                tx_baud_tick <= 1'b0;\n            end\n        end\n    end\n\n    // TX State Machine Registers\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tx_state         <= TX_IDLE;\n            TX               <= 1'b1; // TX line is high when idle\n            tx_data_reg      <= '0;\n            tx_bit_cnt       <= '0;\n            tx_parity_bit    <= 1'b0;\n            tx_busy_internal <= 1'b0;\n            tx_start_reg     <= 1'b0;\n        end else begin\n            tx_start_reg <= UART_Start; // Register UART_Start for edge detection\n            tx_start_pulse <= (UART_Start && !tx_start_reg); // Detect rising edge\n\n            tx_state <= tx_next_state;\n\n            case (tx_state)\n                TX_IDLE: begin\n                    TX               <= 1'b1; // Keep TX high\n                    tx_busy_internal <= 1'b0; // Not busy\n                    tx_bit_cnt       <= '0;\n                    if (tx_start_pulse) begin\n                        tx_data_reg      <= data_in[DATA_BITS-1:0]; // Load data\n                        // Calculate parity if enabled\n                        if (PARITY_EN != 0) begin\n                            logic parity_calc;\n                            parity_calc = ^data_in[DATA_BITS-1:0]; // XOR all data bits\n                            if (PARITY_EN == 1) tx_parity_bit = parity_calc; // Even parity\n                            else if (PARITY_EN == 2) tx_parity_bit = !parity_calc; // Odd parity\n                        end else begin\n                            tx_parity_bit = 1'b0; // Not used\n                        end\n                        tx_busy_internal <= 1'b1; // Start transmission\n                    end\n                end\n                TX_START_BIT: begin\n                    TX <= 1'b0; // Start bit is low\n                    if (tx_baud_tick) begin\n                        tx_bit_cnt <= '0; // Reset bit counter for data bits\n                    end\n                end\n                TX_DATA_BITS: begin\n                    TX <= tx_data_reg[0]; // Send LSB first\n                    if (tx_baud_tick) begin\n                        tx_data_reg <= tx_data_reg >> 1; // Shift data right\n                        tx_bit_cnt  <= tx_bit_cnt + 1;\n                    end\n                end\n                TX_PARITY_BIT: begin\n                    TX <= tx_parity_bit;\n                    // No shift, just wait for tick to move to next state\n                end\n                TX_STOP_BITS: begin\n                    TX <= 1'b1; // Stop bits are high\n                    if (tx_baud_tick) begin\n                        tx_bit_cnt <= tx_bit_cnt + 1;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // TX Next State Logic\n    always_comb begin\n        tx_next_state = tx_state;\n        case (tx_state)\n            TX_IDLE: begin\n                if (tx_start_pulse) begin\n                    tx_next_state = TX_START_BIT;\n                end\n            end\n            TX_START_BIT: begin\n                if (tx_baud_tick) begin\n                    tx_next_state = TX_DATA_BITS;\n                end\n            end\n            TX_DATA_BITS: begin\n                if (tx_baud_tick) begin\n                    if (tx_bit_cnt == DATA_BITS - 1) begin\n                        if (PARITY_EN != 0) tx_next_state = TX_PARITY_BIT;\n                        else                tx_next_state = TX_STOP_BITS;\n                    end\n                end\n            end\n            TX_PARITY_BIT: begin\n                if (tx_baud_tick) begin\n                    tx_next_state = TX_STOP_BITS;\n                end\n            end\n            TX_STOP_BITS: begin\n                if (tx_baud_tick) begin\n                    if (tx_bit_cnt == 2 - 1) begin // Always 2 stop bits\n                        tx_next_state = TX_IDLE;\n                    end\n                end\n            end\n        endcase\n    end\n\n    // --- RX (Receiver) Logic ---\n    typedef enum logic [3:0] {\n        RX_IDLE,\n        RX_START_BIT_DETECT, // Wait for falling edge on RX\n        RX_START_BIT_SAMPLE, // Sample middle of start bit\n        RX_DATA_BITS,\n        RX_PARITY_BIT,\n        RX_STOP_BITS_1,      // Sample first stop bit\n        RX_STOP_BITS_2,      // Sample second stop bit\n        RX_ERROR_STATE       // Hold error state\n    } rx_state_e;\n\n    rx_state_e rx_state, rx_next_state;\n    logic [clog2(BAUD_DIV_RX_16X)-1:0] rx_sample_cnt; // Counter for 16x samples within a bit\n    logic                              rx_bit_tick;   // Pulse at the middle of each bit for sampling\n    logic [DATA_BITS-1:0]              rx_data_reg;   // Shift register for received data\n    logic [3:0]                        rx_bit_cnt;    // Counter for bits received\n    logic                              rx_parity_bit_expected; // Expected parity bit\n    logic                              rx_error_internal; // Internal RX error signal\n\n    // RX Input Synchronizer (2-flop synchronizer)\n    logic RX_sync_0, RX_sync_1;\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            RX_sync_0 <= 1'b1;\n            RX_sync_1 <= 1'b1;\n        end else begin\n            RX_sync_0 <= RX;\n            RX_sync_1 <= RX_sync_0;\n        end\n    end\n\n    // RX Sample Counter and Bit Tick Generator\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_sample_cnt <= '0;\n            rx_bit_tick   <= 1'b0;\n        end else begin\n            rx_bit_tick <= 1'b0; // Default to low\n\n            case (rx_state)\n                RX_IDLE: begin\n                    rx_sample_cnt <= '0; // Reset counter\n                end\n                RX_START_BIT_DETECT: begin\n                    // If RX_sync_1 goes low, reset counter to start timing for sample\n                    if (!RX_sync_1) begin\n                        rx_sample_cnt <= '0;\n                    end else begin\n                        rx_sample_cnt <= '0; // Stay reset if RX is high\n                    end\n                end\n                RX_START_BIT_SAMPLE, RX_DATA_BITS, RX_PARITY_BIT, RX_STOP_BITS_1, RX_STOP_BITS_2: begin\n                    if (rx_sample_cnt == BAUD_DIV_RX_16X - 1) begin\n                        rx_sample_cnt <= '0;\n                    end else begin\n                        rx_sample_cnt <= rx_sample_cnt + 1;\n                    end\n                    // Generate rx_bit_tick at the middle of the bit for sampling\n                    if (rx_sample_cnt == (BAUD_DIV_RX_16X / 2) - 1) begin\n                        rx_bit_tick <= 1'b1; // This is the actual sample point\n                    end\n                end\n                default: begin\n                    rx_sample_cnt <= '0;\n                end\n            endcase\n        end\n    end\n\n    // RX State Machine Registers\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_state          <= RX_IDLE;\n            data_out          <= '0;\n            rx_data_reg       <= '0;\n            rx_bit_cnt        <= '0;\n            rx_error_internal <= 1'b0;\n        end else begin\n            rx_state <= rx_next_state;\n\n            case (rx_state)\n                RX_IDLE: begin\n                    rx_error_internal <= 1'b0; // Clear error when idle\n                    rx_bit_cnt        <= '0;\n                    rx_data_reg       <= '0;\n                end\n                RX_START_BIT_DETECT: begin\n                    // State to detect falling edge and prepare for sampling\n                end\n                RX_START_BIT_SAMPLE: begin\n                    if (rx_bit_tick) begin // Sample at middle of start bit\n                        if (RX_sync_1 == 1'b0) begin // Valid start bit (still low)\n                            rx_bit_cnt <= '0; // Reset bit counter for data bits\n                        end else begin // Not low, error or glitch\n                            rx_error_internal <= 1'b1; // Framing error\n                        end\n                    end\n                end\n                RX_DATA_BITS: begin\n                    if (rx_bit_tick) begin // Sample at middle of data bit\n                        // Shift in new bit (LSB first into rx_data_reg[0])\n                        rx_data_reg <= {rx_data_reg[DATA_BITS-2:0], RX_sync_1};\n                        rx_bit_cnt  <= rx_bit_cnt + 1;\n                    end\n                end\n                RX_PARITY_BIT: begin\n                    if (rx_bit_tick) begin // Sample at middle of parity bit\n                        logic parity_calc;\n                        parity_calc = ^rx_data_reg; // XOR all received data bits\n                        if (PARITY_EN == 1) rx_parity_bit_expected = parity_calc; // Even parity\n                        else if (PARITY_EN == 2) rx_parity_bit_expected = !parity_calc; // Odd parity\n                        // If PARITY_EN is 0, this state is skipped, so no need for 'else'\n                        \n                        if (PARITY_EN != 0 && RX_sync_1 != rx_parity_bit_expected) begin\n                            rx_error_internal <= 1'b1; // Parity error\n                        end\n                    end\n                end\n                RX_STOP_BITS_1: begin\n                    if (rx_bit_tick) begin // Sample at middle of first stop bit\n                        if (RX_sync_1 == 1'b1) begin // Stop bit must be high\n                            // OK\n                        end else begin\n                            rx_error_internal <= 1'b1; // Framing error\n                        end\n                    end\n                end\n                RX_STOP_BITS_2: begin\n                    if (rx_bit_tick) begin // Sample at middle of second stop bit\n                        if (RX_sync_1 == 1'b1) begin // Stop bit must be high\n                            // OK\n                        end else begin\n                            rx_error_internal <= 1'b1; // Framing error\n                        end\n                        // Data is ready after the last stop bit is sampled, if no error\n                        if (!rx_error_internal) begin\n                            data_out <= rx_data_reg; // Assign received data\n                        end\n                    end\n                end\n                RX_ERROR_STATE: begin\n                    // Stay in error state until RX line goes high (idle)\n                end\n            endcase\n        end\n    end\n\n    // RX Next State Logic\n    always_comb begin\n        rx_next_state = rx_state;\n        case (rx_state)\n            RX_IDLE: begin\n                if (!RX_sync_1) begin // Detect falling edge (RX_sync_1 was high, now low)\n                    rx_next_state = RX_START_BIT_DETECT; // Go to state to wait for sample point\n                end\n            end\n            RX_START_BIT_DETECT: begin\n                // Wait for the sample counter to reach the middle of the start bit\n                if (rx_sample_cnt == (BAUD_DIV_RX_16X / 2) - 1) begin\n                    rx_next_state = RX_START_BIT_SAMPLE;\n                end\n            end\n            RX_START_BIT_SAMPLE: begin\n                if (rx_bit_tick) begin // Sampled middle of start bit\n                    if (RX_sync_1 == 1'b0) begin // Still low, valid start bit\n                        rx_next_state = RX_DATA_BITS;\n                    end else begin // Not low, error or glitch\n                        rx_next_state = RX_ERROR_STATE; // Go to error state\n                    end\n                end\n            end\n            RX_DATA_BITS: begin\n                if (rx_bit_tick) begin\n                    if (rx_bit_cnt == DATA_BITS - 1) begin\n                        if (PARITY_EN != 0) rx_next_state = RX_PARITY_BIT;\n                        else                rx_next_state = RX_STOP_BITS_1;\n                    end\n                end\n            end\n            RX_PARITY_BIT: begin\n                if (rx_bit_tick) begin\n                    rx_next_state = RX_STOP_BITS_1;\n                end\n            end\n            RX_STOP_BITS_1: begin\n                if (rx_bit_tick) begin\n                    rx_next_state = RX_STOP_BITS_2;\n                end\n            end\n            RX_STOP_BITS_2: begin\n                if (rx_bit_tick) begin\n                    if (rx_error_internal) begin // If error occurred during reception\n                        rx_next_state = RX_ERROR_STATE;\n                    end else begin\n                        rx_next_state = RX_IDLE; // Go back to idle\n                    end\n                end\n            end\n            RX_ERROR_STATE: begin\n                // Stay in error state until RX goes high (idle)\n                if (RX_sync_1 == 1'b1) begin // Line is idle\n                    rx_next_state = RX_IDLE;\n                end\n            end\n        endcase\n    end\n\n    // --- Output Assignments ---\n    assign UART_Busy  = tx_busy_internal;\n    assign UART_Ready = !tx_busy_internal;\n    assign UART_Error = rx_error_internal;\n\nendmodule\n```"
}
