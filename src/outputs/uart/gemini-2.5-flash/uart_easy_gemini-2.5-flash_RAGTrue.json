{
    "prompt_0": "protocol and the second tests the binary protocol. The test bench uses a register file model to simulate write and read operations. The following table summarizes the synthesis results of the core for different FPGA families. ManufacturerFamilyDevice Device UtilizationElements UtilizationFmax XilinxSpartan 3xc3s50-5pq208 24.00%186 Slices>150MHz XilinxVirtex 5xc5vlx30-3ff324 2.00%111 Slices>200MHz AlteraCyclone IIIep3c5f256c6 5.00%255 LEs>200MHz AlteraStartix IIIep3sl50f484c2 <1%167 Registers 218 ALUTs>200MHz Lattice1MachXOLCMXO2280C- 4T144C10.00%116 Slices> 100MHz Table 1: Synthesis Results for Different FPGA Devices The above results where obtained using the following software versions: \u2022Xilinx ISE Webpack 11.4 \u2022Altera Quartus Web Edition 9.1sp2 NOTE: The UART to Bus core is not Wishbone compatible although modifying it for Wishbone is probably possible. 1Lattice device synthesis results provided by Paul V. Shatov. Results provided before adding bus request/grant mechanism. UART to Bus Core Specifications Page 4 of 10 February 25, 2012 3.Architecture The UART to Bus architecture is fairly simple. The core is includes a UART interface module, which includes both receive and transmit modules, and the command parser. The following figure depicts a block diagram of the core. Figure 1: UART to Bus Core Block Diagram The UART interface is based on an implementation found in the c16 project in OpenCores (http://www.opencores.org/project,c16 ). The interface includes a UART receive and transmit modules that share a single baud rate generator module. The baud rate is set using two constants defined at the core top module which are calculated as follows: D_BAUD_FREQ=16\u22c5BaudRate gcd\ue09eGlobalClockFreq,16\u2217BaudRate\ue09f D_BAUD_LIMIT=GlobalClockFreq gcd\ue09eGlobalClockFreq,16\u22c5BaudRate\ue09f\u2212D_BAUD_FREQ A short Scilab script which calculates the above parameters is added under the \u201cscilab\u201d directory with the core files. The interface between the \u201cuart_parser.v\u201d module and the \u201cuart_top.v\u201d is very simple and uses only five signals. For cases where the UART interface is not possible or another interface is preferred, the \u201cuart_parser.v\u201d module can be used as is with a different interface implementation. UART to Bus Core Specifications Page 5 of 10 uart_tx.v uart_rx.v baud_gen.vuart_top.v uart_parser.vuart2bus_top.v ser_out ser_inint_address int_wr_data16 8 int_write int_read int_rd_data 8 clock resetint_req int_gntFebruary 25, 2012 4.Operation This section describes the protocols used to access the internal bus from the UART interface. As mentioned above the parser supports two modes of operation: text & binary commands. To distinguish between the two protocols all binary commands start with a value of zero which will not be sent when using the text protocol. The following drawing depicts a simplified state machine of the parser. The figure does not include some transitions used to abort illegal command sequences. Figure 2: Parser State Diagram In the state diagram above the states on the right are used for the text mode protocol and the states on the left are used for the binary mode protocol. The following sub-sections describe each of the protocols. 4.1.Text Mode Protocol The text mode protocol includes only two commands: address read and address write. All values are in HEX format. The parser checks for both upper and lower characters, detects both space (0x20) and tab (0x09) as white spaces and both LF (0x0A) and CR (0x0D) as end of\nUART to Bus Core Specifications Written for publication on: File name: UART to Bus Core Specifications Version: 1.0 Creation Date: February 12, 2010 Update Date: February 25, 2012 Author: Moti Litochevski February 25, 2012 Table of Contents 1. Preface.............................................................................................................................................. 3 1.1. Scope........................................................................................................................................ 3 1.2. Revision History ....................................................................................................................... 3 1.3. Abbreviations........................................................................................................................... 3 2. Introduction...................................................................................................................................... 4 3. Architecture...................................................................................................................................... 5 4. Operation.......................................................................................................................................... 6 4.1. Text Mode Protocol .................................................................................................................. 6 4.2. Binary Mode Protocol .............................................................................................................. 7 5. Core Interfaces................................................................................................................................. 9 6. Test Bench Description .................................................................................................................. 10 Index of Tables Table 1: Synthesis Results for Different FPGA Devices ..................................................................... 4 Table 2: Text Protocol Read Command Format .................................................................................. 7 Table 3: Text Protocol Write Command Format ................................................................................. 7 Table 4: Binary Protocol Command Format ........................................................................................ 8 Table 5: Binary Protocol Return Message Format .............................................................................. 8 Table 6: Core Interfaces Description ................................................................................................... 9 Index of Figures Figure 1: UART to Bus Core Block Diagram ..................................................................................... 5 Figure 2: Parser State Diagram ............................................................................................................ 6 UART to Bus Core Specifications Page 2 of 10 February 25, 2012 1.Preface 1.1.Scope This document describes the UART to Bus IP core operation, architecture and interfaces. 1.2.Revision History RevDateAuthor Description 0.102/13/10Moti Litochevski First Draft 0.204/02/10Moti Litochevski Adding test bench description section 0.304/15/11Moti Litochevski Added Lattice MachXO device utilization provided by Paul V. Shatov. 1.002/25/12Moti Litochevski Updated interface description and synthesis results after adding bus request/grant mechanism. 1.3.Abbreviations UARTUniversal Asynchronous Receiver / Transmitter UART to Bus Core Specifications Page 3 of 10 February 25, 2012 2.Introduction The UART to Bus IP Core is a simple command parser that can be used to access an internal bus via a UART interface. This core can be used during initial board debugging or as a permanent solution when high speed interfaces are not required. The internal bus is designed with address bus of 16 bits and data bus of 8 bits. The core implements a very basic UART transmit & receive blocks which share a common baud rate generator and a command parser. The parser supports two modes of operation: text mode commands and binary mode commands. Text mode commands are designed to be used with a hyper terminal software and enable easy access to the internal bus. Binary mode commands are more efficient and also support buffered read & write operations with or without automatic address increment. The core was verified using Icarus Verilog simulator with two test benches: the first tests the text mode protocol and the second tests the binary protocol. The test bench uses a register file model to simulate write and read operations. The following table summarizes the synthesis results of the core for different FPGA families. ManufacturerFamilyDevice Device UtilizationElements UtilizationFmax XilinxSpartan 3xc3s50-5pq208 24.00%186 Slices>150MHz XilinxVirtex 5xc5vlx30-3ff324 2.00%111 Slices>200MHz AlteraCyclone IIIep3c5f256c6 5.00%255 LEs>200MHz AlteraStartix IIIep3sl50f484c2 <1%167 Registers 218 ALUTs>200MHz Lattice1MachXOLCMXO2280C- 4T144C10.00%116 Slices> 100MHz Table 1: Synthesis Results for Different FPGA Devices The above results where obtained using the following software versions: \u2022Xilinx ISE Webpack 11.4 \u2022Altera Quartus Web Edition 9.1sp2 NOTE: The UART to Bus core is not Wishbone compatible although\nbe written to. int_readoutput1An active high read control signal. This signal shall only be valid for a single clock cycle per address to be read from. int_rd_datainput8Data value read from address. This signal is sampled by the core on the next clock cycle following int_read signal active cycle. int_reqoutput1Internal bus access request signal. The core will assert this signal to request access to the internal bus before every bus access. This signal will be asserted until bus access is granted. int_gntinput1Internal bus grant signal. The core will release the request signal and execute the bus access when this signal is asserted. To disable bus request/grant mechanism set this to logic '1'. Table 6: Core Interfaces Description Note: The port direction in the table above is as defined in the core top module. UART to Bus Core Specifications Page 9 of 10 February 25, 2012 6.Test Bench Description The 'verilog\\bench' directory contains two test benches files and required tasks and modules. Compilation batch files are included in the 'verilog\\sim\\icarus' directory used to simulate the core using Icarus Verilog. The directory inclues two compilation batch files: one for binary mode protocol simulation and the second for text mode protocol simulation. The directory also includes batch file to run the simulation, 'run.bat', and another to call gtkwave to view the simulation VCD output file. Note that for binary mode protocol simulation the test bench reads the commands from 'test.bin' file also included in the directory. The file structure is straight forward and is explained in the respective test bench file. UART to Bus Core Specifications Page 10 of 10\nWrite a SystemVerilog module to implement a UART (Universal Asynchronous Receiver-Transmitter) controller. The module should support configurable baud rates, transmit and receive functionality, and proper start, data, parity (optional), and stop bit handling. The UART should operate in full-duplex mode and adhere to the following interface:\nmodule UART_driver( input  logic       clk,        // System clock input  logic       rst,        // Asynchronous reset input  logic       UART_Start, // Signal to initiate transmission input  logic [7:0] data_in,    // Data to be transmitted input  logic       RX,         // UART receive line output logic       TX,         // UART transmit line output logic [7:0] data_out,   // Received data output logic       UART_Ready, // Ready to transmit next byte output logic       UART_Busy,  // Indicates UART is currently transmitting output logic       UART_Error  // High if framing or parity error detected ); ",
    "answer_0": "import math\n\nCLK_FREQ = 50_000_000\nBAUD_RATE = 9600\nBAUD_RATE_DIVISOR = CLK_FREQ / (BAUD_RATE * 16)\nprint(f'{BAUD_RATE_DIVISOR=}')\n\nBAUD_RATE_DIVISOR=325.5208333333333\n\nimport math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nCLK_FREQ = 50_000_000\nBAUD_RATE = 9600\n\nN = 16 * BAUD_RATE\nG = gcd(CLK_FREQ, N)\n\nD_BAUD_FREQ = N // G\nD_BAUD_LIMIT = CLK_FREQ // G - D_BAUD_FREQ\n\nprint(f'{N=}')\nprint(f'{G=}')\nprint(f'{D_BAUD_FREQ=}')\nprint(f'{D_BAUD_LIMIT=}')\n\nN=153600\nG=3200\nD_BAUD_FREQ=48\nD_BAUD_LIMIT=15577\n\nTo implement the UART (Universal Asynchronous Receiver-Transmitter) controller in SystemVerilog, we need to consider the following key components:\n\n1.  **Baud Rate Generator:** This module generates a clock tick at 16 times the desired baud rate. The provided document gives specific formulas for `D_BAUD_FREQ` and `D_BAUD_LIMIT` which are used for a fractional baud rate generator, ensuring higher accuracy.\n2.  **Transmit (TX) Module:** This state machine handles sending data. It sequences through start bit, data bits (LSB first), optional parity bit, and stop bit(s). It manages the `TX` line, `UART_Start` input, `data_in`, `UART_Ready`, and `UART_Busy` outputs.\n3.  **Receive (RX) Module:** This state machine handles receiving data. It detects the start bit, samples data bits (LSB first) in the middle of each bit period, checks for optional parity, and verifies the stop bit(s). It manages the `RX` input, `data_out`, and `UART_Error` outputs. Input synchronization for `RX` is crucial to prevent metastability.\n\nThe module will be parameterized to allow configuration of clock frequency, baud rate, data bits, stop bits, and parity settings.\n\n### Baud Rate Calculation\n\nThe provided formulas for the fractional baud rate generator are:\n*   `D_BAUD_FREQ = (16 * BaudRate) / gcd(GlobalClockFreq, 16 * BaudRate)`\n*   `D_BAUD_LIMIT = GlobalClockFreq / gcd(GlobalClockFreq, 16 * BaudRate) - D_BAUD_FREQ`\n\nLet's calculate these values for an example: `GlobalClockFreq = 50_000_000 Hz` and `BaudRate = 9600`.\n\n\nimport math\n\ndef gcd(a, b):\n    while b:\n        a, b = b, a % b\n    return a\n\nCLK_FREQ = 50_000_000\nBAUD_RATE = 9600\n\nN = 16 * BAUD_RATE\nG = gcd(CLK_FREQ, N)\n\nD_BAUD_FREQ = N // G\nD_BAUD_LIMIT = CLK_FREQ // G - D_BAUD_FREQ\n\nprint(f'N (16 * BaudRate) = {N}')\nprint(f'G (GCD) = {G}')\nprint(f'D_BAUD_FREQ = {D_BAUD_FREQ}')\nprint(f'D_BAUD_LIMIT = {D_BAUD_LIMIT}')\n\nN (16 * BaudRate) = 153600\nG (GCD) = 3200\nD_BAUD_FREQ = 48\nD_BAUD_LIMIT = 15577\n\n**Findings:**\nFor `CLK_FREQ = 50_000_000` and `BAUD_RATE = 9600`, the parameters for the fractional baud rate generator are:\n*   `D_BAUD_FREQ = 48`\n*   `D_BAUD_LIMIT = 15577`\n\nThese values will be used in the SystemVerilog module to generate the `baud_tick_16x` signal.\n\n### SystemVerilog Module Implementation\n\nThe `UART_driver` module will include the baud rate generator, TX state machine, and RX state machine.\n\n\n```systemverilog\nmodule UART_driver #(\n    parameter CLK_FREQ    = 50_000_000, // System clock frequency in Hz\n    parameter BAUD_RATE   = 9600,       // Desired baud rate\n    parameter DATA_BITS   = 8,          // Number of data bits (7 or 8)\n    parameter STOP_BITS   = 1,          // Number of stop bits (1 or 2)\n    parameter PARITY_EN   = 0,          // 0: No parity, 1: Parity enabled\n    parameter PARITY_TYPE = 0           // 0: Even parity, 1: Odd parity (if PARITY_EN=1)\n) (\n    input  logic       clk,        // System clock\n    input  logic       rst,        // Asynchronous reset\n\n    // Transmit Interface\n    input  logic       UART_Start, // Signal to initiate transmission\n    input  logic [7:0] data_in,    // Data to be transmitted\n    output logic       TX,         // UART transmit line\n    output logic       UART_Ready, // Ready to transmit next byte\n    output logic       UART_Busy,  // Indicates UART is currently transmitting\n\n    // Receive Interface\n    input  logic       RX,         // UART receive line\n    output logic [7:0] data_out,   // Received data\n    output logic       UART_Error  // High if framing or parity error detected\n);\n\n    // Function for GCD (Greatest Common Divisor)\n    // Used for calculating fractional baud rate generator parameters\n    function automatic int gcd(int a, int b);\n        while (b != 0) begin\n            int temp = b;\n            b = a % b;\n            a = temp;\n        end\n        return a;\n    endfunction\n\n    // Internal parameters for baud rate generation based on provided formulas\n    // D_BAUD_FREQ = 16 * BaudRate / gcd(GlobalClockFreq, 16 * BaudRate)\n    // D_BAUD_LIMIT = GlobalClockFreq / gcd(GlobalClockFreq, 16 * BaudRate) - D_BAUD_FREQ\n    localparam int N_VAL = 16 * BAUD_RATE;\n    localparam int G_VAL = gcd(CLK_FREQ, N_VAL);\n    localparam int D_BAUD_FREQ_VAL = N_VAL / G_VAL;\n    localparam int D_BAUD_LIMIT_VAL = CLK_FREQ / G_VAL - D_BAUD_FREQ_VAL;\n\n    // Baud Rate Generator\n    // This counter increments by D_BAUD_FREQ_VAL each clock cycle.\n    // When it reaches or exceeds D_BAUD_LIMIT_VAL, a baud_tick_16x is generated,\n    // and D_BAUD_LIMIT_VAL is subtracted from the counter.\n    logic [31:0] baud_cnt;\n    logic        baud_tick_16x; // Pulse at 16x the baud rate\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            baud_cnt <= 0;\n            baud_tick_16x <= 0;\n        end else begin\n            baud_cnt <= baud_cnt + D_BAUD_FREQ_VAL;\n            if (baud_cnt >= D_BAUD_LIMIT_VAL) begin\n                baud_cnt <= baud_cnt - D_BAUD_LIMIT_VAL;\n                baud_tick_16x <= 1;\n            end else begin\n                baud_tick_16x <= 0;\n            end\n        end\n    end\n\n    // TX Module\n    typedef enum logic [2:0] {\n        TX_IDLE,       // Ready to transmit, TX high\n        TX_START,      // Transmitting start bit (low)\n        TX_DATA,       // Transmitting data bits (LSB first)\n        TX_PARITY,     // Transmitting parity bit (optional)\n        TX_STOP        // Transmitting stop bit(s) (high)\n    } tx_state_e;\n\n    tx_state_e tx_state;\n    logic [7:0] tx_shift_reg;   // Holds data to be transmitted\n    logic [3:0] tx_bit_cnt;     // Counts bits transmitted (0 to DATA_BITS-1)\n    logic [3:0] tx_baud_tick_cnt; // Counts 16x baud ticks within a bit period\n\n    logic tx_busy_internal;\n    logic tx_ready_internal;\n    logic tx_out_reg; // Register for the TX line output\n\n    assign UART_Busy  = tx_busy_internal;\n    assign UART_Ready = tx_ready_internal;\n    assign TX         = tx_out_reg;\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tx_state         <= TX_IDLE;\n            tx_shift_reg     <= 8'h00;\n            tx_bit_cnt       <= 0;\n            tx_baud_tick_cnt <= 0;\n            tx_busy_internal <= 0;\n            tx_ready_internal <= 1;\n            tx_out_reg       <= 1'b1; // TX line is high when idle\n        end else begin\n            // Default to not ready, will be set high in TX_IDLE\n            tx_ready_internal <= 0; \n\n            if (baud_tick_16x) begin\n                tx_baud_tick_cnt <= tx_baud_tick_cnt + 1;\n            end\n\n            case (tx_state)\n                TX_IDLE: begin\n                    tx_out_reg       <= 1'b1; // Ensure TX is high\n                    tx_ready_internal <= 1;   // Ready to accept new data\n                    tx_busy_internal <= 0;\n                    tx_baud_tick_cnt <= 0;     // Reset baud tick counter\n                    if (UART_Start && tx_ready_internal) begin // Start transmission if requested and ready\n                        tx_shift_reg     <= data_in;\n                        tx_state         <= TX_START;\n                        tx_out_reg       <= 1'b0; // Transmit start bit (low)\n                        tx_busy_internal <= 1;\n                        tx_baud_tick_cnt <= 0; // Start counting for the start bit\n                    end\n                end\n                TX_START: begin\n                    if (tx_baud_tick_cnt == 16) begin // After 16 ticks (1 bit period)\n                        tx_state         <= TX_DATA;\n                        tx_bit_cnt       <= 0;\n                        tx_baud_tick_cnt <= 0;\n                        tx_out_reg       <= tx_shift_reg[0]; // Transmit first data bit (LSB)\n                        tx_shift_reg     <= tx_shift_reg >> 1; // Shift right for next bit\n                    end\n                end\n                TX_DATA: begin\n                    if (tx_baud_tick_cnt == 16) begin // After 16 ticks (1 bit period)\n                        tx_baud_tick_cnt <= 0;\n                        tx_bit_cnt       <= tx_bit_cnt + 1;\n                        if (tx_bit_cnt == DATA_BITS - 1) begin // Check if last data bit was just transmitted\n                            if (PARITY_EN) begin\n                                tx_state <= TX_PARITY;\n                                // Calculate parity: Even (XOR sum) or Odd (NOT XOR sum)\n                                tx_out_reg <= (PARITY_TYPE == 0) ? ^tx_shift_reg : !^tx_shift_reg;\n                            end else begin\n                                tx_state <= TX_STOP;\n                                tx_out_reg <= 1'b1; // Transmit stop bit (high)\n                            end\n                        end else begin\n                            tx_out_reg   <= tx_shift_reg[0]; // Transmit next data bit\n                            tx_shift_reg <= tx_shift_reg >> 1;\n                        end\n                    end\n                end\n                TX_PARITY: begin\n                    if (tx_baud_tick_cnt == 16) begin // After 16 ticks (1 bit period)\n                        tx_baud_tick_cnt <= 0;\n                        tx_state         <= TX_STOP;\n                        tx_out_reg       <= 1'b1; // Transmit stop bit (high)\n                    end\n                end\n                TX_STOP: begin\n                    // Wait for STOP_BITS periods\n                    if (tx_baud_tick_cnt == (STOP_BITS * 16)) begin\n                        tx_state         <= TX_IDLE;\n                        tx_busy_internal <= 0;\n                        tx_ready_internal <= 1; // Ready for next transmission\n                    end\n                end\n            endcase\n        end\n    end\n\n    // RX Module\n    typedef enum logic [2:0] {\n        RX_IDLE,         // Waiting for start bit\n        RX_START_DETECT, // Detecting start bit and waiting for middle of bit\n        RX_DATA,         // Receiving data bits\n        RX_PARITY,       // Receiving parity bit (optional)\n        RX_STOP          // Receiving stop bit(s)\n    } rx_state_e;\n\n    rx_state_e rx_state;\n    logic [7:0] rx_shift_reg;   // Accumulates received data (LSB first)\n    logic [3:0] rx_bit_cnt;     // Counts received bits\n    logic [3:0] rx_baud_tick_cnt; // Counts 16x baud ticks within a bit period\n    logic       rx_error_internal; // Internal error flag for framing or parity\n\n    assign data_out   = rx_shift_reg;\n    assign UART_Error = rx_error_internal;\n\n    // Synchronize RX input to system clock domain to prevent metastability\n    logic rx_sync_q1, rx_sync_q2;\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_sync_q1 <= 1'b1;\n            rx_sync_q2 <= 1'b1;\n        end else begin\n            rx_sync_q1 <= RX;\n            rx_sync_q2 <= rx_sync_q1;\n        end\n    end\n    logic rx_synced;\n    assign rx_synced = rx_sync_q2; // Stable synchronized RX input\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_state         <= RX_IDLE;\n            rx_shift_reg     <= 8'h00;\n            rx_bit_cnt       <= 0;\n            rx_baud_tick_cnt <= 0;\n            rx_error_internal <= 0;\n        end else begin\n            if (baud_tick_16x) begin\n                rx_baud_tick_cnt <= rx_baud_tick_cnt + 1;\n            end\n\n            case (rx_state)\n                RX_IDLE: begin\n                    rx_error_internal <= 0; // Clear error flag\n                    rx_baud_tick_cnt <= 0;   // Reset baud tick counter\n                    if (!rx_synced) begin // Detect falling edge (start bit)\n                        rx_state         <= RX_START_DETECT;\n                        rx_baud_tick_cnt <= 0; // Start counting for the start bit\n                    end\n                end\n                RX_START_DETECT: begin\n                    if (rx_baud_tick_cnt == 8) begin // Sample in the middle of the start bit\n                        if (!rx_synced) begin // Still low, valid start bit\n                            rx_state         <= RX_DATA;\n                            rx_bit_cnt       <= 0;\n                            rx_baud_tick_cnt <= 0; // Reset for data bits\n                        end else begin // Glitch or false start, go back to idle\n                            rx_state <= RX_IDLE;\n                        end\n                    end\n                end\n                RX_DATA: begin\n                    if (rx_baud_tick_cnt == 16) begin // Sample at the middle of each data bit\n                        rx_baud_tick_cnt <= 0;\n                        // Shift in LSB first: new bit goes to rx_shift_reg[0], existing bits shift left\n                        rx_shift_reg     <= {rx_shift_reg[6:0], rx_synced}; \n                        rx_bit_cnt       <= rx_bit_cnt + 1;\n                        if (rx_bit_cnt == DATA_BITS - 1) begin // Check if last data bit was just received\n                            if (PARITY_EN) begin\n                                rx_state <= RX_PARITY;\n                            end else begin\n                                rx_state <= RX_STOP;\n                            end\n                        end\n                    end\n                end\n                RX_PARITY: begin\n                    if (rx_baud_tick_cnt == 16) begin // Sample at the middle of the parity bit\n                        rx_baud_tick_cnt <= 0;\n                        rx_state         <= RX_STOP;\n                        // Check parity: Even (XOR sum) or Odd (NOT XOR sum)\n                        logic calculated_parity;\n                        calculated_parity = (PARITY_TYPE == 0) ? ^rx_shift_reg : !^rx_shift_reg;\n                        if (calculated_parity != rx_synced) begin\n                            rx_error_internal <= 1; // Parity error detected\n                        end\n                    end\n                end\n                RX_STOP: begin\n                    // Wait for STOP_BITS periods, sample at the middle of the last stop bit\n                    if (rx_baud_tick_cnt == (STOP_BITS * 16)) begin\n                        rx_baud_tick_cnt <= 0;\n                        if (!rx_synced) begin // Stop bit should be high, if low, it's a framing error\n                            rx_error_internal <= 1; // Framing error detected\n                        end\n                        rx_state <= RX_IDLE; // Return to idle, ready for next byte\n                    end\n                end\n            endcase\n        end\n    end\n\nendmodule\n```",
    "prompt_1": "protocol and the second tests the binary protocol. The test bench uses a register file model to simulate write and read operations. The following table summarizes the synthesis results of the core for different FPGA families. ManufacturerFamilyDevice Device UtilizationElements UtilizationFmax XilinxSpartan 3xc3s50-5pq208 24.00%186 Slices>150MHz XilinxVirtex 5xc5vlx30-3ff324 2.00%111 Slices>200MHz AlteraCyclone IIIep3c5f256c6 5.00%255 LEs>200MHz AlteraStartix IIIep3sl50f484c2 <1%167 Registers 218 ALUTs>200MHz Lattice1MachXOLCMXO2280C- 4T144C10.00%116 Slices> 100MHz Table 1: Synthesis Results for Different FPGA Devices The above results where obtained using the following software versions: \u2022Xilinx ISE Webpack 11.4 \u2022Altera Quartus Web Edition 9.1sp2 NOTE: The UART to Bus core is not Wishbone compatible although modifying it for Wishbone is probably possible. 1Lattice device synthesis results provided by Paul V. Shatov. Results provided before adding bus request/grant mechanism. UART to Bus Core Specifications Page 4 of 10 February 25, 2012 3.Architecture The UART to Bus architecture is fairly simple. The core is includes a UART interface module, which includes both receive and transmit modules, and the command parser. The following figure depicts a block diagram of the core. Figure 1: UART to Bus Core Block Diagram The UART interface is based on an implementation found in the c16 project in OpenCores (http://www.opencores.org/project,c16 ). The interface includes a UART receive and transmit modules that share a single baud rate generator module. The baud rate is set using two constants defined at the core top module which are calculated as follows: D_BAUD_FREQ=16\u22c5BaudRate gcd\ue09eGlobalClockFreq,16\u2217BaudRate\ue09f D_BAUD_LIMIT=GlobalClockFreq gcd\ue09eGlobalClockFreq,16\u22c5BaudRate\ue09f\u2212D_BAUD_FREQ A short Scilab script which calculates the above parameters is added under the \u201cscilab\u201d directory with the core files. The interface between the \u201cuart_parser.v\u201d module and the \u201cuart_top.v\u201d is very simple and uses only five signals. For cases where the UART interface is not possible or another interface is preferred, the \u201cuart_parser.v\u201d module can be used as is with a different interface implementation. UART to Bus Core Specifications Page 5 of 10 uart_tx.v uart_rx.v baud_gen.vuart_top.v uart_parser.vuart2bus_top.v ser_out ser_inint_address int_wr_data16 8 int_write int_read int_rd_data 8 clock resetint_req int_gntFebruary 25, 2012 4.Operation This section describes the protocols used to access the internal bus from the UART interface. As mentioned above the parser supports two modes of operation: text & binary commands. To distinguish between the two protocols all binary commands start with a value of zero which will not be sent when using the text protocol. The following drawing depicts a simplified state machine of the parser. The figure does not include some transitions used to abort illegal command sequences. Figure 2: Parser State Diagram In the state diagram above the states on the right are used for the text mode protocol and the states on the left are used for the binary mode protocol. The following sub-sections describe each of the protocols. 4.1.Text Mode Protocol The text mode protocol includes only two commands: address read and address write. All values are in HEX format. The parser checks for both upper and lower characters, detects both space (0x20) and tab (0x09) as white spaces and both LF (0x0A) and CR (0x0D) as end of\nUART to Bus Core Specifications Written for publication on: File name: UART to Bus Core Specifications Version: 1.0 Creation Date: February 12, 2010 Update Date: February 25, 2012 Author: Moti Litochevski February 25, 2012 Table of Contents 1. Preface.............................................................................................................................................. 3 1.1. Scope........................................................................................................................................ 3 1.2. Revision History ....................................................................................................................... 3 1.3. Abbreviations........................................................................................................................... 3 2. Introduction...................................................................................................................................... 4 3. Architecture...................................................................................................................................... 5 4. Operation.......................................................................................................................................... 6 4.1. Text Mode Protocol .................................................................................................................. 6 4.2. Binary Mode Protocol .............................................................................................................. 7 5. Core Interfaces................................................................................................................................. 9 6. Test Bench Description .................................................................................................................. 10 Index of Tables Table 1: Synthesis Results for Different FPGA Devices ..................................................................... 4 Table 2: Text Protocol Read Command Format .................................................................................. 7 Table 3: Text Protocol Write Command Format ................................................................................. 7 Table 4: Binary Protocol Command Format ........................................................................................ 8 Table 5: Binary Protocol Return Message Format .............................................................................. 8 Table 6: Core Interfaces Description ................................................................................................... 9 Index of Figures Figure 1: UART to Bus Core Block Diagram ..................................................................................... 5 Figure 2: Parser State Diagram ............................................................................................................ 6 UART to Bus Core Specifications Page 2 of 10 February 25, 2012 1.Preface 1.1.Scope This document describes the UART to Bus IP core operation, architecture and interfaces. 1.2.Revision History RevDateAuthor Description 0.102/13/10Moti Litochevski First Draft 0.204/02/10Moti Litochevski Adding test bench description section 0.304/15/11Moti Litochevski Added Lattice MachXO device utilization provided by Paul V. Shatov. 1.002/25/12Moti Litochevski Updated interface description and synthesis results after adding bus request/grant mechanism. 1.3.Abbreviations UARTUniversal Asynchronous Receiver / Transmitter UART to Bus Core Specifications Page 3 of 10 February 25, 2012 2.Introduction The UART to Bus IP Core is a simple command parser that can be used to access an internal bus via a UART interface. This core can be used during initial board debugging or as a permanent solution when high speed interfaces are not required. The internal bus is designed with address bus of 16 bits and data bus of 8 bits. The core implements a very basic UART transmit & receive blocks which share a common baud rate generator and a command parser. The parser supports two modes of operation: text mode commands and binary mode commands. Text mode commands are designed to be used with a hyper terminal software and enable easy access to the internal bus. Binary mode commands are more efficient and also support buffered read & write operations with or without automatic address increment. The core was verified using Icarus Verilog simulator with two test benches: the first tests the text mode protocol and the second tests the binary protocol. The test bench uses a register file model to simulate write and read operations. The following table summarizes the synthesis results of the core for different FPGA families. ManufacturerFamilyDevice Device UtilizationElements UtilizationFmax XilinxSpartan 3xc3s50-5pq208 24.00%186 Slices>150MHz XilinxVirtex 5xc5vlx30-3ff324 2.00%111 Slices>200MHz AlteraCyclone IIIep3c5f256c6 5.00%255 LEs>200MHz AlteraStartix IIIep3sl50f484c2 <1%167 Registers 218 ALUTs>200MHz Lattice1MachXOLCMXO2280C- 4T144C10.00%116 Slices> 100MHz Table 1: Synthesis Results for Different FPGA Devices The above results where obtained using the following software versions: \u2022Xilinx ISE Webpack 11.4 \u2022Altera Quartus Web Edition 9.1sp2 NOTE: The UART to Bus core is not Wishbone compatible although\nbe written to. int_readoutput1An active high read control signal. This signal shall only be valid for a single clock cycle per address to be read from. int_rd_datainput8Data value read from address. This signal is sampled by the core on the next clock cycle following int_read signal active cycle. int_reqoutput1Internal bus access request signal. The core will assert this signal to request access to the internal bus before every bus access. This signal will be asserted until bus access is granted. int_gntinput1Internal bus grant signal. The core will release the request signal and execute the bus access when this signal is asserted. To disable bus request/grant mechanism set this to logic '1'. Table 6: Core Interfaces Description Note: The port direction in the table above is as defined in the core top module. UART to Bus Core Specifications Page 9 of 10 February 25, 2012 6.Test Bench Description The 'verilog\\bench' directory contains two test benches files and required tasks and modules. Compilation batch files are included in the 'verilog\\sim\\icarus' directory used to simulate the core using Icarus Verilog. The directory inclues two compilation batch files: one for binary mode protocol simulation and the second for text mode protocol simulation. The directory also includes batch file to run the simulation, 'run.bat', and another to call gtkwave to view the simulation VCD output file. Note that for binary mode protocol simulation the test bench reads the commands from 'test.bin' file also included in the directory. The file structure is straight forward and is explained in the respective test bench file. UART to Bus Core Specifications Page 10 of 10\nWrite a SystemVerilog module to implement a UART (Universal Asynchronous Receiver-Transmitter) controller. The module should support configurable baud rates, transmit and receive functionality, and proper start, data, parity (optional), and 2 stop bit handling. The UART should operate in full-duplex mode and adhere to the following interface:\nmodule UART_driver( input  logic       clk,        // System clock input  logic       rst,        // Asynchronous reset input  logic       UART_Start, // Signal to initiate transmission input  logic [8:0] data_in,    // Data to be transmitted input  logic       RX,         // UART receive line output logic       TX,         // UART transmit line output logic [8:0] data_out,   // Received data output logic       UART_Ready, // Ready to transmit next byte output logic       UART_Busy,  // Indicates UART is currently transmitting output logic       UART_Error  // High if framing or parity error detected ); ",
    "answer_1": "To implement the UART (Universal Asynchronous Receiver-Transmitter) controller in SystemVerilog, we will create a module named `UART_driver`. This module will include a baud rate generator, a transmit (TX) state machine, and a receive (RX) state machine.\n\n**Key Features and Design Choices:**\n\n1.  **Configurable Parameters:**\n    *   `CLK_FREQ`: System clock frequency in Hz.\n    *   `BAUD_RATE`: Desired baud rate (e.g., 115200).\n    *   `DATA_BITS`: Number of data bits (configurable from 5 to 9).\n    *   `PARITY_TYPE`: Parity setting (0: None, 1: Even, 2: Odd).\n    *   `STOP_BITS`: Fixed to 2 as per the requirement.\n\n2.  **Baud Rate Generator:**\n    *   Generates two types of clock enable pulses:\n        *   `baud_tick_1x`: For TX, pulses once per baud period.\n        *   `baud_tick_16x`: For RX oversampling, pulses 16 times per baud period, allowing sampling at the center of each bit.\n\n3.  **Transmitter (TX) Logic:**\n    *   **States:** `TX_IDLE`, `TX_START`, `TX_DATA`, `TX_PARITY`, `TX_STOP`.\n    *   **Start Bit:** Sends a logic '0' for one baud period.\n    *   **Data Bits:** Sends `DATA_BITS` number of data bits, LSB first.\n    *   **Parity Bit:** If `PARITY_TYPE` is not `None`, calculates and sends the appropriate parity bit (Even or Odd).\n    *   **Stop Bits:** Sends two logic '1's for two baud periods.\n    *   **Control Signals:**\n        *   `UART_Start`: An input pulse to initiate transmission. It's internally edge-detected to trigger a single byte transmission.\n        *   `UART_Busy`: High when a transmission is in progress.\n        *   `UART_Ready`: High when the TX is in `TX_IDLE` state, ready for a new byte.\n\n4.  **Receiver (RX) Logic:**\n    *   **States:** `RX_IDLE`, `RX_START`, `RX_DATA`, `RX_PARITY`, `RX_STOP`, `RX_DONE`.\n    *   **Start Bit Detection:** Detects a falling edge on the `RX` line and then samples the middle of the start bit to confirm.\n    *   **Data Bit Sampling:** Samples `DATA_BITS` number of data bits at the center of each bit period using the `baud_tick_16x` clock. Bits are shifted into `rx_data_reg` LSB first.\n    *   **Parity Check:** If `PARITY_TYPE` is not `None`, samples the parity bit and compares it with the calculated parity of the received data.\n    *   **Stop Bit Check:** Samples the two stop bits, expecting them to be logic '1'.\n    *   **Error Detection:**\n        *   `UART_Error`: Becomes high if a framing error (invalid start or stop bit) or a parity error is detected. This is a sticky flag, cleared by `rst`.\n        *   `data_out`: Outputs the received data. If `DATA_BITS` is less than 9, the upper bits of `data_out` will be zero-padded.\n\n**SystemVerilog Module:**\n\n\n```systemverilog\n// SystemVerilog module for a UART (Universal Asynchronous Receiver-Transmitter) controller.\n// Supports configurable baud rates, transmit and receive functionality,\n// and proper start, data, parity (optional), and 2 stop bit handling.\n// Operates in full-duplex mode.\n\nmodule UART_driver #(\n    parameter int CLK_FREQ      = 100_000_000, // System clock frequency in Hz\n    parameter int BAUD_RATE     = 115200,      // Desired baud rate\n    parameter int DATA_BITS     = 8,           // Number of data bits (5-9)\n    parameter int PARITY_TYPE   = 0            // 0: None, 1: Even, 2: Odd\n) (\n    input  logic       clk,        // System clock\n    input  logic       rst,        // Asynchronous reset\n    input  logic       UART_Start, // Signal to initiate transmission (pulse, active high)\n    input  logic [8:0] data_in,    // Data to be transmitted (LSB first, data_in[DATA_BITS-1:0] used)\n    input  logic       RX,         // UART receive line\n    output logic       TX,         // UART transmit line\n    output logic [8:0] data_out,   // Received data (data_out[DATA_BITS-1:0] valid, upper bits zeroed)\n    output logic       UART_Ready, // Ready to transmit next byte (active high)\n    output logic       UART_Busy,  // Indicates UART is currently transmitting (active high)\n    output logic       UART_Error  // High if framing or parity error detected (sticky, cleared by rst)\n);\n\n    // Internal parameters and constants\n    localparam int OVERSAMPLING_FACTOR = 16; // For RX oversampling (common value)\n    localparam int NUM_STOP_BITS = 2;         // Fixed to 2 stop bits as per requirement\n\n    // Calculate baud rate divisors\n    // For 1x baud tick (TX): CLK_FREQ / BAUD_RATE\n    localparam int BAUD_TICK_DIVISOR_1X = CLK_FREQ / BAUD_RATE;\n    // For 16x baud tick (RX oversampling): CLK_FREQ / (BAUD_RATE * OVERSAMPLING_FACTOR)\n    localparam int BAUD_TICK_DIVISOR_16X = CLK_FREQ / (BAUD_RATE * OVERSAMPLING_FACTOR);\n\n    // Compile-time checks for parameter validity\n    initial begin\n        if (BAUD_TICK_DIVISOR_1X == 0) begin\n            $error(\"UART_driver: BAUD_TICK_DIVISOR_1X is zero. CLK_FREQ must be >= BAUD_RATE.\");\n        end\n        if (BAUD_TICK_DIVISOR_16X == 0) begin\n            $error(\"UART_driver: BAUD_TICK_DIVISOR_16X is zero. CLK_FREQ must be >= (BAUD_RATE * OVERSAMPLING_FACTOR).\");\n        end\n        if (DATA_BITS < 5 || DATA_BITS > 9) begin\n            $error(\"UART_driver: DATA_BITS must be between 5 and 9.\");\n        end\n        if (PARITY_TYPE < 0 || PARITY_TYPE > 2) begin\n            $error(\"UART_driver: PARITY_TYPE must be 0 (None), 1 (Even), or 2 (Odd).\");\n        end\n    end\n\n    // Baud Rate Generator\n    logic baud_tick_1x;  // Pulse at 1x baud rate for TX\n    logic baud_tick_16x; // Pulse at 16x baud rate for RX oversampling\n\n    // Counter for 1x baud tick (width handles case where divisor is 1)\n    logic [($clog2(BAUD_TICK_DIVISOR_1X) == 0 ? 0 : $clog2(BAUD_TICK_DIVISOR_1X)-1):0] baud_cnt_1x;\n    // Counter for 16x baud tick (width handles case where divisor is 1)\n    logic [($clog2(BAUD_TICK_DIVISOR_16X) == 0 ? 0 : $clog2(BAUD_TICK_DIVISOR_16X)-1):0] baud_cnt_16x;\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            baud_cnt_1x <= '0;\n            baud_tick_1x <= 1'b0;\n            baud_cnt_16x <= '0;\n            baud_tick_16x <= 1'b0;\n        end else begin\n            // 1x Baud Tick for TX\n            if (baud_cnt_1x == BAUD_TICK_DIVISOR_1X - 1) begin\n                baud_cnt_1x <= '0;\n                baud_tick_1x <= 1'b1;\n            end else begin\n                baud_cnt_1x <= baud_cnt_1x + 1;\n                baud_tick_1x <= 1'b0;\n            end\n\n            // 16x Baud Tick for RX oversampling\n            if (baud_cnt_16x == BAUD_TICK_DIVISOR_16X - 1) begin\n                baud_cnt_16x <= '0;\n                baud_tick_16x <= 1'b1;\n            end else begin\n                baud_cnt_16x <= baud_cnt_16x + 1;\n                baud\n_tick_16x <= 1'b0;\n            end\n        end\n    end\n\n    // TX Module\n    localparam int TX_IDLE = 0, TX_START = 1, TX_DATA = 2, TX_PARITY = 3, TX_STOP = 4;\n    logic [2:0] tx_state;\n    logic [DATA_BITS-1:0] tx_data_reg; // Data to be transmitted\n    logic tx_parity_bit;               // Calculated parity bit\n    // Counter for data bits (width handles case where DATA_BITS is 1)\n    logic [($clog2(DATA_BITS) == 0 ? 0 : $clog2(DATA_BITS)-1):0] tx_bit_cnt;\n    // Counter for stop bits (width handles case where NUM_STOP_BITS is 1)\n    logic [($clog2(NUM_STOP_BITS) == 0 ? 0 : $clog2(NUM_STOP_BITS)-1):0] tx_stop_cnt;\n    logic tx_busy_internal;            // Internal busy flag\n    logic tx_start_pulse;              // Edge-detected UART_Start\n\n    // Capture UART_Start as a single-cycle pulse when not busy\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tx_start_pulse <= 1'b0;\n        end else begin\n            tx_start_pulse <= UART_Start & ~tx_busy_internal;\n        end\n    end\n\n    assign UART_Busy = tx_busy_internal;\n    assign UART_Ready = (tx_state == TX_IDLE); // Ready when idle\n\n    // TX output line: default high (idle), low for start, data/parity/stop bits\n    assign TX = (tx_state == TX_IDLE || tx_state == TX_STOP) ? 1'b1 :\n                (tx_state == TX_START) ? 1'b0 :\n                (tx_state == TX_DATA) ? tx_data_reg[0] :\n                (tx_state == TX_PARITY) ? tx_parity_bit : 1'b1; // Default to high for safety\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tx_state <= TX_IDLE;\n            tx_data_reg <= '0;\n            tx_bit_cnt <= '0;\n            tx_stop_cnt <= '0;\n            tx_busy_internal <= 1'b0;\n            tx_parity_bit <= 1'b0;\n        end else begin\n            if (baud_tick_1x) begin // Advance state on 1x baud tick\n                case (tx_state)\n                    TX_IDLE: begin\n                        if (tx_start_pulse) begin // Triggered by UART_Start pulse\n                            tx_data_reg <= data_in[DATA_BITS-1:0]; // Load data\n                            tx_state <= TX_START;\n                            tx_busy_internal <= 1'b1;\n                            tx_bit_cnt <= '0;\n                            tx_stop_cnt <= '0;\n                            // Calculate parity if enabled\n                            if (PARITY_TYPE != 0) begin\n                                logic parity_val;\n                                parity_val = ^(data_in[DATA_BITS-1:0]); // XOR all data bits\n                                if (PARITY_TYPE == 1) begin // Even parity\n                                    tx_parity_bit <= parity_val;\n                                end else begin // Odd parity\n                                    tx_parity_bit <= ~parity_val;\n                                end\n                            end\n                        end\n                    end\n                    TX_START: begin\n                        tx_state <= TX_DATA; // Move to sending data bits\n                    end\n                    TX_DATA: begin\n                        tx_data_reg <= tx_data_reg >> 1; // Shift right for next bit (LSB first)\n                        if (tx_bit_cnt < DATA_BITS - 1) begin\n                            tx_bit_cnt <= tx_bit_cnt + 1;\n                        end else begin\n                            if (PARITY_TYPE != 0) begin\n                                tx_state <= TX_PARITY; // Move to sending parity bit\n                            end else begin\n                                tx_state <= TX_STOP; // Move to sending stop bits\n                            end\n                            tx_bit_cnt <= '0; // Reset for next use\n                        end\n                    end\n                    TX_PARITY: begin\n                        tx_state <= TX_STOP; // Move to sending stop bits\n                    end\n                    TX_STOP: begin\n                        if (tx_stop_cnt < NUM_STOP_BITS - 1) begin // Count up to NUM_STOP_BITS-1 (e.g., 0 and 1 for 2 stop bits)\n                            tx_stop_cnt <= tx_stop_cnt + 1;\n                        end else begin\n                            tx_state <= TX_IDLE; // Transmission complete\n                            tx_busy_internal <= 1'b0;\n                        end\n                    end\n                    default: tx_state <= TX_IDLE; // Should not happen, reset to idle\n                endcase\n            end\n        end\n    end\n\n    // RX Module\n    localparam int RX_IDLE = 0, RX_START = 1, RX_DATA = 2, RX_PARITY = 3, RX_STOP = 4, RX_DONE = 5;\n    logic [2:0] rx_state;\n    logic [DATA_BITS-1:0] rx_data_reg; // Received data\n    // Counter for 16x samples within a bit period\n    logic [($clog2(OVERSAMPLING_FACTOR) == 0 ? 0 : $clog2(OVERSAMPLING_FACTOR)-1):0] rx_sample_cnt;\n    // Counter for received data bits\n    logic [($clog2(DATA_BITS) == 0 ? 0 : $clog2(DATA_BITS)-1):0] rx_data_bit_cnt;\n    // Counter for received stop bits\n    logic [($clog2(NUM_STOP_BITS) == 0 ? 0 : $clog2(NUM_STOP_BITS)-1):0] rx_stop_bit_cnt;\n    logic rx_parity_bit_rcvd; // The actual parity bit received\n    logic rx_error_internal;  // Internal sticky error flag\n    logic rx_parity_error;    // Parity error detected\n    logic rx_framing_error;   // Framing error detected (start or stop bit violation)\n\n    // Output received data, padded with zeros if DATA_BITS < 9\n    assign data_out = {{(9-DATA_BITS){1'b0}}, rx_data_reg};\n    assign UART_Error = rx_error_internal; // Combined error output\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_state <= RX_IDLE;\n            rx_data_reg <= '0;\n            rx_sample_cnt <= '0;\n            rx_data_bit_cnt <= '0;\n            rx_stop_bit_cnt <= '0;\n            rx_error_internal <= 1'b0;\n            rx_parity_error <= 1'b0;\n            rx_framing_error <= 1'b0;\n            rx_parity_bit_rcvd <= 1'b0;\n        end else begin\n            if (baud_tick_16x) begin // Advance state on 16x baud tick\n                case (rx_state)\n                    RX_IDLE: begin\n                        if (RX == 1'b0) begin // Detect falling edge (start bit)\n                            rx_state <= RX_START;\n                            rx_sample_cnt <= '0; // Reset sample counter\n                            rx_data_bit_cnt <= '0; // Reset data bit counter\n                            rx_stop_bit_cnt <= '0; // Reset stop bit counter\n                            rx_data_reg <= '0; // Clear data register\n                            rx_error_internal <= 1'b0; // Clear previous errors\n                            rx_parity_error <= 1'b0;\n                            rx_framing_error <= 1'b0;\n                        end\n                    end\n                    RX_START: begin\n                        rx_sample_cnt <= rx_sample_cnt + 1;\n                        // Sample at the middle of the start bit (8th sample of 16)\n                        if (rx_sample_cnt == OVERSAMPLING_FACTOR / 2 - 1) begin\n                            if (RX == 1'b0) begin // Start bit must still be low\n                                rx_state <= RX_DATA;\n                                rx_sample_cnt <= '0; // Reset for data bit sampling\n                            end else begin // False start or glitch\n                                rx_state <= RX_IDLE;\n                                rx_error_internal <= 1'b1;\n                                rx_framing_error <= 1'b1;\n                            end\n                        end\n                    end\n                    RX_DATA: begin\n                        rx_sample_cnt <= rx_sample_cnt + 1;\n                        // Sample at the middle of each data bit (16th sample of 16)\n                        if (rx_sample_cnt == OVERSAMPLING_FACTOR - 1) begin\n                            rx_sample_cnt <= '0;\n                            // Shift in new bit (LSB first into bit 0)\n                            rx_data_reg <= {rx_data_reg[DATA_BITS-2:0], RX};\n                            if (rx_data_bit_cnt < DATA_BITS - 1) begin\n                                rx_data_bit_cnt <= rx_data_bit_cnt + 1;\n                            end else begin\n                                if (PARITY_TYPE != 0) begin\n                                    rx_state <= RX_PARITY; // All data bits received, check parity\n                                end else begin\n                                    rx_state <= RX_STOP; // All data bits received, check stop bits\n                                end\n                            end\n                        end\n                    end\n                    RX_PARITY: begin\n                        rx_sample_cnt <= rx_sample_cnt + 1;\n                        // Sample at the middle of the parity bit\n                        if (rx_sample_cnt == OVERSAMPLING_FACTOR - 1) begin\n                            rx_sample_cnt <= '0;\n                            rx_parity_bit_rcvd <= RX; // Store received parity bit\n\n                            // Check parity\n                            logic calculated_parity;\n                            calculated_parity = ^(rx_data_reg[DATA_BITS-1:0]); // XOR of received data bits\n                            if (PARITY_TYPE == 1) begin // Even parity\n                                if (calculated_parity != rx_parity_bit_rcvd) begin\n                                    rx_parity_error <= 1'b1;\n                                    rx_error_internal <= 1'b1;\n                                end\n                            end else if (PARITY_TYPE == 2) begin // Odd parity\n                                if (calculated_parity == rx_parity_bit_rcvd) begin\n                                    rx_parity_error <= 1'b1;\n                                    rx_error_internal <= 1'b1;\n                                end\n                            end\n                            rx_state <= RX_STOP; // Move to checking stop bits\n                        end\n                    end\n                    RX_STOP: begin\n                        rx_sample_cnt <= rx_sample_cnt + 1;\n                        // Sample at the middle of each stop bit\n                        if (rx_sample_cnt == OVERSAMPLING_FACTOR - 1) begin\n                            rx_sample_cnt <= '0;\n                            if (RX == 1'b1) begin // Stop bit must be high\n                                if (rx_stop_bit_cnt < NUM_STOP_BITS - 1) begin // Check for subsequent stop bits\n                                    rx_stop_bit_cnt <= rx_stop_bit_cnt + 1;\n                                    // Stay in RX_STOP to sample the next stop bit\n                                end else begin\n                                    rx_state <= RX_DONE; // All bits received successfully\n                                end\n                            end else begin // Framing error: stop bit was low\n                                rx_framing_error <= 1'b1;\n                                rx_error_internal <= 1'b1;\n                                rx_state <= RX_IDLE; // Go back to idle immediately on error\n                            end\n                        end\n                    end\n                    RX_DONE: begin\n                        // Data is ready, transition back to idle\n                        rx_state <= RX_IDLE;\n                    end\n                    default: rx_state <= RX_IDLE; // Should not happen, reset to idle\n                endcase\n            end\n        end\n    end\n\nendmodule\n\n```"
}
