{
    "prompt_0": "Write a SystemVerilog module to implement a UART (Universal Asynchronous Receiver-Transmitter) controller. The module should support configurable baud rates, transmit and receive functionality, and proper start, data, parity (optional), and stop bit handling. The UART should operate in full-duplex mode and adhere to the following interface:\nmodule UART_driver( input  logic       clk,        // System clock input  logic       rst,        // Asynchronous reset input  logic       UART_Start, // Signal to initiate transmission input  logic [7:0] data_in,    // Data to be transmitted input  logic       RX,         // UART receive line output logic       TX,         // UART transmit line output logic [7:0] data_out,   // Received data output logic       UART_Ready, // Ready to transmit next byte output logic       UART_Busy,  // Indicates UART is currently transmitting output logic       UART_Error  // High if framing or parity error detected ); ",
    "answer_0": "Here's a complete SystemVerilog implementation of a UART controller with configurable parameters:\n\n```systemverilog\nmodule UART_driver #(\n    parameter CLOCK_FREQ = 100_000_000,  // System clock frequency in Hz\n    parameter BAUD_RATE = 9600,          // Baud rate\n    parameter DATA_BITS = 8,             // Number of data bits (5-8)\n    parameter PARITY_EN = 1,             // Enable parity (0=disabled, 1=enabled)\n    parameter PARITY_TYPE = 0,           // Parity type (0=even, 1=odd)\n    parameter STOP_BITS = 1              // Number of stop bits (1 or 2)\n)(\n    input  logic       clk,        // System clock\n    input  logic       rst,        // Asynchronous reset\n    input  logic       UART_Start, // Signal to initiate transmission\n    input  logic [7:0] data_in,    // Data to be transmitted\n    input  logic       RX,         // UART receive line\n    output logic       TX,         // UART transmit line\n    output logic [7:0] data_out,   // Received data\n    output logic       UART_Ready, // Ready to transmit next byte\n    output logic       UART_Busy,  // Indicates UART is currently transmitting\n    output logic       UART_Error  // High if framing or parity error detected\n);\n\n    // Calculate baud rate divider\n    localparam BAUD_TICK = CLOCK_FREQ / BAUD_RATE;\n    localparam BAUD_TICK_HALF = BAUD_TICK / 2;\n    \n    // State definitions for transmitter\n    typedef enum logic [2:0] {\n        TX_IDLE,\n        TX_START,\n        TX_DATA,\n        TX_PARITY,\n        TX_STOP\n    } tx_state_t;\n    \n    // State definitions for receiver\n    typedef enum logic [2:0] {\n        RX_IDLE,\n        RX_START,\n        RX_DATA,\n        RX_PARITY,\n        RX_STOP\n    } rx_state_t;\n    \n    // Transmitter signals\n    tx_state_t tx_state, tx_next_state;\n    logic [$clog2(BAUD_TICK)-1:0] tx_baud_counter;\n    logic [3:0] tx_bit_counter;\n    logic [7:0] tx_shift_reg;\n    logic tx_parity_bit;\n    logic tx_baud_tick;\n    logic [1:0] tx_stop_counter;\n    \n    // Receiver signals\n    rx_state_t rx_state, rx_next_state;\n    logic [$clog2(BAUD_TICK)-1:0] rx_baud_counter;\n    logic [3:0] rx_bit_counter;\n    logic [7:0] rx_shift_reg;\n    logic rx_parity_bit;\n    logic rx_baud_tick;\n    logic rx_start_tick;\n    logic [1:0] rx_stop_counter;\n    logic [2:0] rx_sync;\n    logic rx_error_frame, rx_error_parity;\n    logic data_ready;\n    \n    // Baud rate generation for transmitter\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tx_baud_counter <= 0;\n            tx_baud_tick <= 0;\n        end else begin\n            if (tx_state == TX_IDLE) begin\n                tx_baud_counter <= 0;\n                tx_baud_tick <= 0;\n            end else if (tx_baud_counter == BAUD_TICK - 1) begin\n                tx_baud_counter <= 0;\n                tx_baud_tick <= 1;\n            end else begin\n                tx_baud_counter <= tx_baud_counter + 1;\n                tx_baud_tick <= 0;\n            end\n        end\n    end\n    \n    // Baud rate generation for receiver\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_baud_counter <= 0;\n            rx_baud_tick <= 0;\n            rx_start_tick <= 0;\n        end else begin\n            if (rx_state == RX_IDLE) begin\n                rx_baud_counter <= 0;\n                rx_baud_tick <= 0;\n                rx_start_tick <= 0;\n            end else if (rx_state == RX_START) begin\n                if (rx_baud_counter == BAUD_TICK_HALF - 1) begin\n                    rx_baud_counter <= 0;\n                    rx_start_tick <= 1;\n                end else begin\n                    rx_baud_counter <= rx_baud_counter + 1;\n                    rx_start_tick <= 0;\n                end\n            end else if (rx_baud_counter == BAUD_TICK - 1) begin\n                rx_baud_counter <= 0;\n                rx_baud_tick <= 1;\n            end else begin\n                rx_baud_counter <= rx_baud_counter + 1;\n                rx_baud_tick <= 0;\n            end\n        end\n    end\n    \n    // RX synchronizer\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_sync <= 3'b111;\n        end else begin\n            rx_sync <= {rx_sync[1:0], RX};\n        end\n    end\n    \n    // Transmitter state machine\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tx_state <= TX_IDLE;\n        end else begin\n            tx_state <= tx_next_state;\n        end\n    end\n    \n    always_comb begin\n        tx_next_state = tx_state;\n        \n        case (tx_state)\n            TX_IDLE: begin\n                if (UART_Start) begin\n                    tx_next_state = TX_START;\n                end\n            end\n            \n            TX_START: begin\n                if (tx_baud_tick) begin\n                    tx_next_state = TX_DATA;\n                end\n            end\n            \n            TX_DATA: begin\n                if (tx_baud_tick && tx_bit_counter == DATA_BITS - 1) begin\n                    if (PARITY_EN) begin\n                        tx_next_state = TX_PARITY;\n                    end else begin\n                        tx_next_state = TX_STOP;\n                    end\n                end\n            end\n            \n            TX_PARITY: begin\n                if (tx_baud_tick) begin\n                    tx_next_state = TX_STOP;\n                end\n            end\n            \n            TX_STOP: begin\n                if (tx_baud_tick && tx_stop_counter == STOP_BITS - 1) begin\n                    tx_next_state = TX_IDLE;\n                end\n            end\n        endcase\n    end\n    \n    // Transmitter data path\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tx_shift_reg <= 8'h00;\n            tx_bit_counter <= 0;\n            tx_parity_bit <= 0;\n            tx_stop_counter <= 0;\n        end else begin\n            case (tx_state)\n                TX_IDLE: begin\n                    if (UART_Start) begin\n                        tx_shift_reg <= data_in;\n                        tx_bit_counter <= 0;\n                        tx_stop_counter <= 0;\n                        // Calculate parity\n                        if (PARITY_EN) begin\n                            tx_parity_bit <= PARITY_TYPE ? ~(^data_in) : ^data_in;\n                        end\n                    end\n                end\n                \n                TX_DATA: begin\n                    if (tx_baud_tick) begin\n                        tx_shift_reg <= tx_shift_reg >> 1;\n                        tx_bit_counter <= tx_bit_counter + 1;\n                    end\n                end\n                \n                TX_STOP: begin\n                    if (tx_baud_tick) begin\n                        tx_stop_counter <= tx_stop_counter + 1;\n                    end\n                end\n            endcase\n        end\n    end\n    \n    // Receiver state machine\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_state <= RX_IDLE;\n        end else begin\n            rx_state <= rx_next_state;\n        end\n    end\n    \n    always_comb begin\n        rx_next_state = rx_state;\n        \n        case (rx_state)\n            RX_IDLE: begin\n                if (rx_sync[2:1] == 2'b10) begin  // Detect start bit\n                    rx_next_state = RX_START;\n                end\n            end\n            \n            RX_START: begin\n                if (rx_start_tick) begin\n                    if (rx_sync[2] == 0) begin  // Validate start bit\n                        rx_next_state = RX_DATA;\n                    end else begin\n                        rx_next_state = RX_IDLE;  // False start\n                    end\n                end\n            end\n            \n            RX_DATA: begin\n                if (rx_baud_tick && rx_bit_counter == DATA_BITS - 1) begin\n                    if (PARITY_EN) begin\n                        rx_next_state = RX_PARITY;\n                    end else begin\n                        rx_next_state = RX_STOP;\n                    end\n                end\n            end\n            \n            RX_PARITY: begin\n                if (rx_baud_tick) begin\n                    rx_next_state = RX_STOP;\n                end\n            end\n            \n            RX_STOP: begin\n                if (rx_baud_tick && rx_stop_counter == STOP_BITS - 1) begin\n                    rx_next_state = RX_IDLE;\n                end\n            end\n        endcase\n    end\n    \n    // Receiver data path\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_shift_reg <= 8'h00;\n            rx_bit_counter <= 0;\n            rx_parity_bit <= 0;\n            rx_stop_counter <= 0;\n            rx_error_frame <= 0;\n            rx_error_parity <= 0;\n            data_ready <= 0;\n        end else begin\n            data_ready <= 0;\n            \n            case (rx_state)\n                RX_IDLE: begin\n                    rx_bit_counter <= 0;\n                    rx_stop_counter <= 0;\n                    rx_error_frame <= 0;\n                    rx_error_parity <= 0;\n                end\n                \n                RX_DATA: begin\n                    if (rx_baud_tick) begin\n                        rx_shift_reg <= {rx_sync[2], rx_shift_reg[7:1]};\n                        rx_bit_counter <= rx_bit_counter + 1;\n                    end\n                end\n                \n                RX_PARITY: begin\n                    if (rx_baud_tick) begin\n                        rx_parity_bit <= rx_sync[2];\n                        // Check parity\n                        if (PARITY_EN) begin\n                            if (PARITY_TYPE) begin  // Odd parity\n                                rx_error_parity <= (rx_sync[2] != ~(^rx_shift_reg));\n                            end else begin  // Even parity\n                                rx_error_parity <= (rx_sync[2] != (^rx_shift_reg));\n                            end\n                        end\n                    end\n                end\n                \n                RX_STOP: begin\n                    if (rx_baud_tick) begin\n                        if (rx_sync[2] == 0) begin  // Stop bit should be high\n                            rx_error_frame <= 1;\n                        end\n                        rx_stop_counter <= rx_stop_counter + 1;\n                        \n                        if (rx_stop_counter == STOP_BITS - 1) begin\n                            data_ready <= 1;\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n    \n    // Output assignments\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            TX <= 1;\n            data_out <= 8'h00;\n            UART_Error <= 0;\n        end else begin\n            // TX output\n            case (tx_state)\n                TX_IDLE:   TX <= 1;\n                TX_START:  TX <= 0;\n                TX_DATA:   TX <= tx_shift_reg[0];\n                TX_PARITY: TX <= tx_parity_bit;\n                TX_STOP:   TX <= 1;\n            endcase\n            \n            // Data output\n            if (data_ready) begin\n                data_out <= rx_shift_reg;\n            end\n            \n            // Error output\n            UART_Error <= rx_error_frame | rx_error_parity;\n        end\n    end\n    \n    // Status signals\n    assign UART_Ready = (tx_state == TX_IDLE);\n    assign UART_Busy = (tx_state != TX_IDLE);\n\nendmodule\n```\n\nThis UART controller implementation includes:\n\n**Key Features:**\n1. **Configurable Parameters**: Baud rate, data bits, parity, and stop bits\n2. **Full-Duplex Operation**: Independent transmit and receive state machines\n3. **Proper Bit Timing**: Accurate baud rate generation with half-bit timing for start bit detection\n4. **Error Detection**: Frame errors (invalid stop bits) and parity errors\n5. **Synchronization**: Input synchronizer for RX signal to prevent metastability\n\n**Transmitter Features:**\n- Handles start bit, data bits, optional parity, and stop bits\n- Configurable parity (even/odd or disabled)\n- Ready/Busy status signals\n- Proper idle state (TX line high)\n\n**Receiver Features:**\n- Start bit detection and validation\n- Mid-bit sampling for better noise immunity\n- Configurable parity checking\n- Frame error detection\n- False start bit rejection\n\n**Usage Example:**\n```systemverilog\nUART_driver #(\n    .CLOCK_FREQ(50_000_000),\n    .BAUD_RATE(115200),\n    .DATA_BITS(8),\n    .PARITY_EN(1),\n    .PARITY_TYPE(0),  // Even parity\n    .STOP_BITS(1)\n) uart_inst (\n    .clk(clk),\n    .rst(rst),\n    .UART_Start(tx_start),\n    .data_in(tx_data),\n    .RX(uart_rx),\n    .TX(uart_tx),\n    .data_out(rx_data),\n    .UART_Ready(tx_ready),\n    .UART_Busy(tx_busy),\n    .UART_Error(rx_error)\n);\n```\n\nThe module is fully synthesizable and follows standard UART protocol specifications.",
    "prompt_1": "Write a SystemVerilog module to implement a UART (Universal Asynchronous Receiver-Transmitter) controller. The module should support configurable baud rates, transmit and receive functionality, and proper start, data, parity (optional), and 2 stop bit handling. The UART should operate in full-duplex mode and adhere to the following interface:\nmodule UART_driver( input  logic       clk,        // System clock input  logic       rst,        // Asynchronous reset input  logic       UART_Start, // Signal to initiate transmission input  logic [8:0] data_in,    // Data to be transmitted input  logic       RX,         // UART receive line output logic       TX,         // UART transmit line output logic [8:0] data_out,   // Received data output logic       UART_Ready, // Ready to transmit next byte output logic       UART_Busy,  // Indicates UART is currently transmitting output logic       UART_Error  // High if framing or parity error detected ); ",
    "answer_1": "Here's a comprehensive SystemVerilog implementation of a UART controller with the specified features:\n\n```systemverilog\nmodule UART_driver(\n    input  logic       clk,        // System clock\n    input  logic       rst,        // Asynchronous reset\n    input  logic       UART_Start, // Signal to initiate transmission\n    input  logic [8:0] data_in,    // Data to be transmitted (bit 8 = parity enable)\n    input  logic       RX,         // UART receive line\n    output logic       TX,         // UART transmit line\n    output logic [8:0] data_out,   // Received data (bit 8 = parity bit)\n    output logic       UART_Ready, // Ready to transmit next byte\n    output logic       UART_Busy,  // Indicates UART is currently transmitting\n    output logic       UART_Error  // High if framing or parity error detected\n);\n\n    // Parameters for baud rate configuration\n    parameter int CLOCK_FREQ = 100_000_000; // 100 MHz system clock\n    parameter int BAUD_RATE = 115200;       // Default baud rate\n    parameter int BAUD_DIVISOR = CLOCK_FREQ / (BAUD_RATE * 16); // Oversampling by 16\n    \n    // Internal signals for baud rate generation\n    logic [15:0] baud_counter;\n    logic        baud_tick;\n    logic [3:0]  oversample_counter;\n    logic        bit_tick;\n    \n    // Transmitter state machine\n    typedef enum logic [3:0] {\n        TX_IDLE,\n        TX_START,\n        TX_DATA_0, TX_DATA_1, TX_DATA_2, TX_DATA_3,\n        TX_DATA_4, TX_DATA_5, TX_DATA_6, TX_DATA_7,\n        TX_PARITY,\n        TX_STOP_1,\n        TX_STOP_2\n    } tx_state_t;\n    \n    tx_state_t tx_state, tx_next_state;\n    \n    // Receiver state machine\n    typedef enum logic [3:0] {\n        RX_IDLE,\n        RX_START,\n        RX_DATA_0, RX_DATA_1, RX_DATA_2, RX_DATA_3,\n        RX_DATA_4, RX_DATA_5, RX_DATA_6, RX_DATA_7,\n        RX_PARITY,\n        RX_STOP_1,\n        RX_STOP_2\n    } rx_state_t;\n    \n    rx_state_t rx_state, rx_next_state;\n    \n    // Internal registers\n    logic [7:0] tx_data_reg;\n    logic       tx_parity_enable;\n    logic       tx_parity_bit;\n    logic       tx_start_reg;\n    \n    logic [7:0] rx_data_reg;\n    logic       rx_parity_bit;\n    logic       rx_parity_enable;\n    logic [2:0] rx_sample_counter;\n    logic [2:0] rx_sample_buffer;\n    logic       rx_bit_sample;\n    logic       rx_error_reg;\n    \n    // Baud rate generator\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            baud_counter <= 0;\n            oversample_counter <= 0;\n        end else begin\n            if (baud_counter >= (BAUD_DIVISOR - 1)) begin\n                baud_counter <= 0;\n                oversample_counter <= oversample_counter + 1;\n            end else begin\n                baud_counter <= baud_counter + 1;\n            end\n        end\n    end\n    \n    assign baud_tick = (baud_counter == 0);\n    assign bit_tick = baud_tick && (oversample_counter == 0);\n    \n    // Input synchronization for RX\n    logic [2:0] rx_sync;\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            rx_sync <= 3'b111;\n        else\n            rx_sync <= {rx_sync[1:0], RX};\n    end\n    \n    // Majority voting for RX sampling\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_sample_counter <= 0;\n            rx_sample_buffer <= 0;\n        end else if (baud_tick) begin\n            case (oversample_counter)\n                4'd6, 4'd7, 4'd8: begin\n                    rx_sample_buffer <= rx_sample_buffer + rx_sync[2];\n                    rx_sample_counter <= rx_sample_counter + 1;\n                end\n                4'd9: begin\n                    rx_bit_sample <= (rx_sample_buffer >= 2);\n                    rx_sample_counter <= 0;\n                    rx_sample_buffer <= 0;\n                end\n                default: begin\n                    // Do nothing\n                end\n            endcase\n        end\n    end\n    \n    // Transmitter state machine\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tx_state <= TX_IDLE;\n            tx_data_reg <= 8'h00;\n            tx_parity_enable <= 1'b0;\n            tx_start_reg <= 1'b0;\n        end else begin\n            tx_state <= tx_next_state;\n            \n            // Capture data when starting transmission\n            if (tx_state == TX_IDLE && UART_Start) begin\n                tx_data_reg <= data_in[7:0];\n                tx_parity_enable <= data_in[8];\n                tx_start_reg <= 1'b1;\n            end else if (tx_state != TX_IDLE) begin\n                tx_start_reg <= 1'b0;\n            end\n        end\n    end\n    \n    // Transmitter next state logic\n    always_comb begin\n        tx_next_state = tx_state;\n        \n        case (tx_state)\n            TX_IDLE: begin\n                if (UART_Start)\n                    tx_next_state = TX_START;\n            end\n            \n            TX_START: begin\n                if (bit_tick)\n                    tx_next_state = TX_DATA_0;\n            end\n            \n            TX_DATA_0: if (bit_tick) tx_next_state = TX_DATA_1;\n            TX_DATA_1: if (bit_tick) tx_next_state = TX_DATA_2;\n            TX_DATA_2: if (bit_tick) tx_next_state = TX_DATA_3;\n            TX_DATA_3: if (bit_tick) tx_next_state = TX_DATA_4;\n            TX_DATA_4: if (bit_tick) tx_next_state = TX_DATA_5;\n            TX_DATA_5: if (bit_tick) tx_next_state = TX_DATA_6;\n            TX_DATA_6: if (bit_tick) tx_next_state = TX_DATA_7;\n            TX_DATA_7: begin\n                if (bit_tick) begin\n                    if (tx_parity_enable)\n                        tx_next_state = TX_PARITY;\n                    else\n                        tx_next_state = TX_STOP_1;\n                end\n            end\n            \n            TX_PARITY: begin\n                if (bit_tick)\n                    tx_next_state = TX_STOP_1;\n            end\n            \n            TX_STOP_1: begin\n                if (bit_tick)\n                    tx_next_state = TX_STOP_2;\n            end\n            \n            TX_STOP_2: begin\n                if (bit_tick)\n                    tx_next_state = TX_IDLE;\n            end\n            \n            default: tx_next_state = TX_IDLE;\n        endcase\n    end\n    \n    // Calculate parity bit (even parity)\n    always_comb begin\n        tx_parity_bit = ^tx_data_reg;\n    end\n    \n    // Transmitter output\n    always_comb begin\n        case (tx_state)\n            TX_IDLE:    TX = 1'b1;\n            TX_START:   TX = 1'b0;\n            TX_DATA_0:  TX = tx_data_reg[0];\n            TX_DATA_1:  TX = tx_data_reg[1];\n            TX_DATA_2:  TX = tx_data_reg[2];\n            TX_DATA_3:  TX = tx_data_reg[3];\n            TX_DATA_4:  TX = tx_data_reg[4];\n            TX_DATA_5:  TX = tx_data_reg[5];\n            TX_DATA_6:  TX = tx_data_reg[6];\n            TX_DATA_7:  TX = tx_data_reg[7];\n            TX_PARITY:  TX = tx_parity_bit;\n            TX_STOP_1:  TX = 1'b1;\n            TX_STOP_2:  TX = 1'b1;\n            default:    TX = 1'b1;\n        endcase\n    end\n    \n    // Receiver state machine\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_state <= RX_IDLE;\n            rx_data_reg <= 8'h00;\n            rx_parity_bit <= 1'b0;\n            rx_parity_enable <= 1'b0;\n            rx_error_reg <= 1'b0;\n        end else begin\n            rx_state <= rx_next_state;\n            \n            // Capture data bits\n            if (oversample_counter == 4'd9 && baud_tick) begin\n                case (rx_state)\n                    RX_DATA_0: rx_data_reg[0] <= rx_bit_sample;\n                    RX_DATA_1: rx_data_reg[1] <= rx_bit_sample;\n                    RX_DATA_2: rx_data_reg[2] <= rx_bit_sample;\n                    RX_DATA_3: rx_data_reg[3] <= rx_bit_sample;\n                    RX_DATA_4: rx_data_reg[4] <= rx_bit_sample;\n                    RX_DATA_5: rx_data_reg[5] <= rx_bit_sample;\n                    RX_DATA_6: rx_data_reg[6] <= rx_bit_sample;\n                    RX_DATA_7: rx_data_reg[7] <= rx_bit_sample;\n                    RX_PARITY: rx_parity_bit <= rx_bit_sample;\n                    default: begin\n                        // Do nothing\n                    end\n                endcase\n            end\n            \n            // Error detection\n            if (rx_state == RX_STOP_2 && oversample_counter == 4'd9 && baud_tick) begin\n                // Check for framing error or parity error\n                if (!rx_bit_sample) begin\n                    rx_error_reg <= 1'b1; // Framing error\n                end else if (rx_parity_enable && (rx_parity_bit != (^rx_data_reg))) begin\n                    rx_error_reg <= 1'b1; // Parity error\n                end else begin\n                    rx_error_reg <= 1'b0;\n                end\n            end\n        end\n    end\n    \n    // Receiver next state logic\n    always_comb begin\n        rx_next_state = rx_state;\n        \n        case (rx_state)\n            RX_IDLE: begin\n                if (!rx_sync[2] && rx_sync[1]) // Start bit detected\n                    rx_next_state = RX_START;\n            end\n            \n            RX_START: begin\n                if (oversample_counter == 4'd9 && baud_tick) begin\n                    if (!rx_bit_sample) begin\n                        rx_next_state = RX_DATA_0;\n                        // Auto-detect parity based on transmission pattern\n                        // This is a simplified approach - in practice, this would be configured\n                        rx_parity_enable = 1'b1; // Assume parity is enabled\n                    end else begin\n                        rx_next_state = RX_IDLE; // False start\n                    end\n                end\n            end\n            \n            RX_DATA_0: if (oversample_counter == 4'd9 && baud_tick) rx_next_state = RX_DATA_1;\n            RX_DATA_1: if (oversample_counter == 4'd9 && baud_tick) rx_next_state = RX_DATA_2;\n            RX_DATA_2: if (oversample_counter == 4'd9 && baud_tick) rx_next_state = RX_DATA_3;\n            RX_DATA_3: if (oversample_counter == 4'd9 && baud_tick) rx_next_state = RX_DATA_4;\n            RX_DATA_4: if (oversample_counter == 4'd9 && baud_tick) rx_next_state = RX_DATA_5;\n            RX_DATA_5: if (oversample_counter == 4'd9 && baud_tick) rx_next_state = RX_DATA_6;\n            RX_DATA_6: if (oversample_counter == 4'd9 && baud_tick) rx_next_state = RX_DATA_7;\n            RX_DATA_7: begin\n                if (oversample_counter == 4'd9 && baud_tick) begin\n                    if (rx_parity_enable)\n                        rx_next_state = RX_PARITY;\n                    else\n                        rx_next_state = RX_STOP_1;\n                end\n            end\n            \n            RX_PARITY: begin\n                if (oversample_counter == 4'd9 && baud_tick)\n                    rx_next_state = RX_STOP_1;\n            end\n            \n            RX_STOP_1: begin\n                if (oversample_counter == 4'd9 && baud_tick)\n                    rx_next_state = RX_STOP_2;\n            end\n            \n            RX_STOP_2: begin\n                if (oversample_counter == 4'd9 && baud_tick)\n                    rx_next_state = RX_IDLE;\n            end\n            \n            default: rx_next_state = RX_IDLE;\n        endcase\n    end\n    \n    // Output assignments\n    assign UART_Ready = (tx_state == TX_IDLE);\n    assign UART_Busy = (tx_state != TX_IDLE);\n    assign UART_Error = rx_error_reg;\n    assign data_out = {rx_parity_bit, rx_data_reg};\n\nendmodule\n```\n\nThis UART controller implementation includes:\n\n**Key Features:**\n1. **Configurable baud rate** via parameters\n2. **Full-duplex operation** with separate TX and RX state machines\n3. **Oversampling** (16x) for reliable reception\n4. **Parity support** (even parity) - enabled via bit 8 of data_in\n5. **Two stop bits** as specified\n6. **Error detection** for framing and parity errors\n7. **Majority voting** for RX sampling to improve noise immunity\n\n**Interface Details:**\n- `data_in[8]`: Parity enable bit (1 = enable parity, 0 = disable)\n- `data_in[7:0]`: 8-bit data to transmit\n- `data_out[8]`: Received parity bit\n- `data_out[7:0]`: Received 8-bit data\n- `UART_Ready`: High when ready to accept new transmission\n- `UART_Busy`: High during transmission\n- `UART_Error`: High if framing or parity error detected\n\n**Configuration:**\n- Default: 115200 baud with 100MHz system clock\n- Easily configurable via parameters\n- Supports standard UART frame: Start + 8 Data + Optional Parity + 2 Stop bits\n\nThe design uses proper synchronization, majority voting for noise immunity, and comprehensive error detection suitable for reliable serial communication."
}
