{
    "prompt_0": "protocol and the second tests the binary protocol. The test bench uses a register file model to simulate write and read operations. The following table summarizes the synthesis results of the core for different FPGA families. ManufacturerFamilyDevice Device UtilizationElements UtilizationFmax XilinxSpartan 3xc3s50-5pq208 24.00%186 Slices>150MHz XilinxVirtex 5xc5vlx30-3ff324 2.00%111 Slices>200MHz AlteraCyclone IIIep3c5f256c6 5.00%255 LEs>200MHz AlteraStartix IIIep3sl50f484c2 <1%167 Registers 218 ALUTs>200MHz Lattice1MachXOLCMXO2280C- 4T144C10.00%116 Slices> 100MHz Table 1: Synthesis Results for Different FPGA Devices The above results where obtained using the following software versions: \u2022Xilinx ISE Webpack 11.4 \u2022Altera Quartus Web Edition 9.1sp2 NOTE: The UART to Bus core is not Wishbone compatible although modifying it for Wishbone is probably possible. 1Lattice device synthesis results provided by Paul V. Shatov. Results provided before adding bus request/grant mechanism. UART to Bus Core Specifications Page 4 of 10 February 25, 2012 3.Architecture The UART to Bus architecture is fairly simple. The core is includes a UART interface module, which includes both receive and transmit modules, and the command parser. The following figure depicts a block diagram of the core. Figure 1: UART to Bus Core Block Diagram The UART interface is based on an implementation found in the c16 project in OpenCores (http://www.opencores.org/project,c16 ). The interface includes a UART receive and transmit modules that share a single baud rate generator module. The baud rate is set using two constants defined at the core top module which are calculated as follows: D_BAUD_FREQ=16\u22c5BaudRate gcd\ue09eGlobalClockFreq,16\u2217BaudRate\ue09f D_BAUD_LIMIT=GlobalClockFreq gcd\ue09eGlobalClockFreq,16\u22c5BaudRate\ue09f\u2212D_BAUD_FREQ A short Scilab script which calculates the above parameters is added under the \u201cscilab\u201d directory with the core files. The interface between the \u201cuart_parser.v\u201d module and the \u201cuart_top.v\u201d is very simple and uses only five signals. For cases where the UART interface is not possible or another interface is preferred, the \u201cuart_parser.v\u201d module can be used as is with a different interface implementation. UART to Bus Core Specifications Page 5 of 10 uart_tx.v uart_rx.v baud_gen.vuart_top.v uart_parser.vuart2bus_top.v ser_out ser_inint_address int_wr_data16 8 int_write int_read int_rd_data 8 clock resetint_req int_gntFebruary 25, 2012 4.Operation This section describes the protocols used to access the internal bus from the UART interface. As mentioned above the parser supports two modes of operation: text & binary commands. To distinguish between the two protocols all binary commands start with a value of zero which will not be sent when using the text protocol. The following drawing depicts a simplified state machine of the parser. The figure does not include some transitions used to abort illegal command sequences. Figure 2: Parser State Diagram In the state diagram above the states on the right are used for the text mode protocol and the states on the left are used for the binary mode protocol. The following sub-sections describe each of the protocols. 4.1.Text Mode Protocol The text mode protocol includes only two commands: address read and address write. All values are in HEX format. The parser checks for both upper and lower characters, detects both space (0x20) and tab (0x09) as white spaces and both LF (0x0A) and CR (0x0D) as end of\nUART to Bus Core Specifications Written for publication on: File name: UART to Bus Core Specifications Version: 1.0 Creation Date: February 12, 2010 Update Date: February 25, 2012 Author: Moti Litochevski February 25, 2012 Table of Contents 1. Preface.............................................................................................................................................. 3 1.1. Scope........................................................................................................................................ 3 1.2. Revision History ....................................................................................................................... 3 1.3. Abbreviations........................................................................................................................... 3 2. Introduction...................................................................................................................................... 4 3. Architecture...................................................................................................................................... 5 4. Operation.......................................................................................................................................... 6 4.1. Text Mode Protocol .................................................................................................................. 6 4.2. Binary Mode Protocol .............................................................................................................. 7 5. Core Interfaces................................................................................................................................. 9 6. Test Bench Description .................................................................................................................. 10 Index of Tables Table 1: Synthesis Results for Different FPGA Devices ..................................................................... 4 Table 2: Text Protocol Read Command Format .................................................................................. 7 Table 3: Text Protocol Write Command Format ................................................................................. 7 Table 4: Binary Protocol Command Format ........................................................................................ 8 Table 5: Binary Protocol Return Message Format .............................................................................. 8 Table 6: Core Interfaces Description ................................................................................................... 9 Index of Figures Figure 1: UART to Bus Core Block Diagram ..................................................................................... 5 Figure 2: Parser State Diagram ............................................................................................................ 6 UART to Bus Core Specifications Page 2 of 10 February 25, 2012 1.Preface 1.1.Scope This document describes the UART to Bus IP core operation, architecture and interfaces. 1.2.Revision History RevDateAuthor Description 0.102/13/10Moti Litochevski First Draft 0.204/02/10Moti Litochevski Adding test bench description section 0.304/15/11Moti Litochevski Added Lattice MachXO device utilization provided by Paul V. Shatov. 1.002/25/12Moti Litochevski Updated interface description and synthesis results after adding bus request/grant mechanism. 1.3.Abbreviations UARTUniversal Asynchronous Receiver / Transmitter UART to Bus Core Specifications Page 3 of 10 February 25, 2012 2.Introduction The UART to Bus IP Core is a simple command parser that can be used to access an internal bus via a UART interface. This core can be used during initial board debugging or as a permanent solution when high speed interfaces are not required. The internal bus is designed with address bus of 16 bits and data bus of 8 bits. The core implements a very basic UART transmit & receive blocks which share a common baud rate generator and a command parser. The parser supports two modes of operation: text mode commands and binary mode commands. Text mode commands are designed to be used with a hyper terminal software and enable easy access to the internal bus. Binary mode commands are more efficient and also support buffered read & write operations with or without automatic address increment. The core was verified using Icarus Verilog simulator with two test benches: the first tests the text mode protocol and the second tests the binary protocol. The test bench uses a register file model to simulate write and read operations. The following table summarizes the synthesis results of the core for different FPGA families. ManufacturerFamilyDevice Device UtilizationElements UtilizationFmax XilinxSpartan 3xc3s50-5pq208 24.00%186 Slices>150MHz XilinxVirtex 5xc5vlx30-3ff324 2.00%111 Slices>200MHz AlteraCyclone IIIep3c5f256c6 5.00%255 LEs>200MHz AlteraStartix IIIep3sl50f484c2 <1%167 Registers 218 ALUTs>200MHz Lattice1MachXOLCMXO2280C- 4T144C10.00%116 Slices> 100MHz Table 1: Synthesis Results for Different FPGA Devices The above results where obtained using the following software versions: \u2022Xilinx ISE Webpack 11.4 \u2022Altera Quartus Web Edition 9.1sp2 NOTE: The UART to Bus core is not Wishbone compatible although\nbe written to. int_readoutput1An active high read control signal. This signal shall only be valid for a single clock cycle per address to be read from. int_rd_datainput8Data value read from address. This signal is sampled by the core on the next clock cycle following int_read signal active cycle. int_reqoutput1Internal bus access request signal. The core will assert this signal to request access to the internal bus before every bus access. This signal will be asserted until bus access is granted. int_gntinput1Internal bus grant signal. The core will release the request signal and execute the bus access when this signal is asserted. To disable bus request/grant mechanism set this to logic '1'. Table 6: Core Interfaces Description Note: The port direction in the table above is as defined in the core top module. UART to Bus Core Specifications Page 9 of 10 February 25, 2012 6.Test Bench Description The 'verilog\\bench' directory contains two test benches files and required tasks and modules. Compilation batch files are included in the 'verilog\\sim\\icarus' directory used to simulate the core using Icarus Verilog. The directory inclues two compilation batch files: one for binary mode protocol simulation and the second for text mode protocol simulation. The directory also includes batch file to run the simulation, 'run.bat', and another to call gtkwave to view the simulation VCD output file. Note that for binary mode protocol simulation the test bench reads the commands from 'test.bin' file also included in the directory. The file structure is straight forward and is explained in the respective test bench file. UART to Bus Core Specifications Page 10 of 10\nWrite a SystemVerilog module to implement a UART (Universal Asynchronous Receiver-Transmitter) controller. The module should support configurable baud rates, transmit and receive functionality, and proper start, data, parity (optional), and stop bit handling. The UART should operate in full-duplex mode and adhere to the following interface:\nmodule UART_driver( input  logic       clk,        // System clock input  logic       rst,        // Asynchronous reset input  logic       UART_Start, // Signal to initiate transmission input  logic [7:0] data_in,    // Data to be transmitted input  logic       RX,         // UART receive line output logic       TX,         // UART transmit line output logic [7:0] data_out,   // Received data output logic       UART_Ready, // Ready to transmit next byte output logic       UART_Busy,  // Indicates UART is currently transmitting output logic       UART_Error  // High if framing or parity error detected ); ",
    "answer_0": "Of course. Here is a SystemVerilog implementation of a UART controller based on the provided documentation and standard UART principles.\n\n### **1. Design Analysis and Information Gathering**\n\nBased on the provided document and the module interface, here are the key design parameters I've identified:\n\n*   **Full-Duplex Operation**: The design requires separate transmit (TX) and receive (RX) logic that can operate simultaneously.\n*   **Asynchronous Interface**: The `RX` line is asynchronous to the system clock (`clk`), requiring synchronization to prevent metastability. A standard two-flop synchronizer will be used.\n*   **Configurable Baud Rate**: The document mentions a formula for calculating baud rate divisors based on a 16x oversampling clock. This is a standard technique. I will parameterize the module for a default system clock and baud rate, which can be easily overridden during instantiation.\n*   **Data Frame Format**: The standard UART frame format will be used:\n    *   1 Start Bit (logic '0')\n    *   8 Data Bits (LSB first)\n    *   No Parity Bit (as it was marked optional and not defined in the interface)\n    *   1 Stop Bit (logic '1')\n*   **Control/Status Signals**:\n    *   `UART_Start`: A single-cycle pulse to initiate the transmission of the byte on `data_in`.\n    *   `UART_Busy`: Indicates that the transmitter is currently sending a byte.\n    *   `UART_Ready`: Indicates that the transmitter is idle and ready to accept a new byte for transmission.\n    *   `UART_Error`: Flags a framing error (i.e., the stop bit was not detected as high).\n\n### **2. SystemVerilog Implementation**\n\nThe following SystemVerilog code implements the `UART_driver` module. It is structured with distinct sections for parameters, baud rate generation, receiver logic, and transmitter logic for clarity.\n\n\n```systemverilog\n/**\n * @brief UART (Universal Asynchronous Receiver-Transmitter) Controller\n *\n * This module implements a full-duplex UART controller with configurable baud rates.\n * It handles transmission and reception of 8-bit data frames with one start bit\n * and one stop bit.\n *\n * @param p_SYS_CLK_FREQ System Clock Frequency in Hz (e.g., 50MHz)\n * @param p_BAUD_RATE    Desired Baud Rate (e.g., 9600, 115200)\n */\nmodule UART_driver #(\n    parameter p_SYS_CLK_FREQ = 50_000_000, // Default to 50 MHz\n    parameter p_BAUD_RATE    = 115200      // Default to 115200 baud\n) (\n    input  logic       clk,        // System clock\n    input  logic       rst,        // Asynchronous reset (active high)\n    // Transmitter Interface\n    input  logic       UART_Start, // Signal to initiate transmission\n    input  logic [7:0] data_in,    // Data to be transmitted\n    output logic       TX,         // UART transmit line\n    output logic       UART_Ready, // Ready to transmit next byte\n    output logic       UART_Busy,  // Indicates UART is currently transmitting\n    // Receiver Interface\n    input  logic       RX,         // UART receive line\n    output logic [7:0] data_out,   // Received data\n    output logic       UART_Error  // High if framing or parity error detected\n);\n\n    //--------------------------------------------------------------------------\n    // Internal Parameters and Types\n    //--------------------------------------------------------------------------\n    // Use 16x oversampling for robust bit sampling\n    localparam c_OVERSAMPLE_RATE = 16;\n    localparam c_CLKS_PER_TICK   = p_SYS_CLK_FREQ / (p_BAUD_RATE * c_OVERSAMPLE_RATE);\n    localparam c_SAMPLE_POINT    = c_OVERSAMPLE_RATE / 2;\n\n    // Transmitter State Machine\n    typedef enum logic [1:0] {\n        TX_IDLE,\n        TX_START_BIT,\n        TX_DATA_BITS,\n        TX_STOP_BIT\n    } tx_state_e;\n\n    // Receiver State Machine\n    typedef enum logic [1:0] {\n        RX_IDLE,\n        RX_START_BIT,\n        RX_DATA_BITS,\n        RX_STOP_BIT\n    } rx_state_e;\n\n    //--------------------------------------------------------------------------\n    // Baud Rate Tick Generator\n    //--------------------------------------------------------------------------\n    logic       baud_tick;\n    int unsigned tick_counter = 0;\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tick_counter <= 0;\n            baud_tick    <= 1'b0;\n        end else begin\n            baud_tick <= 1'b0;\n            if (tick_counter == c_CLKS_PER_TICK - 1) begin\n                tick_counter <= 0;\n                baud_tick    <= 1'b1;\n            end else begin\n                tick_counter <= tick_counter + 1;\n            end\n        end\n    end\n\n    //--------------------------------------------------------------------------\n    // Transmitter Logic\n    //--------------------------------------------------------------------------\n    tx_state_e   tx_state_reg, tx_state_next;\n    logic [3:0]  tx_tick_count; // Counts 0-15 for oversampling\n    logic [2:0]  tx_bit_count;  // Counts 0-7 for data bits\n    logic [7:0]  tx_data_reg;   // Latched data for transmission\n\n    // Transmitter sequential logic (registers)\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tx_state_reg <= TX_IDLE;\n            tx_tick_count <= '0;\n            tx_bit_count  <= '0;\n            tx_data_reg   <= '0;\n            TX            <= 1'b1; // UART line is high when idle\n            UART_Busy     <= 1'b0;\n        end else begin\n            tx_state_reg <= tx_state_next;\n            TX           <= TX; // Keep previous value unless changed\n            UART_Busy    <= UART_Busy;\n\n            if (tx_state_next != tx_state_reg) begin // Reset counters on state change\n                tx_tick_count <= '0;\n                tx_bit_count  <= '0;\n            end\n\n            case (tx_state_reg)\n                TX_IDLE: begin\n                    if (UART_Start) begin\n                        tx_data_reg <= data_in;\n                        UART_Busy   <= 1'b1;\n                        TX          <= 1'b0; // Start bit\n                    end\n                end\n                TX_START_BIT: begin\n                    if (baud_tick) begin\n                        if (tx_tick_count == c_OVERSAMPLE_RATE - 1) begin\n                            tx_tick_count <= '0;\n                            TX            <= tx_data_reg[0]; // First data bit\n                        end else begin\n                            tx_tick_count <= tx_tick_count + 1;\n                        end\n                    end\n                end\n                TX_DATA_BITS: begin\n                    if (baud_tick) begin\n                        if (tx_tick_count == c_OVERSAMPLE_RATE - 1) begin\n                            tx_tick_count <= '0;\n                            tx_bit_count  <= tx_bit_count + 1;\n                            if (tx_bit_count == 7) begin\n                                TX <= 1'b1; // Stop bit\n                            end else begin\n                                TX <= tx_data_reg[tx_bit_count + 1];\n                            end\n                        end else begin\n                            tx_tick_count <= tx_tick_count + 1;\n                        end\n                    end\n                end\n                TX_STOP_BIT: begin\n                    if (baud_tick) begin\n                        if (tx_tick_count == c_OVERSAMPLE_RATE - 1) begin\n                            tx_tick_count <= '0;\n                            UART_Busy     <= 1'b0;\n                        end else begin\n                            tx_tick_count <= tx_tick_count + 1;\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Transmitter combinational logic (state transitions)\n    always_comb begin\n        tx_state_next = tx_state_reg;\n        case (tx_state_reg)\n            TX_IDLE:      if (UART_Start) tx_state_next = TX_START_BIT;\n            TX_START_BIT: if (baud_tick && tx_tick_count == c_OVERSAMPLE_RATE - 1) tx_state_next = TX_DATA_BITS;\n            TX_DATA_BITS: if (baud_tick && tx_tick_count == c_OVERSAMPLE_RATE - 1 && tx_bit_count == 7) tx_state_next = TX_STOP_BIT;\n            TX_STOP_BIT:  if (baud_tick && tx_tick_count == c_OVERSAMPLE_RATE - 1) tx_state_next = TX_IDLE;\n        endcase\n    end\n\n    // Transmitter status outputs\n    assign UART_Ready = (tx_state_reg == TX_IDLE);\n\n    //--------------------------------------------------------------------------\n    // Receiver Logic\n    //--------------------------------------------------------------------------\n    rx_state_e   rx_state_reg, rx_state_next;\n    logic [3:0]  rx_tick_count; // Counts 0-15 for oversampling\n    logic [2:0]  rx_bit_count;  // Counts 0-7 for data bits\n    logic [7:0]  rx_data_reg;   // Shift register for incoming data\n    logic        rx_sync1, rx_sync2, rx_sync3; // RX line synchronizer\n\n    // Synchronize asynchronous RX input to system clock to prevent metastability\n    always_ff @(posedge clk) begin\n        rx_sync1 <= RX;\n        rx_sync2 <= rx_sync1;\n        rx_sync3 <= rx_sync2;\n    end\n\n    // Receiver sequential logic (registers)\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_state_reg <= RX_IDLE;\n            rx_tick_count <= '0;\n            rx_bit_count  <= '0;\n            rx_data_reg   <= '0;\n            data_out      <= '0;\n            UART_Error    <= 1'b0;\n        end else begin\n            rx_state_reg <= rx_state_next;\n            data_out     <= data_out; // Latch previous value\n            UART_Error   <= UART_Error; // Latch previous value\n\n            if (rx_state_next != rx_state_reg) begin // Reset counters on state change\n                rx_tick_count <= '0;\n                rx_bit_count  <= '0;\n            end\n\n            case (rx_state_reg)\n                RX_IDLE: begin\n                    UART_Error <= 1'b0; // Clear error on new reception attempt\n                    if (rx_sync2 == 1'b1 && rx_sync3 == 1'b0) begin // Detect falling edge (start)\n                        rx_tick_count <= '0;\n                    end\n                end\n                RX_START_BIT: begin\n                    if (baud_tick) begin\n                        if (rx_tick_count == c_SAMPLE_POINT - 1) begin\n                            if (rx_sync3 == 1'b0) begin // Confirm it's a valid start bit\n                                // Valid start bit, do nothing, wait for next state\n                            end else begin\n                                // Glitch, go back to idle\n                            end\n                        end\n                        rx_tick_count <= rx_tick_count + 1;\n                    end\n                end\n                RX_DATA_BITS: begin\n                    if (baud_tick) begin\n                        if (rx_tick_count == c_SAMPLE_POINT - 1) begin\n                            rx_data_reg[rx_bit_count] <= rx_sync3; // Sample bit\n                        end\n                        if (rx_tick_count == c_OVERSAMPLE_RATE - 1) begin\n                            rx_tick_count <= '0;\n                            rx_bit_count  <= rx_bit_count + 1;\n                        end else begin\n                            rx_tick_count <= rx_tick_count + 1;\n                        end\n                    end\n                end\n                RX_STOP_BIT: begin\n                    if (baud_tick) begin\n                        if (rx_tick_count == c_SAMPLE_POINT - 1) begin\n                            if (rx_sync3 == 1'b0) begin // Framing error if stop bit is not high\n                                UART_Error <= 1'b1;\n                            end else begin\n                                data_out <= rx_data_reg; // Successful reception\n                            end\n                        end\n                        rx_tick_count <= rx_tick_count + 1;\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Receiver combinational logic (state transitions)\n    always_comb begin\n        rx_state_next = rx_state_reg;\n        case (rx_state_reg)\n            RX_IDLE:      if (rx_sync2 == 1'b1 && rx_sync3 == 1'b0) rx_state_next = RX_START_BIT;\n            RX_START_BIT: if (baud_tick && rx_tick_count == c_OVERSAMPLE_RATE - 1) begin\n                            if (rx_sync3 == 1'b0) rx_state_next = RX_DATA_BITS;\n                            else rx_state_next = RX_IDLE; // Glitch, return to idle\n                          end\n            RX_DATA_BITS: if (baud_tick && rx_tick_count == c_OVERSAMPLE_RATE - 1 && rx_bit_count == 7) rx_state_next = RX_STOP_BIT;\n            RX_STOP_BIT:  if (baud_tick && rx_tick_count == c_OVERSAMPLE_RATE - 1) rx_state_next = RX_IDLE;\n        endcase\n    end\n\nendmodule\n```",
    "prompt_1": "protocol and the second tests the binary protocol. The test bench uses a register file model to simulate write and read operations. The following table summarizes the synthesis results of the core for different FPGA families. ManufacturerFamilyDevice Device UtilizationElements UtilizationFmax XilinxSpartan 3xc3s50-5pq208 24.00%186 Slices>150MHz XilinxVirtex 5xc5vlx30-3ff324 2.00%111 Slices>200MHz AlteraCyclone IIIep3c5f256c6 5.00%255 LEs>200MHz AlteraStartix IIIep3sl50f484c2 <1%167 Registers 218 ALUTs>200MHz Lattice1MachXOLCMXO2280C- 4T144C10.00%116 Slices> 100MHz Table 1: Synthesis Results for Different FPGA Devices The above results where obtained using the following software versions: \u2022Xilinx ISE Webpack 11.4 \u2022Altera Quartus Web Edition 9.1sp2 NOTE: The UART to Bus core is not Wishbone compatible although modifying it for Wishbone is probably possible. 1Lattice device synthesis results provided by Paul V. Shatov. Results provided before adding bus request/grant mechanism. UART to Bus Core Specifications Page 4 of 10 February 25, 2012 3.Architecture The UART to Bus architecture is fairly simple. The core is includes a UART interface module, which includes both receive and transmit modules, and the command parser. The following figure depicts a block diagram of the core. Figure 1: UART to Bus Core Block Diagram The UART interface is based on an implementation found in the c16 project in OpenCores (http://www.opencores.org/project,c16 ). The interface includes a UART receive and transmit modules that share a single baud rate generator module. The baud rate is set using two constants defined at the core top module which are calculated as follows: D_BAUD_FREQ=16\u22c5BaudRate gcd\ue09eGlobalClockFreq,16\u2217BaudRate\ue09f D_BAUD_LIMIT=GlobalClockFreq gcd\ue09eGlobalClockFreq,16\u22c5BaudRate\ue09f\u2212D_BAUD_FREQ A short Scilab script which calculates the above parameters is added under the \u201cscilab\u201d directory with the core files. The interface between the \u201cuart_parser.v\u201d module and the \u201cuart_top.v\u201d is very simple and uses only five signals. For cases where the UART interface is not possible or another interface is preferred, the \u201cuart_parser.v\u201d module can be used as is with a different interface implementation. UART to Bus Core Specifications Page 5 of 10 uart_tx.v uart_rx.v baud_gen.vuart_top.v uart_parser.vuart2bus_top.v ser_out ser_inint_address int_wr_data16 8 int_write int_read int_rd_data 8 clock resetint_req int_gntFebruary 25, 2012 4.Operation This section describes the protocols used to access the internal bus from the UART interface. As mentioned above the parser supports two modes of operation: text & binary commands. To distinguish between the two protocols all binary commands start with a value of zero which will not be sent when using the text protocol. The following drawing depicts a simplified state machine of the parser. The figure does not include some transitions used to abort illegal command sequences. Figure 2: Parser State Diagram In the state diagram above the states on the right are used for the text mode protocol and the states on the left are used for the binary mode protocol. The following sub-sections describe each of the protocols. 4.1.Text Mode Protocol The text mode protocol includes only two commands: address read and address write. All values are in HEX format. The parser checks for both upper and lower characters, detects both space (0x20) and tab (0x09) as white spaces and both LF (0x0A) and CR (0x0D) as end of\nUART to Bus Core Specifications Written for publication on: File name: UART to Bus Core Specifications Version: 1.0 Creation Date: February 12, 2010 Update Date: February 25, 2012 Author: Moti Litochevski February 25, 2012 Table of Contents 1. Preface.............................................................................................................................................. 3 1.1. Scope........................................................................................................................................ 3 1.2. Revision History ....................................................................................................................... 3 1.3. Abbreviations........................................................................................................................... 3 2. Introduction...................................................................................................................................... 4 3. Architecture...................................................................................................................................... 5 4. Operation.......................................................................................................................................... 6 4.1. Text Mode Protocol .................................................................................................................. 6 4.2. Binary Mode Protocol .............................................................................................................. 7 5. Core Interfaces................................................................................................................................. 9 6. Test Bench Description .................................................................................................................. 10 Index of Tables Table 1: Synthesis Results for Different FPGA Devices ..................................................................... 4 Table 2: Text Protocol Read Command Format .................................................................................. 7 Table 3: Text Protocol Write Command Format ................................................................................. 7 Table 4: Binary Protocol Command Format ........................................................................................ 8 Table 5: Binary Protocol Return Message Format .............................................................................. 8 Table 6: Core Interfaces Description ................................................................................................... 9 Index of Figures Figure 1: UART to Bus Core Block Diagram ..................................................................................... 5 Figure 2: Parser State Diagram ............................................................................................................ 6 UART to Bus Core Specifications Page 2 of 10 February 25, 2012 1.Preface 1.1.Scope This document describes the UART to Bus IP core operation, architecture and interfaces. 1.2.Revision History RevDateAuthor Description 0.102/13/10Moti Litochevski First Draft 0.204/02/10Moti Litochevski Adding test bench description section 0.304/15/11Moti Litochevski Added Lattice MachXO device utilization provided by Paul V. Shatov. 1.002/25/12Moti Litochevski Updated interface description and synthesis results after adding bus request/grant mechanism. 1.3.Abbreviations UARTUniversal Asynchronous Receiver / Transmitter UART to Bus Core Specifications Page 3 of 10 February 25, 2012 2.Introduction The UART to Bus IP Core is a simple command parser that can be used to access an internal bus via a UART interface. This core can be used during initial board debugging or as a permanent solution when high speed interfaces are not required. The internal bus is designed with address bus of 16 bits and data bus of 8 bits. The core implements a very basic UART transmit & receive blocks which share a common baud rate generator and a command parser. The parser supports two modes of operation: text mode commands and binary mode commands. Text mode commands are designed to be used with a hyper terminal software and enable easy access to the internal bus. Binary mode commands are more efficient and also support buffered read & write operations with or without automatic address increment. The core was verified using Icarus Verilog simulator with two test benches: the first tests the text mode protocol and the second tests the binary protocol. The test bench uses a register file model to simulate write and read operations. The following table summarizes the synthesis results of the core for different FPGA families. ManufacturerFamilyDevice Device UtilizationElements UtilizationFmax XilinxSpartan 3xc3s50-5pq208 24.00%186 Slices>150MHz XilinxVirtex 5xc5vlx30-3ff324 2.00%111 Slices>200MHz AlteraCyclone IIIep3c5f256c6 5.00%255 LEs>200MHz AlteraStartix IIIep3sl50f484c2 <1%167 Registers 218 ALUTs>200MHz Lattice1MachXOLCMXO2280C- 4T144C10.00%116 Slices> 100MHz Table 1: Synthesis Results for Different FPGA Devices The above results where obtained using the following software versions: \u2022Xilinx ISE Webpack 11.4 \u2022Altera Quartus Web Edition 9.1sp2 NOTE: The UART to Bus core is not Wishbone compatible although\nbe written to. int_readoutput1An active high read control signal. This signal shall only be valid for a single clock cycle per address to be read from. int_rd_datainput8Data value read from address. This signal is sampled by the core on the next clock cycle following int_read signal active cycle. int_reqoutput1Internal bus access request signal. The core will assert this signal to request access to the internal bus before every bus access. This signal will be asserted until bus access is granted. int_gntinput1Internal bus grant signal. The core will release the request signal and execute the bus access when this signal is asserted. To disable bus request/grant mechanism set this to logic '1'. Table 6: Core Interfaces Description Note: The port direction in the table above is as defined in the core top module. UART to Bus Core Specifications Page 9 of 10 February 25, 2012 6.Test Bench Description The 'verilog\\bench' directory contains two test benches files and required tasks and modules. Compilation batch files are included in the 'verilog\\sim\\icarus' directory used to simulate the core using Icarus Verilog. The directory inclues two compilation batch files: one for binary mode protocol simulation and the second for text mode protocol simulation. The directory also includes batch file to run the simulation, 'run.bat', and another to call gtkwave to view the simulation VCD output file. Note that for binary mode protocol simulation the test bench reads the commands from 'test.bin' file also included in the directory. The file structure is straight forward and is explained in the respective test bench file. UART to Bus Core Specifications Page 10 of 10\nWrite a SystemVerilog module to implement a UART (Universal Asynchronous Receiver-Transmitter) controller. The module should support configurable baud rates, transmit and receive functionality, and proper start, data, parity (optional), and 2 stop bit handling. The UART should operate in full-duplex mode and adhere to the following interface:\nmodule UART_driver( input  logic       clk,        // System clock input  logic       rst,        // Asynchronous reset input  logic       UART_Start, // Signal to initiate transmission input  logic [8:0] data_in,    // Data to be transmitted input  logic       RX,         // UART receive line output logic       TX,         // UART transmit line output logic [8:0] data_out,   // Received data output logic       UART_Ready, // Ready to transmit next byte output logic       UART_Busy,  // Indicates UART is currently transmitting output logic       UART_Error  // High if framing or parity error detected ); ",
    "answer_1": "Of course. I will write a SystemVerilog module for a UART controller based on your requirements and the provided documentation.\n\n### **1. My Thoughts & Analysis**\n\nBased on the \"UART to Bus Core Specifications\" document you provided and your specific requirements, I've formulated the following plan:\n\n*   **Architecture:** I will adopt the modular architecture described in the document (Figure 1), which separates the design into a baud rate generator, a transmitter (`uart_tx`), and a receiver (`uart_rx`). This makes the design clean, reusable, and easier to understand.\n*   **Baud Rate Generation:** The document specifies a method for baud rate generation using a 16x oversampling clock. This is a standard and robust technique, especially for the receiver, as it allows for more accurate sampling of the incoming asynchronous data stream. I will implement a configurable baud rate generator based on this principle.\n*   **Protocol Framing:** As requested, the UART frame will consist of:\n    *   1 Start Bit (logic '0')\n    *   8 Data Bits (LSB first)\n    *   1 Optional Parity Bit\n    *   2 Stop Bits (logic '1')\n*   **Interface:** I will strictly adhere to the SystemVerilog interface you provided for the top-level `UART_driver` module.\n*   **Configurability:** The module will be made configurable using parameters for the system clock frequency, baud rate, and enabling/disabling parity, making it adaptable to different use cases.\n*   **Error Handling:** The `UART_Error` output will be asserted if the receiver detects a framing error (the first stop bit is not high) or a parity error (if enabled and the calculated parity does not match the received parity bit).\n\n### **2. Findings & Evidence from Provided Text**\n\n*   **Evidence for Modular Design:** Section 3, Figure 1 (\"UART to Bus Core Block Diagram\") clearly shows distinct modules: `uart_tx.v`, `uart_rx.v`, and `baud_gen.v`.\n*   **Evidence for 16x Oversampling:** Section 3, under the block diagram, provides formulas for `D_BAUD_FREQ` and `D_BAUD_LIMIT`. The term `16 * BaudRate` in these formulas is a strong indicator of a 16x oversampling clock scheme used to time the bit periods.\n*   **Evidence for Data Bus Width:** Section 2 (\"Introduction\") mentions the internal bus has a \"data bus of 8 bits,\" which aligns with the standard 8-bit data payload for a UART.\n\n### **3. SystemVerilog Implementation**\n\nHere is the complete SystemVerilog implementation for the `UART_driver` module. It is structured with internal modules for the transmitter and receiver for clarity and good design practice.\n\n\n```systemverilog\n//================================================================\n// Baud Rate Generator\n// Generates a tick at 16x the specified BAUD_RATE\n//================================================================\nmodule baud_gen (\n    input  logic clk,\n    input  logic rst,\n    output logic tick\n);\n    parameter SYS_CLK_FREQ = 50_000_000; // 50 MHz\n    parameter BAUD_RATE    = 9600;\n    parameter OVERSAMPLE   = 16;\n\n    localparam COUNTER_MAX = (SYS_CLK_FREQ / (BAUD_RATE * OVERSAMPLE)) - 1;\n\n    logic [$clog2(COUNTER_MAX)-1:0] counter_reg;\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter_reg <= '0;\n            tick        <= 1'b0;\n        end else begin\n            tick <= 1'b0;\n            if (counter_reg == COUNTER_MAX) begin\n                counter_reg <= '0;\n                tick        <= 1'b1;\n            end else begin\n                counter_reg <= counter_reg + 1;\n            end\n        end\n    end\nendmodule\n\n//================================================================\n// UART Transmitter\n// Handles serialization and transmission of a byte.\n// Frame: 1 start bit, 8 data bits, 1 optional parity, 2 stop bits\n//================================================================\nmodule uart_tx (\n    input  logic       clk,\n    input  logic       rst,\n    input  logic       tx_start,\n    input  logic [8:0] data_in, // data_in[7:0] is data, data_in[8] is parity\n    input  logic       baud_tick,\n    output logic       tx_pin,\n    output logic       tx_ready,\n    output logic       tx_busy\n);\n    parameter PARITY_EN = 1;\n    parameter STOP_BITS = 2;\n    parameter OVERSAMPLE = 16;\n\n    typedef enum logic [2:0] {\n        IDLE,\n        START_BIT,\n        DATA_BITS,\n        PARITY_BIT,\n        STOP_BITS_STATE\n    } tx_state_t;\n\n    tx_state_t state_reg, state_next;\n    logic [8:0] data_reg;\n    logic [$clog2(OVERSAMPLE)-1:0] tick_counter;\n    logic [3:0] bit_counter;\n\n    // State Register\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state_reg <= IDLE;\n        end else begin\n            state_reg <= state_next;\n        end\n    end\n\n    // Next State Logic & Outputs\n    always_comb begin\n        state_next = state_reg;\n        tx_ready = 1'b0;\n        tx_busy = 1'b1;\n        tx_pin = 1'b1; // Default to idle line state\n\n        case (state_reg)\n            IDLE: begin\n                tx_ready = 1'b1;\n                tx_busy = 1'b0;\n                if (tx_start) begin\n                    state_next = START_BIT;\n                end\n            end\n\n            START_BIT: begin\n                tx_pin = 1'b0;\n                if (baud_tick) begin\n                    if (tick_counter == OVERSAMPLE - 1) begin\n                        state_next = DATA_BITS;\n                    end\n                end\n            end\n\n            DATA_BITS: begin\n                tx_pin = data_reg[bit_counter];\n                if (baud_tick) begin\n                    if (tick_counter == OVERSAMPLE - 1) begin\n                        if (bit_counter == 7) begin\n                            state_next = PARITY_EN ? PARITY_BIT : STOP_BITS_STATE;\n                        end else begin\n                            state_next = DATA_BITS;\n                        end\n                    end\n                end\n            end\n\n            PARITY_BIT: begin\n                tx_pin = data_reg[8]; // Transmit parity bit\n                if (baud_tick) begin\n                    if (tick_counter == OVERSAMPLE - 1) begin\n                        state_next = STOP_BITS_STATE;\n                    end\n                end\n            end\n\n            STOP_BITS_STATE: begin\n                tx_pin = 1'b1;\n                if (baud_tick) begin\n                    if (tick_counter == OVERSAMPLE - 1) begin\n                        if (bit_counter == (PARITY_EN ? STOP_BITS : STOP_BITS - 1)) begin\n                           state_next = IDLE;\n                        end\n                    end\n                end\n            end\n            default: state_next = IDLE;\n        endcase\n    end\n\n    // Counters and Data Register\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tick_counter <= '0;\n            bit_counter  <= '0;\n            data_reg     <= '0;\n        end else begin\n            if (state_reg == IDLE && tx_start) begin\n                data_reg <= data_in;\n            end\n\n            if (baud_tick) begin\n                if (tick_counter == OVERSAMPLE - 1) begin\n                    tick_counter <= '0;\n                    if (state_reg == DATA_BITS || (state_reg == STOP_BITS_STATE && bit_counter < (PARITY_EN ? STOP_BITS : STOP_BITS - 1))) begin\n                        bit_counter <= bit_counter + 1;\n                    end else begin\n                        bit_counter <= '0;\n                    end\n                end else begin\n                    tick_counter <= tick_counter + 1;\n                end\n            end\n        end\n    end\nendmodule\n\n//================================================================\n// UART Receiver\n// Handles deserialization of an incoming byte.\n// Frame: 1 start bit, 8 data bits, 1 optional parity, 1 stop bit\n//================================================================\nmodule uart_rx (\n    input  logic       clk,\n    input  logic       rst,\n    input  logic       rx_pin,\n    input  logic       baud_tick,\n    output logic [8:0] data_out,\n    output logic       rx_done,\n    output logic       framing_error,\n    output logic       parity_error\n);\n    parameter PARITY_EN = 1;\n    parameter OVERSAMPLE = 16;\n\n    typedef enum logic [2:0] {\n        IDLE,\n        START_BIT,\n        DATA_BITS,\n        PARITY_BIT,\n        STOP_BIT\n    } rx_state_t;\n\n    rx_state_t state_reg, state_next;\n    logic [8:0] data_reg;\n    logic [$clog2(OVERSAMPLE)-1:0] tick_counter;\n    logic [3:0] bit_counter;\n    logic rx_sync;\n\n    // Synchronize the asynchronous RX input\n    logic rx_dly, rx_dly2;\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_dly  <= 1'b1;\n            rx_dly2 <= 1'b1;\n        end else begin\n            rx_dly  <= rx_pin;\n            rx_dly2 <= rx_dly;\n        end\n    end\n    assign rx_sync = rx_dly2;\n\n    // State Register\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state_reg <= IDLE;\n        end else begin\n            state_reg <= state_next;\n        end\n    end\n\n    // Next State Logic\n    always_comb begin\n        state_next = state_reg;\n        rx_done = 1'b0;\n        framing_error = 1'b0;\n        parity_error = 1'b0;\n\n        case (state_reg)\n            IDLE: begin\n                // Detect falling edge for start bit\n                if (rx_sync == 1'b0) begin\n                    state_next = START_BIT;\n                end\n            end\n\n            START_BIT: begin\n                if (baud_tick) begin\n                    // Sample at middle of start bit\n                    if (tick_counter == (OVERSAMPLE / 2) - 1) begin\n                        if (rx_sync == 1'b0) begin // Valid start bit\n                            state_next = DATA_BITS;\n                        end else begin // Glitch, not a start bit\n                            state_next = IDLE;\n                        end\n                    end\n                end\n            end\n\n            DATA_BITS: begin\n                if (baud_tick) begin\n                    if (tick_counter == OVERSAMPLE - 1) begin\n                        if (bit_counter == 7) begin\n                            state_next = PARITY_EN ? PARITY_BIT : STOP_BIT;\n                        end else begin\n                            state_next = DATA_BITS;\n                        end\n                    end\n                end\n            end\n\n            PARITY_BIT: begin\n                if (baud_tick) begin\n                    if (tick_counter == OVERSAMPLE - 1) begin\n                        state_next = STOP_BIT;\n                    end\n                end\n            end\n\n            STOP_BIT: begin\n                if (baud_tick) begin\n                    if (tick_counter == OVERSAMPLE - 1) begin\n                        if (rx_sync == 1'b0) begin // Framing error if stop bit is not high\n                            framing_error = 1'b1;\n                        end else begin\n                            // Check parity if enabled\n                            if (PARITY_EN && (^data_reg != 1'b0)) begin // Assuming even parity\n                                parity_error = 1'b1;\n                            end\n                        end\n                        rx_done = 1'b1;\n                        state_next = IDLE;\n                    end\n                end\n            end\n            default: state_next = IDLE;\n        endcase\n    end\n\n    // Counters and Data Register\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tick_counter <= '0;\n            bit_counter  <= '0;\n            data_reg     <= '0;\n            data_out     <= '0;\n        end else begin\n            if (state_next == IDLE) begin\n                tick_counter <= '0;\n                bit_counter  <= '0;\n            end else if (baud_tick) begin\n                if (tick_counter == OVERSAMPLE - 1) begin\n                    tick_counter <= '0;\n                    if (state_reg == DATA_BITS || state_reg == PARITY_BIT) begin\n                        bit_counter <= bit_counter + 1;\n                    end\n                end else begin\n                    tick_counter <= tick_counter + 1;\n                end\n            end\n\n            // Shift in data bits at the center of each bit time\n            if (baud_tick && tick_counter == (OVERSAMPLE / 2) - 1) begin\n                if (state_reg == DATA_BITS) begin\n                    data_reg[bit_counter] <= rx_sync;\n                end else if (state_reg == PARITY_BIT) begin\n                    data_reg[8] <= rx_sync;\n                end\n            end\n\n            if (rx_done && !framing_error && !parity_error) begin\n                data_out <= data_reg;\n            end\n        end\n    end\nendmodule\n\n\n//================================================================\n// Top-Level UART Driver\n// Instantiates and connects the TX, RX, and Baud Generator\n//================================================================\nmodule UART_driver(\n    input  logic       clk,        // System clock\n    input  logic       rst,        // Asynchronous reset\n    input  logic       UART_Start, // Signal to initiate transmission\n    input  logic [8:0] data_in,    // Data to be transmitted (data[7:0], parity[8])\n    input  logic       RX,         // UART receive line\n    output logic       TX,         // UART transmit line\n    output logic [8:0] data_out,   // Received data\n    output logic       UART_Ready, // Ready to transmit next byte\n    output logic       UART_Busy,  // Indicates UART is currently transmitting\n    output logic       UART_Error  // High if framing or parity error detected\n);\n    // Parameters for configuration\n    parameter SYS_CLK_FREQ = 50_000_000; // System Clock in Hz (e.g., 50MHz)\n    parameter BAUD_RATE    = 9600;       // Desired Baud Rate\n    parameter PARITY_EN    = 1;          // 1 to enable parity, 0 to disable\n    parameter OVERSAMPLE   = 16;         // Oversampling factor (16 is standard)\n    parameter STOP_BITS    = 2;          // Number of stop bits for transmitter\n\n    // Internal signals\n    logic baud_tick;\n    logic rx_done;\n    logic framing_error;\n    logic parity_error;\n    logic [8:0] data_in_with_parity;\n\n    // Instantiate Baud Rate Generator\n    baud_gen #(\n        .SYS_CLK_FREQ(SYS_CLK_FREQ),\n        .BAUD_RATE(BAUD_RATE),\n        .OVERSAMPLE(OVERSAMPLE)\n    ) i_baud_gen (\n        .clk(clk),\n        .rst(rst),\n        .tick(baud_tick)\n    );\n\n    // Calculate parity for outgoing data if enabled\n    // Assumes even parity: XOR of all data bits + parity bit should be 0.\n    // So, the parity bit is the XOR of all data bits.\n    assign data_in_with_parity = PARITY_EN ? {^data_in[7:0], data_in[7:0]} : data_in;\n\n    // Instantiate UART Transmitter\n    uart_tx #(\n        .PARITY_EN(PARITY_EN),\n        .STOP_BITS(STOP_BITS),\n        .OVERSAMPLE(OVERSAMPLE)\n    ) i_uart_tx (\n        .clk(clk),\n        .rst(rst),\n        .tx_start(UART_Start),\n        .data_in(data_in_with_parity),\n        .baud_tick(baud_tick),\n        .tx_pin(TX),\n        .tx_ready(UART_Ready),\n        .tx_busy(UART_Busy)\n    );\n\n    // Instantiate UART Receiver\n    uart_rx #(\n        .PARITY_EN(PARITY_EN),\n        .OVERSAMPLE(OVERSAMPLE)\n    ) i_uart_rx (\n        .clk(clk),\n        .rst(rst),\n        .rx_pin(RX),\n        .baud_tick(baud_tick),\n        .data_out(data_out),\n        .rx_done(rx_done),\n        .framing_error(framing_error),\n        .parity_error(parity_error)\n    );\n\n    // Combine error signals\n    assign UART_Error = framing_error | parity_error;\n\nendmodule\n```\ninvalid decimal literal (<string>, line 4)\nTraceback (most recent call last):\n  File \"/usr/bin/entry/entry_point\", line 109, in _run_python\n    exec(code, exec_scope)  # pylint: disable=exec-used\n    ^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 4\n    // Generates a tick at 16x the specified BAUD_RATE\n                            ^\nSyntaxError: invalid decimal literal\n\nMy apologies, it appears the execution environment incorrectly tried to run the SystemVerilog code as Python. SystemVerilog is a hardware description language and cannot be executed in a Python interpreter.\n\nI will present the code again in the correct format.\n\n### **1. My Thoughts & Analysis**\n\nBased on the \"UART to Bus Core Specifications\" document you provided and your specific requirements, I've formulated the following plan:\n\n*   **Architecture:** I will adopt the modular architecture described in the document (Figure 1), which separates the design into a baud rate generator, a transmitter (`uart_tx`), and a receiver (`uart_rx`). This makes the design clean, reusable, and easier to understand.\n*   **Baud Rate Generation:** The document specifies a method for baud rate generation using a 16x oversampling clock. This is a standard and robust technique, especially for the receiver, as it allows for more accurate sampling of the incoming asynchronous data stream. I will implement a configurable baud rate generator based on this principle.\n*   **Protocol Framing:** As requested, the UART frame will consist of:\n    *   1 Start Bit (logic '0')\n    *   8 Data Bits (LSB first)\n    *   1 Optional Parity Bit\n    *   2 Stop Bits (logic '1')\n*   **Interface:** I will strictly adhere to the SystemVerilog interface you provided for the top-level `UART_driver` module.\n*   **Configurability:** The module will be made configurable using parameters for the system clock frequency, baud rate, and enabling/disabling parity, making it adaptable to different use cases.\n*   **Error Handling:** The `UART_Error` output will be asserted if the receiver detects a framing error (the first stop bit is not high) or a parity error (if enabled and the calculated parity does not match the received parity bit).\n\n### **2. Findings & Evidence from Provided Text**\n\n*   **Evidence for Modular Design:** Section 3, Figure 1 (\"UART to Bus Core Block Diagram\") clearly shows distinct modules: `uart_tx.v`, `uart_rx.v`, and `baud_gen.v`.\n*   **Evidence for 16x Oversampling:** Section 3, under the block diagram, provides formulas for `D_BAUD_FREQ` and `D_BAUD_LIMIT`. The term `16 * BaudRate` in these formulas is a strong indicator of a 16x oversampling clock scheme used to time the bit periods.\n*   **Evidence for Data Bus Width:** Section 2 (\"Introduction\") mentions the internal bus has a \"data bus of 8 bits,\" which aligns with the standard 8-bit data payload for a UART.\n\n### **3. SystemVerilog Implementation**\n\nHere is the complete SystemVerilog implementation for the `UART_driver` module. It is structured with internal modules for the transmitter and receiver for clarity and good design practice.\n\n\n```systemverilog\n//================================================================\n// Baud Rate Generator\n// Generates a tick at 16x the specified BAUD_RATE\n//================================================================\nmodule baud_gen (\n    input  logic clk,\n    input  logic rst,\n    output logic tick\n);\n    parameter SYS_CLK_FREQ = 50_000_000; // 50 MHz\n    parameter BAUD_RATE    = 9600;\n    parameter OVERSAMPLE   = 16;\n\n    localparam COUNTER_MAX = (SYS_CLK_FREQ / (BAUD_RATE * OVERSAMPLE)) - 1;\n\n    logic [$clog2(COUNTER_MAX)-1:0] counter_reg;\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            counter_reg <= '0;\n            tick        <= 1'b0;\n        end else begin\n            tick <= 1'b0;\n            if (counter_reg == COUNTER_MAX) begin\n                counter_reg <= '0;\n                tick        <= 1'b1;\n            end else begin\n                counter_reg <= counter_reg + 1;\n            end\n        end\n    end\nendmodule\n\n//================================================================\n// UART Transmitter\n// Handles serialization and transmission of a byte.\n// Frame: 1 start bit, 8 data bits, 1 optional parity, 2 stop bits\n//================================================================\nmodule uart_tx (\n    input  logic       clk,\n    input  logic       rst,\n    input  logic       tx_start,\n    input  logic [8:0] data_in, // data_in[7:0] is data, data_in[8] is parity\n    input  logic       baud_tick,\n    output logic       tx_pin,\n    output logic       tx_ready,\n    output logic       tx_busy\n);\n    parameter PARITY_EN = 1;\n    parameter STOP_BITS = 2;\n    parameter OVERSAMPLE = 16;\n\n    typedef enum logic [2:0] {\n        IDLE,\n        START_BIT,\n        DATA_BITS,\n        PARITY_BIT,\n        STOP_BITS_STATE\n    } tx_state_t;\n\n    tx_state_t state_reg, state_next;\n    logic [8:0] data_reg;\n    logic [$clog2(OVERSAMPLE)-1:0] tick_counter;\n    logic [3:0] bit_counter;\n\n    // State Register\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state_reg <= IDLE;\n        end else begin\n            state_reg <= state_next;\n        end\n    end\n\n    // Next State Logic & Outputs\n    always_comb begin\n        state_next = state_reg;\n        tx_ready = 1'b0;\n        tx_busy = 1'b1;\n        tx_pin = 1'b1; // Default to idle line state\n\n        case (state_reg)\n            IDLE: begin\n                tx_ready = 1'b1;\n                tx_busy = 1'b0;\n                if (tx_start) begin\n                    state_next = START_BIT;\n                end\n            end\n\n            START_BIT: begin\n                tx_pin = 1'b0;\n                if (baud_tick) begin\n                    if (tick_counter == OVERSAMPLE - 1) begin\n                        state_next = DATA_BITS;\n                    end\n                end\n            end\n\n            DATA_BITS: begin\n                tx_pin = data_reg[bit_counter];\n                if (baud_tick) begin\n                    if (tick_counter == OVERSAMPLE - 1) begin\n                        if (bit_counter == 7) begin\n                            state_next = PARITY_EN ? PARITY_BIT : STOP_BITS_STATE;\n                        end else begin\n                            state_next = DATA_BITS;\n                        end\n                    end\n                end\n            end\n\n            PARITY_BIT: begin\n                tx_pin = data_reg[8]; // Transmit parity bit\n                if (baud_tick) begin\n                    if (tick_counter == OVERSAMPLE - 1) begin\n                        state_next = STOP_BITS_STATE;\n                    end\n                end\n            end\n\n            STOP_BITS_STATE: begin\n                tx_pin = 1'b1;\n                if (baud_tick) begin\n                    if (tick_counter == OVERSAMPLE - 1) begin\n                        // The number of stop bits to count depends on whether parity was sent\n                        if (bit_counter == (STOP_BITS - 1)) begin\n                           state_next = IDLE;\n                        end\n                    end\n                end\n            end\n            default: state_next = IDLE;\n        endcase\n    end\n\n    // Counters and Data Register\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tick_counter <= '0;\n            bit_counter  <= '0;\n            data_reg     <= '0;\n        end else begin\n            if (state_reg == IDLE && tx_start) begin\n                data_reg <= data_in;\n            end\n\n            if (baud_tick) begin\n                if (tick_counter == OVERSAMPLE - 1) begin\n                    tick_counter <= '0;\n                    // Increment bit counter for data and stop bits\n                    if (state_reg == DATA_BITS || (state_reg == STOP_BITS_STATE && bit_counter < (STOP_BITS - 1))) begin\n                        bit_counter <= bit_counter + 1;\n                    end else begin\n                        bit_counter <= '0;\n                    end\n                end else begin\n                    tick_counter <= tick_counter + 1;\n                end\n            end\n        end\n    end\nendmodule\n\n//================================================================\n// UART Receiver\n// Handles deserialization of an incoming byte.\n// Frame: 1 start bit, 8 data bits, 1 optional parity, 1 stop bit\n//================================================================\nmodule uart_rx (\n    input  logic       clk,\n    input  logic       rst,\n    input  logic       rx_pin,\n    input  logic       baud_tick,\n    output logic [8:0] data_out,\n    output logic       rx_done,\n    output logic       framing_error,\n    output logic       parity_error\n);\n    parameter PARITY_EN = 1;\n    parameter OVERSAMPLE = 16;\n\n    typedef enum logic [2:0] {\n        IDLE,\n        START_BIT,\n        DATA_BITS,\n        PARITY_BIT,\n        STOP_BIT\n    } rx_state_t;\n\n    rx_state_t state_reg, state_next;\n    logic [8:0] data_reg;\n    logic [$clog2(OVERSAMPLE)-1:0] tick_counter;\n    logic [3:0] bit_counter;\n    logic rx_sync;\n\n    // Synchronize the asynchronous RX input\n    logic rx_dly, rx_dly2;\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_dly  <= 1'b1;\n            rx_dly2 <= 1'b1;\n        end else begin\n            rx_dly  <= rx_pin;\n            rx_dly2 <= rx_dly;\n        end\n    end\n    assign rx_sync = rx_dly2;\n\n    // State Register\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state_reg <= IDLE;\n        end else begin\n            state_reg <= state_next;\n        end\n    end\n\n    // Next State Logic\n    always_comb begin\n        state_next = state_reg;\n        rx_done = 1'b0;\n        framing_error = 1'b0;\n        parity_error = 1'b0;\n\n        case (state_reg)\n            IDLE: begin\n                // Detect falling edge for start bit\n                if (rx_sync == 1'b0) begin\n                    state_next = START_BIT;\n                end\n            end\n\n            START_BIT: begin\n                if (baud_tick) begin\n                    // Sample at middle of start bit\n                    if (tick_counter == (OVERSAMPLE / 2) - 1) begin\n                        if (rx_sync == 1'b0) begin // Valid start bit\n                            state_next = DATA_BITS;\n                        end else begin // Glitch, not a start bit\n                            state_next = IDLE;\n                        end\n                    end\n                end\n            end\n\n            DATA_BITS: begin\n                if (baud_tick) {\n                    if (tick_counter == OVERSAMPLE - 1) begin\n                        if (bit_counter == 7) begin\n                            state_next = PARITY_EN ? PARITY_BIT : STOP_BIT;\n                        end else begin\n                            state_next = DATA_BITS;\n                        end\n                    end\n                }\n            end\n\n            PARITY_BIT: begin\n                if (baud_tick) {\n                    if (tick_counter == OVERSAMPLE - 1) begin\n                        state_next = STOP_BIT;\n                    end\n                }\n            end\n\n            STOP_BIT: begin\n                if (baud_tick) {\n                    if (tick_counter == OVERSAMPLE - 1) begin\n                        if (rx_sync == 1'b0) begin // Framing error if stop bit is not high\n                            framing_error = 1'b1;\n                        end else begin\n                            // Check parity if enabled (assuming even parity)\n                            if (PARITY_EN && (^data_reg != 1'b0)) begin\n                                parity_error = 1'b1;\n                            end\n                        end\n                        rx_done = 1'b1;\n                        state_next = IDLE;\n                    end\n                }\n            end\n            default: state_next = IDLE;\n        endcase\n    end\n\n    // Counters and Data Register\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tick_counter <= '0;\n            bit_counter  <= '0;\n            data_reg     <= '0;\n            data_out     <= '0;\n        end else begin\n            if (state_next == IDLE) begin\n                tick_counter <= '0;\n                bit_counter  <= '0;\n            end else if (baud_tick) begin\n                if (tick_counter == OVERSAMPLE - 1) begin\n                    tick_counter <= '0;\n                    if (state_reg == DATA_BITS || state_reg == PARITY_BIT) begin\n                        bit_counter <= bit_counter + 1;\n                    end\n                end else begin\n                    tick_counter <= tick_counter + 1;\n                end\n            end\n\n            // Shift in data bits at the center of each bit time\n            if (baud_tick && tick_counter == (OVERSAMPLE / 2) - 1) begin\n                if (state_reg == DATA_BITS) begin\n                    data_reg[bit_counter] <= rx_sync;\n                end else if (state_reg == PARITY_BIT) begin\n                    data_reg[8] <= rx_sync;\n                end\n            end\n\n            if (rx_done && !framing_error && !parity_error) begin\n                data_out <= data_reg;\n            end\n        end\n    end\nendmodule\n\n\n//================================================================\n// Top-Level UART Driver\n// Instantiates and connects the TX, RX, and Baud Generator\n//================================================================\nmodule UART_driver(\n    input  logic       clk,        // System clock\n    input  logic       rst,        // Asynchronous reset\n    input  logic       UART_Start, // Signal to initiate transmission\n    input  logic [8:0] data_in,    // Data to be transmitted (data[7:0], parity[8])\n    input  logic       RX,         // UART receive line\n    output logic       TX,         // UART transmit line\n    output logic [8:0] data_out,   // Received data\n    output logic       UART_Ready, // Ready to transmit next byte\n    output logic       UART_Busy,  // Indicates UART is currently transmitting\n    output logic       UART_Error  // High if framing or parity error detected\n);\n    // Parameters for configuration\n    parameter SYS_CLK_FREQ = 50_000_000; // System Clock in Hz (e.g., 50MHz)\n    parameter BAUD_RATE    = 9600;       // Desired Baud Rate\n    parameter PARITY_EN    = 1;          // 1 to enable parity, 0 to disable\n    parameter OVERSAMPLE   = 16;         // Oversampling factor (16 is standard)\n    parameter STOP_BITS    = 2;          // Number of stop bits for transmitter\n\n    // Internal signals\n    logic baud_tick;\n    logic rx_done;\n    logic framing_error;\n    logic parity_error;\n    logic [8:0] data_in_with_parity;\n\n    // Instantiate Baud Rate Generator\n    baud_gen #(\n        .SYS_CLK_FREQ(SYS_CLK_FREQ),\n        .BAUD_RATE(BAUD_RATE),\n        .OVERSAMPLE(OVERSAMPLE)\n    ) i_baud_gen (\n        .clk(clk),\n        .rst(rst),\n        .tick(baud_tick)\n    );\n\n    // Calculate parity for outgoing data if enabled.\n    // Assumes even parity: XOR of all data bits + parity bit should be 0.\n    // So, the parity bit is the XOR of all data bits.\n    // If parity is disabled, the 9th bit of data_in is ignored.\n    assign data_in_with_parity = PARITY_EN ? {^data_in[7:0], data_in[7:0]} : data_in;\n\n    // Instantiate UART Transmitter\n    uart_tx #(\n        .PARITY_EN(PARITY_EN),\n        .STOP_BITS(STOP_BITS),\n        .OVERSAMPLE(OVERSAMPLE)\n    ) i_uart_tx (\n        .clk(clk),\n        .rst(rst),\n        .tx_start(UART_Start),\n        .data_in(data_in_with_parity),\n        .baud_tick(baud_tick),\n        .tx_pin(TX),\n        .tx_ready(UART_Ready),\n        .tx_busy(UART_Busy)\n    );\n\n    // Instantiate UART Receiver\n    uart_rx #(\n        .PARITY_EN(PARITY_EN),\n        .OVERSAMPLE(OVERSAMPLE)\n    ) i_uart_rx (\n        .clk(clk),\n        .rst(rst),\n        .rx_pin(RX),\n        .baud_tick(baud_tick),\n        .data_out(data_out),\n        .rx_done(rx_done),\n        .framing_error(framing_error),\n        .parity_error(parity_error)\n    );\n\n    // Combine error signals\n    assign UART_Error = framing_error | parity_error;\n\nendmodule\n```"
}
