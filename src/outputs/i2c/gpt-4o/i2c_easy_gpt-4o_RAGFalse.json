{
    "prompt_0": " Write a SystemVerilog module to implement an I2C master controller. The controller should generate proper start and stop conditions, handle data transfers with acknowledgments, and support both write and read operations. The design must include a clock divider to produce the appropriate I2C SCL frequency. The I2C module should have the following interface:\nmodule I2C_driver( input  logic       clk,         // System clock input  logic       rst,         // Asynchronous reset input  logic       I2C_Start,   // Initiate a transaction when high input  logic       RW,          // Read/Write control: 0 for write, 1 for read input  logic [6:0] slave_addr,  // 7-bit I2C slave address input  logic [7:0] data_in,     // Data to be written (for write transactions) inout  logic       I2C_SDA,     // I2C data line (bidirectional) output logic       I2C_SCL,     // I2C clock line output logic [7:0] data_out,    // Data received from slave (for read transactions) output logic       I2C_En,      // Module enable signal (active during transaction) output logic       busy         // Indicates the module is busy with a transaction ); The I2C master controller should operate as follows: Start Condition: When I2C_Start is asserted, generate a start condition on the I2C bus. Addressing: Transmit the 7-bit slave address along with a R/W bit. Data Transfer: For write transactions (RW = 0), send the provided data (data_in) and handle the ACK from the slave. For read transactions (RW = 1), read the data from the slave and output it on data_out while sending the necessary ACK/NACK. Stop Condition: After the data transfer, generate a stop condition on the bus. Clock Generation: Use a clock divider to derive the I2C SCL frequency from the system clock. Control Signals: The module should assert busy during active transactions and deassert it once the transaction is complete. Design your code with clear state machine implementation, proper handling of bidirectional signals (I2C_SDA), and ensure that all I2C protocol timing requirements are met.\n",
    "answer_0": "Certainly! Here's a simple implementation of an I2C master controller in SystemVerilog following your specifications with a state machine approach. This module handles I2C start/stop conditions, data transfers, read/write operations, and clock division for generating the SCL signal.\n\n```systemverilog\nmodule I2C_driver(\n    input  logic       clk,        // System clock\n    input  logic       rst,        // Asynchronous reset\n    input  logic       I2C_Start,  // Start signal\n    input  logic       RW,         // Read/Write Control\n    input  logic [6:0] slave_addr, // Slave address\n    input  logic [7:0] data_in,    // Input data for writing\n    inout  logic       I2C_SDA,    // Bidirectional data line\n    output logic       I2C_SCL,    // Clock line for I2C\n    output logic [7:0] data_out,   // Output data from reading\n    output logic       I2C_En,     // Enable signal\n    output logic       busy        // Busy signal\n);\n\n    typedef enum logic [2:0] {\n        IDLE,\n        START,\n        ADDR,\n        DATA,\n        RECEIVE,\n        STOP\n    } state_t;\n\n    state_t state, next_state;\n    logic [15:0] clk_div_counter;\n    logic scl_enable;\n    logic sda_dir;   // 0: input, 1: output\n    logic [3:0] bit_count;\n    logic ack_check;\n\n    // Parameters\n    parameter CLK_DIV = 1000; // Adjust this to set the SCL frequency\n\n    // Clock Divider for I2C SCL generation\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            clk_div_counter <= 0;\n            I2C_SCL <= 1;\n        end else begin\n            if (clk_div_counter == CLK_DIV) begin\n                clk_div_counter <= 0;\n                I2C_SCL <= ~I2C_SCL;\n            end else begin\n                clk_div_counter <= clk_div_counter + 1;\n            end\n        end\n    end\n\n    // State machine for I2C control\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            busy <= 0;\n            I2C_SDA <= 1'bz;\n            sda_dir <= 1;\n            bit_count <= 0;\n        end else begin\n            state <= next_state;\n            if (state != IDLE) busy <= 1;\n            else busy <= 0;\n        end\n    end\n\n    // Next state logic\n    always_comb begin\n        next_state = state; // Default to stay in the same state\n        case (state)\n            IDLE: begin\n                I2C_En = 0;\n                if (I2C_Start) begin\n                    next_state = START;\n                    sda_dir = 1; // Set SDA to output\n                end\n            end\n\n            START: begin\n                I2C_En = 1;\n                if (clk_div_counter == 0) begin\n                    I2C_SDA = 0; // Start condition\n                    next_state = ADDR;\n                end\n            end\n\n            ADDR: begin\n                I2C_En = 1;\n                if (clk_div_counter == 0) begin\n                    if (bit_count < 7) begin\n                        I2C_SDA = slave_addr[6 - bit_count];\n                        bit_count = bit_count + 1;\n                    end else begin\n                        I2C_SDA = RW;\n                        bit_count = 0;\n                        next_state = DATA;\n                    end\n                end\n            end\n\n            DATA: begin\n                I2C_En = 1;\n                if (clk_div_counter == 0) begin\n                    if (RW == 0) begin\n                        if (bit_count < 8) begin\n                            I2C_SDA = data_in[7-bit_count];\n                            bit_count = bit_count + 1;\n                        end else begin\n                            sda_dir = 0; // Switch to input for ACK\n                            ack_check = I2C_SDA;\n                            bit_count = 0;\n                            next_state = STOP;\n                        end\n                    end else begin\n                        sda_dir = 0; // Switch to input for reading\n                        next_state = RECEIVE;\n                    end\n                end\n            end\n\n            RECEIVE: begin\n                I2C_En = 1;\n                if (clk_div_counter == 0) begin\n                    if (bit_count < 8) begin\n                        data_out[7-bit_count] = I2C_SDA;\n                        bit_count = bit_count + 1;\n                    end else begin\n                        sda_dir = 1; // Switch to output for NACK\n                        I2C_SDA = 1; // NACK\n                        next_state = STOP;\n                    end\n                end\n            end\n\n            STOP: begin\n                I2C_En = 1;\n                if (clk_div_counter == 0) begin\n                    I2C_SDA = 0;\n                end else if (clk_div_counter == CLK_DIV/2) begin\n                    I2C_SDA = 1;\n                    next_state = IDLE;\n                end\n            end\n        endcase\n    end\n\n    // Bidirectional I2C SDA handling\n    assign I2C_SDA = (sda_dir ? 1'bz : I2C_SDA);\n\nendmodule\n```\n\n### Explanation:\n\n1. **State Machine**: The module uses a state machine to handle the sequence of operations: IDLE, START, ADDR (address phase), DATA (for reading/writing data), RECEIVE (reading data from the slave), and STOP (end the transaction).\n\n2. **Clock Divider**: `clk_div_counter` generates the SCL clock based on the system clock, adjusting the frequency appropriate for I2C communication.\n\n3. **Data Direction**: The `sda_dir` signal controls the direction of the I2C_SDA line: 0 for input and 1 for output.\n\n4. **Start and Stop Conditions**: Start and stop conditions are generated as per the I2C protocol.\n\n5. **Acknowledgment**: Handles ACK/NACK from the slave device.\n\nThis code provides a framework that you can adjust depending on the clock frequencies and any additional features required for your specific application.",
    "prompt_1": " Write a SystemVerilog module to implement an I2C master controller. The controller should generate proper start and stop conditions, handle data transfers with acknowledgments, and support both write and read operations. The design must include a clock divider to produce the appropriate I2C SCL frequency. The I2C module should have the following interface:\nmodule I2C_driver( input  logic       clk,         // System clock input  logic       rst,         // Asynchronous reset input  logic       I2C_Start,   // Initiate a transaction when high input  logic       RW,          // Read/Write control: 0 for write, 1 for read input  logic [9:0] slave_addr,  // 10-bit I2C slave address input  logic [7:0] data_in,     // Data to be written (for write transactions) inout  logic       I2C_SDA,     // I2C data line (bidirectional) output logic       I2C_SCL,     // I2C clock line output logic [7:0] data_out,    // Data received from slave (for read transactions) output logic       I2C_En,      // Module enable signal (active during transaction) output logic       busy         // Indicates the module is busy with a transaction ); The I2C master controller should operate as follows: Start Condition: When I2C_Start is asserted, generate a start condition on the I2C bus. Addressing: Transmit the 10-bit slave address along with a R/W bit. Data Transfer: For write transactions (RW = 0), send the provided data (data_in) and handle the ACK from the slave. For read transactions (RW = 1), read the data from the slave and output it on data_out while sending the necessary ACK/NACK. Stop Condition: After the data transfer, generate a stop condition on the bus. Clock Generation: Use a clock divider to derive the I2C SCL frequency from the system clock. Control Signals: The module should assert busy during active transactions and deassert it once the transaction is complete. Design your code with clear state machine implementation, proper handling of bidirectional signals (I2C_SDA), and ensure that all I2C protocol timing requirements are met.\n",
    "answer_1": "```systemverilog\nmodule I2C_driver (\n    input  logic        clk,        // System clock\n    input  logic        rst,        // Asynchronous reset\n    input  logic        I2C_Start,  // Initiate a transaction\n    input  logic        RW,         // Read/Write control: 0 for write, 1 for read\n    input  logic [9:0]  slave_addr, // 10-bit I2C slave address\n    input  logic [7:0]  data_in,    // Data to be written\n    inout  logic        I2C_SDA,    // I2C data line\n    output logic        I2C_SCL,    // I2C clock line\n    output logic [7:0]  data_out,   // Data received from slave\n    output logic        I2C_En,     // Module enable (active during transaction)\n    output logic        busy        // Module busy indicator\n);\n\n    // Parameters for I2C timing\n    parameter SCL_DIV = 250; // Adjust clock divider factor as needed (assuming a specific frequency)\n\n    typedef enum logic [2:0] {\n        IDLE,\n        START,\n        ADDR,\n        DATA,\n        STOP\n    } state_t;\n\n    state_t state, next_state;\n\n    logic [15:0] clk_div_ctr;\n    logic scl_enable;\n    logic [8:0] bit_counter;\n    logic ack_received;\n\n    // Clock divider for I2C SCL generation\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            clk_div_ctr <= 16'd0;\n            scl_enable <= 1'b0;\n        end else if (clk_div_ctr == (SCL_DIV - 1)) begin\n            clk_div_ctr <= 16'd0;\n            scl_enable <= ~scl_enable;\n        end else begin\n            clk_div_ctr <= clk_div_ctr + 1'b1;\n        end\n    end\n\n    assign I2C_SCL = scl_enable; // I2C clock based on divided clock\n\n    // State transition\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            busy <= 1'b0;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // State machine next state logic and output logic\n    always_comb begin\n        // Default signal values\n        busy = 1'b0;\n        I2C_En = 1'b0;\n        case (state)\n            IDLE: begin\n                if (I2C_Start) begin\n                    next_state = START;\n                    busy = 1'b1;\n                end else begin\n                    next_state = IDLE;\n                end\n            end\n\n            START: begin\n                // Generate start condition (SDA goes low while SCL is high)\n                I2C_En = 1'b1;\n                busy = 1'b1;\n                // Transaction initiation\n                next_state = ADDR;\n            end\n\n            ADDR: begin\n                // Transmit slave address with R/W bit\n                // Logic to manage transfer of address\n                I2C_En = 1'b1;\n                busy = 1'b1;\n                // Check for address transmission and ACK\n                if (ack_received) begin\n                    next_state = DATA;\n                end else begin\n                    next_state = ADDR;\n                end\n            end\n\n            DATA: begin\n                // Logic for data transfer\n                I2C_En = 1'b1;\n                busy = 1'b1;\n                // Logic for sending/receiving data\n                if (RW == 1'b0) begin\n                    // Write operation, handle ACK from slave\n                    next_state = STOP;\n                end else if (RW == 1'b1) begin\n                    // Read operation, wait for data from slave\n                    data_out = ack_received ? 8'hXX : data_out; // Your read logic\n                    next_state = STOP;\n                end\n            end\n\n            STOP: begin\n                // Generate stop condition\n                I2C_En = 1'b1;\n                busy = 1'b0;\n                next_state = IDLE;\n            end\n\n        endcase\n    end\n\n    // SDA line control logic\n    // Implement tri-state buffer control for SDA\n    assign I2C_SDA = (I2C_En && (state == ADDR || state == DATA) && RW == 1'b0) ? 1'bz : 1'b0;\n\nendmodule\n```\n\n**Notes**:\n- This is a basic structure for an I2C master controller module that needs further detailed implementation, especially in the `ADDR`, `DATA`, and bidirectional control logic for `SDA`.\n- The `SCL_DIV` parameter sets the clock division for generating the I2C SCL frequency. Modify according to your system clock speed and the desired I2C bus speed.\n- The internal states would require further elaboration for actual signal manipulation to comply with I2C timing and protocol.\n- Ensure to implement appropriate logic for handling `ACK/NACK` conditions and SDA line driving according to the transaction type."
}
