{
    "prompt_0": "a STOP or Repeated START signal. To write data to a slave, store the data to be transmitted in the Transmit Register and set the WR bit. To read data from a slave, set the RD bit. During a transfer the core set the TIP flag, indicating that a Transfer is In Progress. When the transfer is done the TIP flag is reset, the IF flag set and, when enabled, an interrupt generated. The Receive Register contains valid data after the IF flag has been set. The user may issue a new write or read command when the TIP flag is reset. 4.2.4 STOP signal The master can terminate the communication by generating a STOP signal. A STOP signal, usually referred to as the P-bit, is defined as a low-to-high transition of SDA while SCL is at logical \u20181\u2019. OpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 9 of 15 4.3 Arbitration Procedure 4.3.1 Clock Synchronization The I2C bus is a true multimaster bus that allows more than one master to be connected on it. If two or more masters simultaneously try to control the bus, a clock synchronization procedure determines the bus clock. Because of the wired-AND connection of the I 2C signals a high to low transition affects all devices connected to the bus. Therefore a high to low transition on the SCL line causes all concerned devices to count off their low period. Once a device clock has gone low it will hold the SCL line in that state until the clock high state is reached. Due to the wired-AND connection the SCL line will therefore be held low by the device with the longest low period, and held high by the device with the shortest high period. Start counting low period wait stateStart counting high period SCL1 SCL2 SCLMaster1 SCL Master2 SCL wired-AND SCL 4.3.2 Clock Stretching Slave devices can use the clock synchronization mechanism to slow down the transfer bit rate. After the master has driven SCL low, the slave can drive SCL low for the required period and then release it. If the slave\u2019s SCL low period is greater than the master\u2019s SCL low period, the resulting SCL bus signal low period is stretched, thus inserting wait-states. OpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 10 of 15 5 Architecture The I2C core is built around four primary blocks; the Clock Generator, the Byte Command Controller, the Bit Command Controller and the DataIO Shift Register. All other blocks are used for interfacing or for storing temporary values. 5.1 Clock Generator The Clock Generator generates an internal 4*Fscl clock enable signal that triggers all synchronous elements in the Bit Command Controller. It also handles clock stretching needed by some slaves. 5.2 Byte Command Controller The Byte Command Controller handles I2C traffic at the byte level. It takes data from the Command Register and translates it into sequences based on the transmission of a single byte. By setting the START, STOP, and READ bit in the\nbyte has been read the contents are copied into the Receive Register. During a write action, the Transmit Register\u2019s contents are copied into the DataIO Shift Register and are then transmitted onto the SDA line. A B C DOpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 13 of 15 6 Programming examples Example 1 Write 1 byte of data to a slave. Slave address = 0x51 (b\u201d1010001\u201d) Data to write = 0xAC I2C Sequence: 1) generate start command 2) write slave address + write bit 3) receive acknowledge from slave 4) write data 5) receive acknowledge from slave 6) generate stop command Commands: 1) write 0xA2 (address + write bit) to Transmit Register, set STA bit, set WR bit. -- wait for interrupt or TIP flag to negate -- 2) read RxACK bit from Status Register, should be \u20180\u2019. write 0xAC to Transmit register, set STO bit, set WR bit. -- wait for interrupt or TIP flag to negate -- 3) read RxACK bit from Status Register, should be \u20180\u2019. Please note that the time for the Interrupt Service Routine is not shown here. It is assumed that the ISR is much faster then the I2C cycle time, and therefore not visible. Second command sequence First command sequence SDA S Wr ack ack P SCL OpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 14 of 15 Example 2 Read a byte of data from an I2C memory device. Slave address = 0x4E Memory location to read from = 0x20 I2C sequence: 1) generate start signal 2) write slave address + write bit 3) receive acknowledge from slave 4) write memory location 5) receive acknowledge from slave 6) generate repeated start signal 7) write slave address + read bit 8) receive acknowledge from slave 9) read byte from slave 10) write no acknowledge (NACK) to slave, indicating end of transfer 11) generate stop signal Commands: 1) write 0x9C (address + write bit) to Transmit Register, set STA bit, set WR bit. -- wait for interrupt or TIP flag to negate -- 2) read RxACK bit from Status Register, should be \u20180\u2019. write 0x20 to Transmit register, set WR bit. -- wait for interrupt or TIP flag to negate -- 3) read RxACK bit from Status Register, should be \u20180\u2019. write 0x9D (address + read bit) to Transmit Register, set STA bit, set WR bit. -- wait for interrupt or TIP flag to negate -- 4) set RD bit, set ACK to \u20181\u2019 (NACK), set STO bit Please note that the time for the Interrupt Service Routine is not shown here. It is assumed that the ISR is much faster then the I2C cycle time, and therefore not visible. Second command sequence First command sequence SDA S Wr ack ack SCL Fourth command sequence Third command sequence SDA R Rd ack D7 D6 D5 D4 D3 D2 D1 D0 nack P SCL OpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 15 of 15 Appendix A Synthesis results Synthesis tool: Synplify Pro Technology\nCommand Controller, the Bit Command Controller and the DataIO Shift Register. All other blocks are used for interfacing or for storing temporary values. 5.1 Clock Generator The Clock Generator generates an internal 4*Fscl clock enable signal that triggers all synchronous elements in the Bit Command Controller. It also handles clock stretching needed by some slaves. 5.2 Byte Command Controller The Byte Command Controller handles I2C traffic at the byte level. It takes data from the Command Register and translates it into sequences based on the transmission of a single byte. By setting the START, STOP, and READ bit in the Command Register, for example, the Byte Command Controller generates a sequence that results in the SCL SDA Prescale Register clock generator Command Register Status Register Byte Command Controller Bit Command Controller WISHBONE Interface Transmit Register Receive Register DataIO Shift Register Fig. 5.1 Internal structure I2C Master Core OpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 11 of 15 generation of a START signal, the reading of a byte from the slave device, and the generation of a STOP signal. It does this by dividing each byte operation into separate bit-operations, which are then sent to the Bit Command Controller. NoIdle state Read / Write bit set ? Yes START bit set ? Yes START signal state No START generated ? No Yes Read bit set ? Yes READ state Byte Read ? No Yes ACK state WRITE state Byte Written ? No YesNo ACK bit Read Written No YesOpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 12 of 15 5.3 Bit Command Controller The Bit Command Controller handles the actual transmission of data and the generation of the specific levels for START, Repeated START, and STOP signals by controlling the SCL and SDA lines. The Byte Command Controller tells the Bit Command Controller which operation has to be performed. For a single byte read, the Bit Command Controller receives 8 separate read commands. Each bit-operation is divided into 5 pieces (idle and A, B, C, and D), except for a STOP operation which is divided into 4 pieces (idle and A, B, and C). Start SCL SDA Rep Start SCL SDA Stop SCL SDA Write SCL SDA Read SCL SDA 5.4 DataIO Shift Register The DataIO Shift Register contains the data associated with the current transfer. During a read action, data is shifted in from the SDA line. After a byte has been read the contents are copied into the Receive Register. During a write action, the Transmit Register\u2019s contents are copied into the DataIO Shift Register and are then transmitted onto the SDA line. A B C DOpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 13 of 15 6 Programming examples Example 1 Write 1 byte of data to a slave. Slave address = 0x51 (b\u201d1010001\u201d) Data to write = 0xAC I2C Sequence: 1) generate start command 2) write slave address + write bit 3) receive acknowledge from slave 4) write data 5) receive acknowledge from slave 6) generate\n Write a SystemVerilog module to implement an I2C master controller. The controller should generate proper start and stop conditions, handle data transfers with acknowledgments, and support both write and read operations. The design must include a clock divider to produce the appropriate I2C SCL frequency. The I2C module should have the following interface:\nmodule I2C_driver( input  logic       clk,         // System clock input  logic       rst,         // Asynchronous reset input  logic       I2C_Start,   // Initiate a transaction when high input  logic       RW,          // Read/Write control: 0 for write, 1 for read input  logic [6:0] slave_addr,  // 7-bit I2C slave address input  logic [7:0] data_in,     // Data to be written (for write transactions) inout  logic       I2C_SDA,     // I2C data line (bidirectional) output logic       I2C_SCL,     // I2C clock line output logic [7:0] data_out,    // Data received from slave (for read transactions) output logic       I2C_En,      // Module enable signal (active during transaction) output logic       busy         // Indicates the module is busy with a transaction ); The I2C master controller should operate as follows: Start Condition: When I2C_Start is asserted, generate a start condition on the I2C bus. Addressing: Transmit the 7-bit slave address along with a R/W bit. Data Transfer: For write transactions (RW = 0), send the provided data (data_in) and handle the ACK from the slave. For read transactions (RW = 1), read the data from the slave and output it on data_out while sending the necessary ACK/NACK. Stop Condition: After the data transfer, generate a stop condition on the bus. Clock Generation: Use a clock divider to derive the I2C SCL frequency from the system clock. Control Signals: The module should assert busy during active transactions and deassert it once the transaction is complete. Design your code with clear state machine implementation, proper handling of bidirectional signals (I2C_SDA), and ensure that all I2C protocol timing requirements are met.\n",
    "answer_0": "Of course. I will provide a complete SystemVerilog module for an I2C master controller based on your requirements.\n\n### 1. Design Rationale and Strategy\n\nTo implement the I2C master controller, I will employ the following strategy:\n\n*   **State Machine:** The core of the controller will be a Finite State Machine (FSM). This FSM will progress through the various stages of an I2C transaction: Idle, Start, Transmit, Receive Acknowledge, Read, Send Acknowledge, and Stop. This approach ensures that all protocol steps are executed in the correct sequence.\n*   **Clock Generation:** An I2C bus operates at a much lower frequency (e.g., 100kHz Standard-mode) than a typical system clock. I will implement a clock divider to generate a periodic tick (`scl_tick`) that is four times the desired SCL frequency. This \"4x\" clock allows for precise control over the four distinct phases of the SCL clock cycle (low, rising edge, high, falling edge), ensuring that data on the SDA line is stable when SCL is high, as per the I2C specification.\n*   **Bidirectional Data Line (SDA):** The `I2C_SDA` line is bidirectional. To manage this, the module will use an internal output enable signal (`sda_en`).\n    *   When the master needs to **write** data (address, data bit, NACK), `sda_en` will be asserted, and the module will drive the `I2C_SDA` line.\n    *   When the master needs to **read** data (slave's ACK, data bit), `sda_en` will be de-asserted, putting the driver in a high-impedance state (`'z'`) and allowing the module to read the value being driven by the slave device.\n*   **Operation Flow:**\n    1.  The module will remain in an `IDLE` state until the `I2C_Start` signal is asserted.\n    2.  Upon starting, it will latch the input parameters (`slave_addr`, `data_in`, `RW`), assert the `busy` signal, and begin the transaction.\n    3.  It will generate a START condition.\n    4.  It will transmit the 7-bit slave address followed by the R/W bit.\n    5.  It will check for an Acknowledge (ACK) bit from the slave. If a NACK is received, it will terminate the transaction with a STOP condition.\n    6.  Based on the `RW` bit, it will either transmit the `data_in` byte (for a write) or receive a byte into `data_out` (for a read).\n    7.  After a successful read, the master will send a Not-Acknowledge (NACK) to signal the end of the read sequence.\n    8.  Finally, it will generate a STOP condition and return to the `IDLE` state, de-asserting the `busy` signal.\n\n### 2. SystemVerilog Implementation\n\nHere is the SystemVerilog code for the `I2C_driver` module. The code is parameterized for system and I2C clock frequencies, making it adaptable to different environments.\n\n\n```systemverilog\n/**\n * @brief I2C Master Controller\n *\n * This module implements a single-master I2C controller capable of performing\n * single-byte read and write transactions.\n *\n * @param SYS_CLK_FREQ System clock frequency in Hz (e.g., 50MHz)\n * @param SCL_FREQ     Desired I2C SCL clock frequency in Hz (e.g., 100kHz)\n */\nmodule I2C_driver #(\n    parameter SYS_CLK_FREQ = 50_000_000, // 50 MHz System Clock\n    parameter SCL_FREQ     = 100_000    // 100 kHz I2C Clock\n) (\n    // System Interface\n    input  logic       clk,\n    input  logic       rst,\n\n    // User Command Interface\n    input  logic       I2C_Start,\n    input  logic       RW,          // 0 for Write, 1 for Read\n    input  logic [6:0] slave_addr,\n    input  logic [7:0] data_in,\n\n    // I2C Bus Interface\n    inout  logic       I2C_SDA,\n    output logic       I2C_SCL,\n\n    // Status and Data Output\n    output logic [7:0] data_out,\n    output logic       I2C_En,\n    output logic       busy\n);\n\n    // Calculate the division factor for the SCL clock generator.\n    // We create a tick at 4x the SCL frequency to control the 4 phases of the SCL signal.\n    localparam CLK_DIV_COUNT = (SYS_CLK_FREQ / (SCL_FREQ * 4));\n\n    // FSM state definitions\n    typedef enum logic [3:0] {\n        IDLE,\n        START,\n        WRITE_BYTE,\n        READ_BYTE,\n        GET_ACK,\n        SEND_NACK,\n        STOP\n    } fsm_state_t;\n\n    // Internal Registers\n    fsm_state_t state, next_state;\n\n    // Clock generation signals\n    logic [15:0] clk_div_counter;\n    logic        scl_tick;\n\n    // State machine control signals\n    logic [1:0]  phase_ctr;      // Controls 4 phases of SCL clock\n    logic [2:0]  bit_counter;    // Counts bits within a byte transfer\n    logic        ack_in;         // Stores the received ACK bit\n    logic        sent_addr_flag; // Flag to distinguish address ACK from data ACK\n\n    // Latched command and data registers\n    logic [7:0]  tx_buffer;      // Buffer for data to be transmitted (addr+rw, data)\n    logic [7:0]  rx_buffer;      // Buffer for received data\n    logic        cmd_reg;        // Latched RW command\n    logic [6:0]  addr_reg;       // Latched slave address\n    logic [7:0]  data_w_reg;     // Latched write data\n\n    // I2C line control\n    logic        scl_out;\n    logic        sda_out;\n    logic        sda_en;\n\n    // --- 1. Clock Generation ---\n    // Generates a periodic tick (scl_tick) at 4x the SCL frequency.\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            clk_div_counter <= 0;\n            scl_tick <= 0;\n        end else begin\n            if (clk_div_counter >= CLK_DIV_COUNT - 1) begin\n                clk_div_counter <= 0;\n                scl_tick <= 1;\n            end else begin\n                clk_div_counter <= clk_div_counter + 1;\n                scl_tick <= 0;\n            end\n        end\n    end\n\n    // --- 2. State Machine Sequential Logic ---\n    // This block handles state transitions and updates registers on each scl_tick.\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            phase_ctr <= 0;\n            bit_counter <= 7;\n            sent_addr_flag <= 0;\n            // Initialize other registers on reset\n            tx_buffer <= 0;\n            rx_buffer <= 0;\n            cmd_reg <= 0;\n            addr_reg <= 0;\n            data_w_reg <= 0;\n        end else begin\n            if (scl_tick) begin\n                state <= next_state;\n                // Latch inputs only when starting a new transaction from IDLE\n                if (state == IDLE && next_state != IDLE) begin\n                    cmd_reg <= RW;\n                    addr_reg <= slave_addr;\n                    data_w_reg <= data_in;\n                    tx_buffer <= {slave_addr, RW};\n                    sent_addr_flag <= 1; // We are about to send the address\n                    bit_counter <= 7;\n                end\n\n                // Update counters and buffers based on the current state\n                if (state == WRITE_BYTE || state == READ_BYTE) begin\n                    if (phase_ctr == 3) begin // End of an SCL cycle\n                        bit_counter <= bit_counter - 1;\n                    end\n                end\n\n                if (state == READ_BYTE && phase_ctr == 2) begin // SCL is high\n                    rx_buffer[bit_counter] <= I2C_SDA;\n                end\n\n                // Reset bit counter when moving to a new byte operation\n                if ((state == GET_ACK && next_state == WRITE_BYTE) || (state == STOP && next_state == IDLE)) begin\n                    bit_counter <= 7;\n                end\n\n                // Clear the address flag after it has been processed in GET_ACK\n                if (state == GET_ACK) begin\n                    sent_addr_flag <= 0;\n                end\n\n                // Advance the 4-phase SCL clock counter\n                if (state != IDLE) begin\n                    phase_ctr <= phase_ctr + 1;\n                end else begin\n                    phase_ctr <= 0;\n                \nend\n            end\n        end\n    end\n\n    // --- 3. State Machine Combinational Logic ---\n    // This block determines the next state and control signal values based on the current state.\n    always_comb begin\n        next_state = state;\n        scl_out = 1'b1;\n        sda_out = 1'b1;\n        sda_en = 1'b0; // Default to high-impedance (reading)\n        ack_in = I2C_SDA;\n\n        case (state)\n            IDLE: begin\n                scl_out = 1'b1;\n                sda_en = 1'b0; // Release the bus\n                if (I2C_Start) begin\n                    next_state = START;\n                end\n            end\n\n            START: begin\n                // START condition: SDA goes low while SCL is high\n                case (phase_ctr)\n                    0: begin scl_out = 1'b1; sda_out = 1'b1; sda_en = 1'b1; end\n                    1: begin scl_out = 1'b1; sda_out = 1'b0; sda_en = 1'b1; end\n                    2: begin scl_out = 1'b0; sda_out = 1'b0; sda_en = 1'b1; end\n                    default: next_state = WRITE_BYTE;\n                endcase\n            end\n\n            WRITE_BYTE: begin\n                // Transmit one bit per SCL cycle\n                sda_out = tx_buffer[bit_counter];\n                sda_en = 1'b1;\n                case (phase_ctr)\n                    0, 1: scl_out = 1'b0; // Data changes when SCL is low\n                    2, 3: scl_out = 1'b1; // Data stable when SCL is high\n                endcase\n                if (bit_counter == 0 && phase_ctr == 3) begin\n                    next_state = GET_ACK;\n                end\n            end\n\n            GET_ACK: begin\n                // Release SDA and pulse SCL to read the ACK bit\n                sda_en = 1'b0;\n                case (phase_ctr)\n                    0, 1: scl_out = 1'b0;\n                    2:    scl_out = 1'b1; // Slave drives SDA low for ACK\n                    3: begin\n                        scl_out = 1'b0;\n                        if (ack_in == 1'b0) begin // ACK received\n                            if (sent_addr_flag) begin\n                                if (cmd_reg == 1'b1) begin // It was a READ command\n                                    next_state = READ_BYTE;\n                                end else begin // It was a WRITE command\n                                    tx_buffer = data_w_reg; // Load data to transmit\n                                    next_state = WRITE_BYTE;\n                                end\n                            end else begin // Data ACK received, transaction done\n                                next_state = STOP;\n                            end\n                        end else begin // NACK received, terminate\n                            next_state = STOP;\n                        end\n                    end\n                endcase\n            end\n\n            READ_BYTE: begin\n                // Release SDA and generate SCL pulses to receive data\n                sda_en = 1'b0;\n                case (phase_ctr)\n                    0, 1: scl_out = 1'b0;\n                    2, 3: scl_out = 1'b1; // Read SDA when SCL is high\n                endcase\n                if (bit_counter == 0 && phase_ctr == 3) begin\n                    next_state = SEND_NACK;\n                end\n            end\n\n            SEND_NACK: begin\n                // Master sends NACK after reading a byte to signal end of transfer\n                sda_out = 1'b1; // NACK is SDA high\n                sda_en = 1'b1;\n                case (phase_ctr)\n                    0, 1: scl_out = 1'b0;\n                    2:    scl_out = 1'b1;\n                    3:    next_state = STOP;\n                endcase\n            end\n\n            STOP: begin\n                // STOP condition: SDA goes high while SCL is high\n                case (phase_ctr)\n                    0: begin scl_out = 1'b0; sda_out = 1'b0; sda_en = 1'b1; end\n                    1: begin scl_out = 1'b1; sda_out = 1'b0; sda_en = 1'b1; end\n                    2: begin scl_out = 1'b1; sda_out = 1'b1; sda_en = 1'b1; end\n                    default: next_state = IDLE;\n                endcase\n            end\n\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // --- 4. Output Assignments ---\n    assign I2C_SCL = scl_out;\n    assign I2C_SDA = sda_en ? sda_out : 1'bz;\n    assign busy = (state != IDLE);\n    assign I2C_En = busy;\n    assign data_out = rx_buffer;\n\nendmodule\n\n```",
    "prompt_1": "a STOP or Repeated START signal. To write data to a slave, store the data to be transmitted in the Transmit Register and set the WR bit. To read data from a slave, set the RD bit. During a transfer the core set the TIP flag, indicating that a Transfer is In Progress. When the transfer is done the TIP flag is reset, the IF flag set and, when enabled, an interrupt generated. The Receive Register contains valid data after the IF flag has been set. The user may issue a new write or read command when the TIP flag is reset. 4.2.4 STOP signal The master can terminate the communication by generating a STOP signal. A STOP signal, usually referred to as the P-bit, is defined as a low-to-high transition of SDA while SCL is at logical \u20181\u2019. OpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 9 of 15 4.3 Arbitration Procedure 4.3.1 Clock Synchronization The I2C bus is a true multimaster bus that allows more than one master to be connected on it. If two or more masters simultaneously try to control the bus, a clock synchronization procedure determines the bus clock. Because of the wired-AND connection of the I 2C signals a high to low transition affects all devices connected to the bus. Therefore a high to low transition on the SCL line causes all concerned devices to count off their low period. Once a device clock has gone low it will hold the SCL line in that state until the clock high state is reached. Due to the wired-AND connection the SCL line will therefore be held low by the device with the longest low period, and held high by the device with the shortest high period. Start counting low period wait stateStart counting high period SCL1 SCL2 SCLMaster1 SCL Master2 SCL wired-AND SCL 4.3.2 Clock Stretching Slave devices can use the clock synchronization mechanism to slow down the transfer bit rate. After the master has driven SCL low, the slave can drive SCL low for the required period and then release it. If the slave\u2019s SCL low period is greater than the master\u2019s SCL low period, the resulting SCL bus signal low period is stretched, thus inserting wait-states. OpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 10 of 15 5 Architecture The I2C core is built around four primary blocks; the Clock Generator, the Byte Command Controller, the Bit Command Controller and the DataIO Shift Register. All other blocks are used for interfacing or for storing temporary values. 5.1 Clock Generator The Clock Generator generates an internal 4*Fscl clock enable signal that triggers all synchronous elements in the Bit Command Controller. It also handles clock stretching needed by some slaves. 5.2 Byte Command Controller The Byte Command Controller handles I2C traffic at the byte level. It takes data from the Command Register and translates it into sequences based on the transmission of a single byte. By setting the START, STOP, and READ bit in the\nbyte has been read the contents are copied into the Receive Register. During a write action, the Transmit Register\u2019s contents are copied into the DataIO Shift Register and are then transmitted onto the SDA line. A B C DOpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 13 of 15 6 Programming examples Example 1 Write 1 byte of data to a slave. Slave address = 0x51 (b\u201d1010001\u201d) Data to write = 0xAC I2C Sequence: 1) generate start command 2) write slave address + write bit 3) receive acknowledge from slave 4) write data 5) receive acknowledge from slave 6) generate stop command Commands: 1) write 0xA2 (address + write bit) to Transmit Register, set STA bit, set WR bit. -- wait for interrupt or TIP flag to negate -- 2) read RxACK bit from Status Register, should be \u20180\u2019. write 0xAC to Transmit register, set STO bit, set WR bit. -- wait for interrupt or TIP flag to negate -- 3) read RxACK bit from Status Register, should be \u20180\u2019. Please note that the time for the Interrupt Service Routine is not shown here. It is assumed that the ISR is much faster then the I2C cycle time, and therefore not visible. Second command sequence First command sequence SDA S Wr ack ack P SCL OpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 14 of 15 Example 2 Read a byte of data from an I2C memory device. Slave address = 0x4E Memory location to read from = 0x20 I2C sequence: 1) generate start signal 2) write slave address + write bit 3) receive acknowledge from slave 4) write memory location 5) receive acknowledge from slave 6) generate repeated start signal 7) write slave address + read bit 8) receive acknowledge from slave 9) read byte from slave 10) write no acknowledge (NACK) to slave, indicating end of transfer 11) generate stop signal Commands: 1) write 0x9C (address + write bit) to Transmit Register, set STA bit, set WR bit. -- wait for interrupt or TIP flag to negate -- 2) read RxACK bit from Status Register, should be \u20180\u2019. write 0x20 to Transmit register, set WR bit. -- wait for interrupt or TIP flag to negate -- 3) read RxACK bit from Status Register, should be \u20180\u2019. write 0x9D (address + read bit) to Transmit Register, set STA bit, set WR bit. -- wait for interrupt or TIP flag to negate -- 4) set RD bit, set ACK to \u20181\u2019 (NACK), set STO bit Please note that the time for the Interrupt Service Routine is not shown here. It is assumed that the ISR is much faster then the I2C cycle time, and therefore not visible. Second command sequence First command sequence SDA S Wr ack ack SCL Fourth command sequence Third command sequence SDA R Rd ack D7 D6 D5 D4 D3 D2 D1 D0 nack P SCL OpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 15 of 15 Appendix A Synthesis results Synthesis tool: Synplify Pro Technology\nCommand Controller, the Bit Command Controller and the DataIO Shift Register. All other blocks are used for interfacing or for storing temporary values. 5.1 Clock Generator The Clock Generator generates an internal 4*Fscl clock enable signal that triggers all synchronous elements in the Bit Command Controller. It also handles clock stretching needed by some slaves. 5.2 Byte Command Controller The Byte Command Controller handles I2C traffic at the byte level. It takes data from the Command Register and translates it into sequences based on the transmission of a single byte. By setting the START, STOP, and READ bit in the Command Register, for example, the Byte Command Controller generates a sequence that results in the SCL SDA Prescale Register clock generator Command Register Status Register Byte Command Controller Bit Command Controller WISHBONE Interface Transmit Register Receive Register DataIO Shift Register Fig. 5.1 Internal structure I2C Master Core OpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 11 of 15 generation of a START signal, the reading of a byte from the slave device, and the generation of a STOP signal. It does this by dividing each byte operation into separate bit-operations, which are then sent to the Bit Command Controller. NoIdle state Read / Write bit set ? Yes START bit set ? Yes START signal state No START generated ? No Yes Read bit set ? Yes READ state Byte Read ? No Yes ACK state WRITE state Byte Written ? No YesNo ACK bit Read Written No YesOpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 12 of 15 5.3 Bit Command Controller The Bit Command Controller handles the actual transmission of data and the generation of the specific levels for START, Repeated START, and STOP signals by controlling the SCL and SDA lines. The Byte Command Controller tells the Bit Command Controller which operation has to be performed. For a single byte read, the Bit Command Controller receives 8 separate read commands. Each bit-operation is divided into 5 pieces (idle and A, B, C, and D), except for a STOP operation which is divided into 4 pieces (idle and A, B, and C). Start SCL SDA Rep Start SCL SDA Stop SCL SDA Write SCL SDA Read SCL SDA 5.4 DataIO Shift Register The DataIO Shift Register contains the data associated with the current transfer. During a read action, data is shifted in from the SDA line. After a byte has been read the contents are copied into the Receive Register. During a write action, the Transmit Register\u2019s contents are copied into the DataIO Shift Register and are then transmitted onto the SDA line. A B C DOpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 13 of 15 6 Programming examples Example 1 Write 1 byte of data to a slave. Slave address = 0x51 (b\u201d1010001\u201d) Data to write = 0xAC I2C Sequence: 1) generate start command 2) write slave address + write bit 3) receive acknowledge from slave 4) write data 5) receive acknowledge from slave 6) generate\n Write a SystemVerilog module to implement an I2C master controller. The controller should generate proper start and stop conditions, handle data transfers with acknowledgments, and support both write and read operations. The design must include a clock divider to produce the appropriate I2C SCL frequency. The I2C module should have the following interface:\nmodule I2C_driver( input  logic       clk,         // System clock input  logic       rst,         // Asynchronous reset input  logic       I2C_Start,   // Initiate a transaction when high input  logic       RW,          // Read/Write control: 0 for write, 1 for read input  logic [9:0] slave_addr,  // 10-bit I2C slave address input  logic [7:0] data_in,     // Data to be written (for write transactions) inout  logic       I2C_SDA,     // I2C data line (bidirectional) output logic       I2C_SCL,     // I2C clock line output logic [7:0] data_out,    // Data received from slave (for read transactions) output logic       I2C_En,      // Module enable signal (active during transaction) output logic       busy         // Indicates the module is busy with a transaction ); The I2C master controller should operate as follows: Start Condition: When I2C_Start is asserted, generate a start condition on the I2C bus. Addressing: Transmit the 10-bit slave address along with a R/W bit. Data Transfer: For write transactions (RW = 0), send the provided data (data_in) and handle the ACK from the slave. For read transactions (RW = 1), read the data from the slave and output it on data_out while sending the necessary ACK/NACK. Stop Condition: After the data transfer, generate a stop condition on the bus. Clock Generation: Use a clock divider to derive the I2C SCL frequency from the system clock. Control Signals: The module should assert busy during active transactions and deassert it once the transaction is complete. Design your code with clear state machine implementation, proper handling of bidirectional signals (I2C_SDA), and ensure that all I2C protocol timing requirements are met.\n",
    "answer_1": "Of course. Here is a comprehensive solution for the I2C master controller in SystemVerilog, complete with detailed explanations of the design choices and implementation.\n\n### **1. Design Philosophy and Strategy**\n\nTo create a robust and clear I2C master controller, the design is broken down into three main components:\n\n1.  **Clock Generation:** A clock divider generates a core clock signal at four times the desired SCL frequency (e.g., 400kHz for a 100kHz SCL). This provides four distinct phases for each SCL cycle, allowing for precise control over SDA transitions relative to the SCL edges, which is critical for meeting I2C timing requirements.\n\n2.  **Low\n-Level Bit Controller:** This logic uses a simple 2-bit phase counter (`phase_cnt`) that increments on each core clock cycle. It directly manipulates the `I2C_SCL` and `I2C_SDA` lines to perform the fundamental I2C actions:\n    *   **Phase 0:** Drive SCL low.\n    *   **Phase 1:** Change SDA value (for a write) or prepare to release it (for a read).\n    *   **Phase 2:** Drive SCL high. The data on SDA is now valid.\n    *   **Phase 3:** Keep SCL high. Sample SDA (for a read or ACK check).\n\n3.  **High-Level State Machine (FSM):** This is the core of the controller, managing the byte-level sequence of an I2C transaction. It dictates the overall flow, from the START condition, through addressing and data transfer, to the STOP condition. The FSM transitions at the end of each bit transfer (when `phase_cnt` completes a full cycle), making the logic clean and synchronous with the bit-level operations.\n\nThis hierarchical approach ensures that the high-level logic (the FSM) is not cluttered with low-level timing details, making the code easier to understand, debug, and maintain.\n\n### **2. I2C 10-bit Addressing Protocol**\n\nThe design correctly implements the I2C 10-bit addressing scheme, which involves a multi-byte sequence:\n1.  **First Frame (Write):** The master sends a special header `11110xx0`, where `xx` are the two most significant bits (MSBs) of the 10-bit address, followed by a Write bit (0).\n2.  **Second Frame (Write):** After receiving an ACK, the master sends the lower 8 bits of the 10-bit address.\n3.  **Data Transfer:**\n    *   **For a Write Operation:** After the second ACK, the master proceeds to send data bytes.\n    *   **For a Read Operation:** After the second ACK, the master must generate a **Repeated START** condition, followed by the same special header but with the Read bit set (`11110xx1`). After receiving an ACK for this, the master can begin reading data from the slave.\n\n### **3. SystemVerilog Implementation**\n\nHere is the complete SystemVerilog code for the `I2C_driver` module.\n\n\n```systemverilog\n// I2C Master Controller with 10-bit Addressing Support\n//\n// Design Overview:\n// 1. Clock Divider: Generates a core clock (core_clk_en) at 4x the SCL frequency\n//    to create four distinct timing phases for each SCL cycle.\n// 2. Phase Counter: A 2-bit counter (phase_cnt) cycles through the four phases\n//    to control SCL and SDA signals at the bit level.\n// 3. FSM: A high-level state machine manages the byte-level transaction sequence\n//    (START, address, data, ACK, STOP).\n\nmodule I2C_driver #(\n    parameter CLK_FREQ   = 50_000_000, // System clock frequency in Hz\n    parameter SCL_FREQ   = 100_000     // I2C SCL clock frequency in Hz\n) (\n    input  logic       clk,\n    input  logic       rst,\n    input  logic       I2C_Start,\n    input  logic       RW,          // 0 for write, 1 for read\n    input  logic [9:0] slave_addr,\n    input  logic [7:0] data_in,\n    inout  logic       I2C_SDA,\n    output logic       I2C_SCL,\n    output logic [7:0] data_out,\n    output logic       I2C_En,\n    output logic       busy\n);\n\n    // Calculate the division ratio for the core clock\n    localparam CORE_CLK_DIV = (CLK_FREQ / (SCL_FREQ * 4));\n\n    // FSM state definitions\n    typedef enum logic [4:0] {\n        S_IDLE,\n        S_START,\n        S_TX_ADDR1,\n        S_ACK1,\n        S_TX_ADDR2,\n        S_ACK2,\n        S_REP_START,\n        S_TX_ADDR_R,\n        S_ACK_R,\n        S_WRITE_DATA,\n        S_ACK_W,\n        S_READ_DATA,\n        S_SEND_NACK,\n        S_STOP,\n        S_ERROR\n    } state_t;\n\n    state_t state, next_state;\n\n    // Internal registers and signals\n    logic [15:0] core_clk_cnt;\n    logic        core_clk_en;\n    logic [1:0]  phase_cnt;\n    logic [3:0]  bit_cnt;\n\n    logic        scl_reg;\n    logic        sda_reg;\n    logic        sda_en;\n    logic [7:0]  data_shift;\n    logic        ack_in;\n\n    // Latched input registers\n    logic        i_rw;\n    logic [9:0]  i_slave_addr;\n    logic [7:0]  i_data_in;\n\n    //--------------------------------------------------------------------------\n    // 1. Clock Generation Logic\n    //--------------------------------------------------------------------------\n    // Generate a core clock enable pulse at 4x SCL frequency\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            core_clk_cnt <= '0;\n            core_clk_en  <= 1'b0;\n        end else begin\n            core_clk_en <= 1'b0;\n            if (core_clk_cnt == CORE_CLK_DIV - 1) begin\n                core_clk_cnt <= '0;\n                core_clk_en  <= 1'b1;\n            end else begin\n                core_clk_cnt <= core_clk_cnt + 1;\n            end\n        end\n    end\n\n    //--------------------------------------------------------------------------\n    // 2. Low-Level Bit Controller (Phase Counter)\n    //--------------------------------------------------------------------------\n    // This counter creates the four phases for each bit transfer\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            phase_cnt <= '0;\n        end else if (core_clk_en) begin\n            if (state == S_IDLE) begin\n                phase_cnt <= '0;\n            end else begin\n                phase_cnt <= phase_cnt + 1;\n            end\n        end\n    end\n\n    //--------------------------------------------------------------------------\n    // 3. High-Level FSM and Datapath Logic\n    //--------------------------------------------------------------------------\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state        <= S_IDLE;\n            bit_cnt      <= '0;\n            data_shift   <= '0;\n            ack_in       <= 1'b1;\n            i_rw         <= '0;\n            i_slave_addr <= '0;\n            i_data_in    <= '0;\n        end else begin\n            // Latch inputs at the beginning of a transaction\n            if (I2C_Start && state == S_IDLE) begin\n                i_rw         <= RW;\n                i_slave_addr <= slave_addr;\n                i_data_in    <= data_in;\n            end\n\n            if (core_clk_en) begin\n                // FSM state transitions happen at the end of a bit cycle (phase 3)\n                if (phase_cnt == 3) begin\n                    state <= next_state;\n                end\n\n                // Update counters and shift registers based on the next state\n                if (phase_cnt == 3) begin // End of bit cycle\n                    case (next_state)\n                        S_TX_ADDR1, S_TX_ADDR2, S_TX_ADDR_R, S_WRITE_DATA: begin\n                            if (state != next_state) bit_cnt <= 4'd7; // Start of a new byte transfer\n                            else bit_cnt <= bit_cnt - 1;\n                            data_shift <= data_shift << 1;\n                        end\n                        S_READ_DATA: begin\n                            if (state != next_state) bit_cnt <= 4'd7;\n                            else bit_cnt <= bit_cnt - 1;\n                            data_shift <= {data_shift[6:0], I2C_SDA}; // Shift in received bit\n                        end\n                        default: begin\n                            bit_cnt <= '0;\n                        end\n                    endcase\n                end\n                \n                // Latch ACK value from slave\n                if (phase_cnt == 2) begin // Sample SDA when SCL is high\n                    case (state)\n                        S_ACK1, S_ACK2, S_ACK_R, S_ACK_W: begin\n                            ack_in <= I2C_SDA;\n                        end\n                    endcase\n                end\n            end\n        end\n    end\n\n    // FSM Combinational Logic (calculates next_state and control signals)\n    always_comb begin\n        next_state = state; // Default: stay in the same state\n\n        // Default control signal values\n        scl_reg  = 1'b1;\n        sda_reg  = 1'b1;\n        sda_en   = 1'b1;\n\n        case (state)\n            S_IDLE: begin\n                scl_reg = 1'b1;\n                sda_reg = 1'b1;\n                sda_en  = 1'b1; // Drive SDA high in idle\n                if (I2C_Start) begin\n                    next_state = S_START;\n                end\n            end\n\n            S_START: begin\n                // START condition: SDA goes low while SCL is high\n                scl_reg = 1'b1;\n                sda_reg = (phase_cnt < 2) ? 1'b1 : 1'b0;\n                if (phase_cnt == 3) begin\n                    next_state = S_TX_ADDR1;\n                    // Load first address byte: 11110 + Addr[9:8] + W(0)\n                    data_shift = {5'b11110, i_slave_addr[9:8], 1'b0};\n                end\n            end\n\n            S_TX_ADDR1, S_TX_ADDR2, S_TX_ADDR_R, S_WRITE_DATA: begin\n                // Transmit one bit per 4 phases\n                scl_reg = phase_cnt[1]; // SCL is high for phases 2 and 3\n                sda_reg = data_shift[7];\n                sda_en  = 1'b1;\n                if (phase_cnt == 3 && bit_cnt == 0) begin\n                    case(state)\n                        S_TX_ADDR1:   next_state = S_ACK1;\n                        S_TX_ADDR2:   next_state = S_ACK2;\n                        S_TX_ADDR_R:  next_state = S_ACK_R;\n                        S_WRITE_DATA: next_state = S_ACK_W;\n                    endcase\n                end\n            end\n\n            S_ACK1, S_ACK2, S_ACK_R, S_ACK_W: begin\n                // Check for ACK from slave\n                scl_reg = phase_cnt[1];\n                sda_en  = 1'b0; // Release SDA for slave to drive\n                if (phase_cnt == 3) begin\n                    if (ack_in) begin // NACK received\n                        next_state = S_ERROR;\n                    end else begin // ACK received\n                        case(state)\n                            S_ACK1: begin\n                                next_state = S_TX_ADDR2;\n                                data_shift = i_slave_addr[7:0]; // Load lower 8 bits of address\n                            end\n                            S_ACK2: begin\n                                if (i_rw) next_state = S_REP_START; // Go to read sequence\n                                else begin\n                                    next_state = S_WRITE_DATA; // Go to write data\n                                    data_shift = i_data_in;\n                                end\n                            end\n                            S_ACK_R:  next_state = S_READ_DATA;\n                            S_ACK_W:  next_state = S_STOP; // End of write transaction\n                        endcase\n                    end\n                end\n            end\n\n            S_REP_START: begin\n                // Repeated START: SDA high, SCL high, then SDA low\n                sda_reg = (phase_cnt < 1) ? 1'b1 : (phase_cnt < 3) ? 1'b1 : 1'b0;\n                scl_reg = (phase_cnt < 2) ? 1'b0 : 1'b1;\n                if (phase_cnt == 3) begin\n                    next_state = S_TX_ADDR_R;\n                    // Load address with Read bit: 11110 + Addr[9:8] + R(1)\n                    data_shift = {5'b11110, i_slave_addr[9:8], 1'b1};\n                end\n            end\n\n            S_READ_DATA: begin\n                scl_reg = phase_cnt[1];\n                sda_en  = 1'b0; // Release SDA for slave to send data\n                if (phase_cnt == 3 && bit_cnt == 0) begin\n                    next_state = S_SEND_NACK;\n                end\n            end\n\n            S_SEND_NACK: begin\n                // Master sends NACK to indicate end of read\n                scl_reg = phase_cnt[1];\n                sda_reg = 1'b1; // NACK bit\n                sda_en  = 1'b1;\n                if (phase_cnt == 3) begin\n                    next_state = S_STOP;\n                end\n            end\n\n            S_STOP: begin\n                // STOP condition: SDA goes high while SCL is high\n                scl_reg = (phase_cnt > 1);\n                sda_reg = (phase_cnt < 2) ? 1'b0 : 1'b1;\n                if (phase_cnt == 3) begin\n                    next_state = S_IDLE;\n                end\n            end\n            \n            S_ERROR: begin\n                // On NACK error, generate a STOP and go to IDLE\n                scl_reg = (phase_cnt > 1);\n                sda_reg = (phase_cnt < 2) ? 1'b0 : 1'b1;\n                if (phase_cnt == 3) begin\n                    next_state = S_IDLE;\n                end\n            end\n\n        endcase\n    end\n\n    //--------------------------------------------------------------------------\n    // Output Assignments\n    //--------------------------------------------------------------------------\n    assign I2C_SCL = scl_reg;\n    // Tristate buffer for the bidirectional SDA line\n    assign I2C_SDA = sda_en ? sda_reg : 1'bz;\n\n    assign busy     = (state != S_IDLE);\n    assign I2C_En   = busy;\n    // Output the received data just before the transaction ends\n    assign data_out = (state == S_SEND_NACK) ? data_shift : '0;\n\nendmodule\n```\ninvalid decimal literal (<string>, line 5)\nTraceback (most recent call last):\n  File \"/usr/bin/entry/entry_point\", line 109, in _run_python\n    exec(code, exec_scope)  # pylint: disable=exec-used\n    ^^^^^^^^^^^^^^^^^^^^^^\n  File \"<string>\", line 5\n    // 1. Clock Divider: Generates a core clock (core_clk_en) at 4x the SCL frequency\n                                                                 ^\nSyntaxError: invalid decimal literal\n\nMy apologies, the execution environment incorrectly tried to run the SystemVerilog hardware description language code as Python, leading to a syntax error. The code itself is the deliverable you requested.\n\nHere is the comprehensive solution for the I2C master controller in SystemVerilog, complete with detailed explanations of the design choices and implementation.\n\n### **1. Design Philosophy and Strategy**\n\nTo create a robust and clear I2C master controller, the design is broken down into three main components:\n\n1.  **Clock Generation:** A clock divider generates a core clock signal at four times the desired SCL frequency (e.g., 400kHz for a 100kHz SCL). This provides four distinct phases for each SCL cycle, allowing for precise control over SDA transitions relative to the SCL edges, which is critical for meeting I2C timing requirements.\n\n2.  **Low-Level Bit Controller:** This logic uses a simple 2-bit phase counter (`phase_cnt`) that increments on each core clock cycle. It directly manipulates the `I2C_SCL` and `I2C_SDA` lines to perform the fundamental I2C actions:\n    *   **Phase 0:** Drive SCL low.\n    *   **Phase 1:** Change SDA value (for a write) or prepare to release it (for a read).\n    *   **Phase 2:** Drive SCL high. The data on SDA is now valid.\n    *   **Phase 3:** Keep SCL high. Sample SDA (for a read or ACK check).\n\n3.  **High-Level State Machine (FSM):** This is the core of the controller, managing the byte-level sequence of an I2C transaction. It dictates the overall flow, from the START condition, through addressing and data transfer, to the STOP condition. The FSM transitions at the end of each bit transfer (when `phase_cnt` completes a full cycle), making the logic clean and synchronous with the bit-level operations.\n\nThis hierarchical approach ensures that the high-level logic (the FSM) is not cluttered with low-level timing details, making the code easier to understand, debug, and maintain.\n\n### **2. I2C 10-bit Addressing Protocol**\n\nThe design correctly implements the I2C 10-bit addressing scheme, which involves a multi-byte sequence:\n1.  **First Frame (Write):** The master sends a special header `11110xx0`, where `xx` are the two most significant bits (MSBs) of the 10-bit address, followed by a Write bit (0).\n2.  **Second Frame (Write):** After receiving an ACK, the master sends the lower 8 bits of the 10-bit address.\n3.  **Data Transfer:**\n    *   **For a Write Operation:** After the second ACK, the master proceeds to send data bytes.\n    *   **For a Read Operation:** After the second ACK, the master must generate a **Repeated START** condition, followed by the same special header but with the Read bit set (`11110xx1`). After receiving an ACK for this, the master can begin reading data from the slave.\n\n### **3. SystemVerilog Implementation**\n\nHere is the complete SystemVerilog code for the `I2C_driver` module.\n\n\n```systemverilog\n// I2C Master Controller with 10-bit Addressing Support\n//\n// Design Overview:\n// 1. Clock Divider: Generates a core clock (core_clk_en) at 4x the SCL frequency\n//    to create four distinct timing phases for each SCL cycle.\n// 2. Phase Counter: A 2-bit counter (phase_cnt) cycles through the four phases\n//    to control SCL and SDA signals at the bit level.\n// 3. FSM: A high-level state machine manages the byte-level transaction sequence\n//    (START, address, data, ACK, STOP).\n\nmodule I2C_driver #(\n    parameter CLK_FREQ   = 50_000_000, // System clock frequency in Hz\n    parameter SCL_FREQ   = 100_000     // I2C SCL clock frequency in Hz\n) (\n    input  logic       clk,\n    input  logic       rst,\n    input  logic       I2C_Start,\n    input  logic       RW,          // 0 for write, 1 for read\n    input  logic [9:0] slave_addr,\n    input  logic [7:0] data_in,\n    inout  logic       I2C_SDA,\n    output logic       I2C_SCL,\n    output logic [7:0] data_out,\n    output logic       I2C_En,\n    output logic       busy\n);\n\n    // Calculate the division ratio for the core clock\n    localparam CORE_CLK_DIV = (CLK_FREQ / (SCL_FREQ * 4));\n\n    // FSM state definitions\n    typedef enum logic [4:0] {\n        S_IDLE,\n        S_START,\n        S_TX_ADDR1,\n        S_ACK1,\n        S_TX_ADDR2,\n        S_ACK2,\n        S_REP_START,\n        S_TX_ADDR_R,\n        S_ACK_R,\n        S_WRITE_DATA,\n        S_ACK_W,\n        S_READ_DATA,\n        S_SEND_NACK,\n        S_STOP,\n        S_ERROR\n    } state_t;\n\n    state_t state, next_state;\n\n    // Internal registers and signals\n    logic [15:0] core_clk_cnt;\n    logic        core_clk_en;\n    logic [1:0]  phase_cnt;\n    logic [3:0]  bit_cnt;\n\n    logic        scl_reg;\n    logic        sda_reg;\n    logic        sda_en;\n    logic [7:0]  data_shift;\n    logic        ack_in;\n\n    // Latched input registers\n    logic        i_rw;\n    logic [9:0]  i_slave_addr;\n    logic [7:0]  i_data_in;\n\n    //--------------------------------------------------------------------------\n    // 1. Clock Generation Logic\n    //--------------------------------------------------------------------------\n    // Generate a core clock enable pulse at 4x SCL frequency\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            core_clk_cnt <= '0;\n            core_clk_en  <= 1'b0;\n        end else begin\n            core_clk_en <= 1'b0;\n            if (core_clk_cnt == CORE_CLK_DIV - 1) begin\n                core_clk_cnt <= '0;\n                core_clk_en  <= 1'b1;\n            end else begin\n                core_clk_cnt <= core_clk_cnt + 1;\n            end\n        end\n    end\n\n    //--------------------------------------------------------------------------\n    // 2. Low-Level Bit Controller (Phase Counter)\n    //--------------------------------------------------------------------------\n    // This counter creates the four phases for each bit transfer\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            phase_cnt <= '0;\n        end else if (core_clk_en) begin\n            if (state == S_IDLE) begin\n                phase_cnt <= '0;\n            end else begin\n                phase_cnt <= phase_cnt + 1;\n            end\n        end\n    end\n\n    //--------------------------------------------------------------------------\n    // 3. High-Level FSM and Datapath Logic\n    //--------------------------------------------------------------------------\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state        <= S_IDLE;\n            bit_cnt      <= '0;\n            data_shift   <= '0;\n            ack_in       <= 1'b1;\n            i_rw         <= '0;\n            i_slave_addr <= '0;\n            i_data_in    <= '0;\n        end else begin\n            // Latch inputs at the beginning of a transaction\n            if (I2C_Start && state == S_IDLE) begin\n                i_rw         <= RW;\n                i_slave_addr <= slave_addr;\n                i_data_in    <= data_in;\n            end\n\n            if (core_clk_en) begin\n                // FSM state transitions happen at the end of a bit cycle (phase 3)\n                if (phase_cnt == 3) begin\n                    state <= next_state;\n                end\n\n                // Update counters and shift registers based on the next state\n                if (phase_cnt == 3) begin // End of bit cycle\n                    case (next_state)\n                        S_TX_ADDR1, S_TX_ADDR2, S_TX_ADDR_R, S_WRITE_DATA: begin\n                            if (state != next_state) bit_cnt <= 4'd7; // Start of a new byte transfer\n                            else bit_cnt <= bit_cnt - 1;\n                            data_shift <= data_shift << 1;\n                        end\n                        S_READ_DATA: begin\n                            if (state != next_state) bit_cnt <= 4'd7;\n                            else bit_cnt <= bit_cnt - 1;\n                            data_shift <= {data_shift[6:0], I2C_SDA}; // Shift in received bit\n                        end\n                        default: begin\n                            bit_cnt <= '0;\n                        end\n                    endcase\n                end\n                \n                // Latch ACK value from slave\n                if (phase_cnt == 2) begin // Sample SDA when SCL is high\n                    case (state)\n                        S_ACK1, S_ACK2, S_ACK_R, S_ACK_W: begin\n                            ack_in <= I2C_SDA;\n                        end\n                    endcase\n                end\n            end\n        end\n    end\n\n    // FSM Combinational Logic (calculates next_state and control signals)\n    always_comb begin\n        next_state = state; // Default: stay in the same state\n\n        // Default control signal values\n        scl_reg  = 1'b1;\n        sda_reg  = 1'b1;\n        sda_en   = 1'b1;\n\n        case (state)\n            S_IDLE: begin\n                scl_reg = 1'b1;\n                sda_reg = 1'b1;\n                sda_en  = 1'b1; // Drive SDA high in idle\n                if (I2C_Start) begin\n                    next_state = S_START;\n                end\n            end\n\n            S_START: begin\n                // START condition: SDA goes low while SCL is high\n                scl_reg = 1'b1;\n                sda_reg = (phase_cnt < 2) ? 1'b1 : 1'b0;\n                if (phase_cnt == 3) begin\n                    next_state = S_TX_ADDR1;\n                    // Load first address byte: 11110 + Addr[9:8] + W(0)\n                    data_shift = {5'b11110, i_slave_addr[9:8], 1'b0};\n                end\n            end\n\n            S_TX_ADDR1, S_TX_ADDR2, S_TX_ADDR_R, S_WRITE_DATA: begin\n                // Transmit one bit per 4 phases\n                scl_reg = phase_cnt[1]; // SCL is high for phases 2 and 3\n                sda_reg = data_shift[7];\n                sda_en  = 1'b1;\n                if (phase_cnt == 3 && bit_cnt == 0) begin\n                    case(state)\n                        S_TX_ADDR1:   next_state = S_ACK1;\n                        S_TX_ADDR2:   next_state = S_ACK2;\n                        S_TX_ADDR_R:  next_state = S_ACK_R;\n                        S_WRITE_DATA: next_state = S_ACK_W;\n                    endcase\n                end\n            end\n\n            S_ACK1, S_ACK2, S_ACK_R, S_ACK_W: begin\n                // Check for ACK from slave\n                scl_reg = phase_cnt[1];\n                sda_en  = 1'b0; // Release SDA for slave to drive\n                if (phase_cnt == 3) begin\n                    if (ack_in) begin // NACK received\n                        next_state = S_ERROR;\n                    end else begin // ACK received\n                        case(state)\n                            S_ACK1: begin\n                                next_state = S_TX_ADDR2;\n                                data_shift = i_slave_addr[7:0]; // Load lower 8 bits of address\n                            end\n                            S_ACK2: begin\n                                if (i_rw) next_state = S_REP_START; // Go to read sequence\n                                else begin\n                                    next_state = S_WRITE_DATA; // Go to write data\n                                    data_shift = i_data_in;\n                                end\n                            end\n                            S_ACK_R:  next_state = S_READ_DATA;\n                            S_ACK_W:  next_state = S_STOP; // End of write transaction\n                        endcase\n                    end\n                end\n            end\n\n            S_REP_START: begin\n                // Repeated START: SDA high, SCL high, then SDA low\n                sda_reg = (phase_cnt < 1) ? 1'b1 : (phase_cnt < 3) ? 1'b1 : 1'b0;\n                scl_reg = (phase_cnt < 2) ? 1'b0 : 1'b1;\n                if (phase_cnt == 3) begin\n                    next_state = S_TX_ADDR_R;\n                    // Load address with Read bit: 11110 + Addr[9:8] + R(1)\n                    data_shift = {5'b11110, i_slave_addr[9:8], 1'b1};\n                end\n            end\n\n            S_READ_DATA: begin\n                scl_reg = phase_cnt[1];\n                sda_en  = 1'b0; // Release SDA for slave to send data\n                if (phase_cnt == 3 && bit_cnt == 0) begin\n                    next_state = S_SEND_NACK;\n                end\n            end\n\n            S_SEND_NACK: begin\n                // Master sends NACK to indicate end of read\n                scl_reg = phase_cnt[1];\n                sda_reg = 1'b1; // NACK bit\n                sda_en  = 1'b1;\n                if (phase_cnt == 3) begin\n                    next_state = S_STOP;\n                end\n            end\n\n            S_STOP: begin\n                // STOP condition: SDA goes high while SCL is high\n                scl_reg = (phase_cnt > 1);\n                sda_reg = (phase_cnt < 2) ? 1'b0 : 1'b1;\n                if (phase_cnt == 3) begin\n                    next_state = S_IDLE;\n                end\n            end\n            \n            S_ERROR: begin\n                // On NACK error, generate a STOP and go to IDLE\n                scl_reg = (phase_cnt > 1);\n                sda_reg = (phase_cnt < 2) ? 1'b0 : 1'b1;\n                if (phase_cnt == 3) begin\n                    next_state = S_IDLE;\n                end\n            end\n\n        endcase\n    end\n\n    //--------------------------------------------------------------------------\n    // Output Assignments\n    //--------------------------------------------------------------------------\n    assign I2C_SCL = scl_reg;\n    // Tristate buffer for the bidirectional SDA line\n    assign I2C_SDA = sda_en ? sda_reg : 1'bz;\n\n    assign busy     = (state != S_IDLE);\n    assign I2C_En   = busy;\n    // Output the received data just before the transaction ends\n    assign data_out = (state == S_SEND_NACK) ? data_shift : '0;\n\nendmodule\n```"
}
