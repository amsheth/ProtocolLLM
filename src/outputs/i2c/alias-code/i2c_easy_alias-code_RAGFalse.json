{
    "prompt_0": " Write a SystemVerilog module to implement an I2C master controller. The controller should generate proper start and stop conditions, handle data transfers with acknowledgments, and support both write and read operations. The design must include a clock divider to produce the appropriate I2C SCL frequency. The I2C module should have the following interface:\nmodule I2C_driver( input  logic       clk,         // System clock input  logic       rst,         // Asynchronous reset input  logic       I2C_Start,   // Initiate a transaction when high input  logic       RW,          // Read/Write control: 0 for write, 1 for read input  logic [6:0] slave_addr,  // 7-bit I2C slave address input  logic [7:0] data_in,     // Data to be written (for write transactions) inout  logic       I2C_SDA,     // I2C data line (bidirectional) output logic       I2C_SCL,     // I2C clock line output logic [7:0] data_out,    // Data received from slave (for read transactions) output logic       I2C_En,      // Module enable signal (active during transaction) output logic       busy         // Indicates the module is busy with a transaction ); The I2C master controller should operate as follows: Start Condition: When I2C_Start is asserted, generate a start condition on the I2C bus. Addressing: Transmit the 7-bit slave address along with a R/W bit. Data Transfer: For write transactions (RW = 0), send the provided data (data_in) and handle the ACK from the slave. For read transactions (RW = 1), read the data from the slave and output it on data_out while sending the necessary ACK/NACK. Stop Condition: After the data transfer, generate a stop condition on the bus. Clock Generation: Use a clock divider to derive the I2C SCL frequency from the system clock. Control Signals: The module should assert busy during active transactions and deassert it once the transaction is complete. Design your code with clear state machine implementation, proper handling of bidirectional signals (I2C_SDA), and ensure that all I2C protocol timing requirements are met.\n",
    "answer_0": "```systemverilog\nmodule I2C_driver(\n    input  logic       clk,         // System clock\n    input  logic       rst,         // Asynchronous reset\n    input  logic       I2C_Start,   // Initiate a transaction when high\n    input  logic       RW,          // Read/Write control: 0 for write, 1 for read\n    input  logic [6:0] slave_addr,  // 7-bit I2C slave address\n    input  logic [7:0] data_in,     // Data to be written (for write transactions)\n    inout  logic       I2C_SDA,     // I2C data line (bidirectional)\n    output logic       I2C_SCL,     // I2C clock line\n    output logic [7:0] data_out,    // Data received from slave (for read transactions)\n    output logic       I2C_En,      // Module enable signal (active during transaction)\n    output logic       busy         // Indicates the module is busy with a transaction\n);\n\n    // State definitions\n    typedef enum logic [2:0] {\n        IDLE,\n        START,\n        ADDRESS,\n        ACK_ADDRESS,\n        WRITE_DATA,\n        ACK_WRITE_DATA,\n        READ_DATA,\n        ACK_READ_DATA,\n        STOP\n    } state_t;\n\n    state_t state, next_state;\n\n    // Clock divider for I2C SCL\n    logic [7:0] clk_div;\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            clk_div <= 8'd0;\n            I2C_SCL <= 1'b0;\n        end else begin\n            if (clk_div == 8'd0) begin\n                clk_div <= 8'd255; // Adjust for desired SCL frequency\n                I2C_SCL <= ~I2C_SCL;\n            end else begin\n                clk_div <= clk_div - 1;\n            end\n        end\n    end\n\n    // I2C SDA tristate control\n    assign I2C_SDA = (state == IDLE || state == START || state == STOP)? 1'bz : I2C_SDA;\n\n    // State machine logic\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            busy <= 1'b0;\n            I2C_En <= 1'b0;\n        end else begin\n            state <= next_state;\n            busy <= (state!= IDLE);\n            I2C_En <= (state!= IDLE);\n        end\n    end\n\n    always_comb begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (I2C_Start) begin\n                    next_state = START;\n                end\n            end\n            START: begin\n                I2C_SDA <= 1'b0;\n                next_state = ADDRESS;\n            end\n            ADDRESS: begin\n                I2C_SDA <= {slave_addr, RW};\n                next_state = ACK_ADDRESS;\n            end\n            ACK_ADDRESS: begin\n                // Wait for ACK from slave\n                next_state = (I2C_SDA == 1'b0)? (RW? READ_DATA : WRITE_DATA) : STOP;\n            end\n            WRITE_DATA: begin\n                I2C_SDA <= data_in[7];\n                next_state = ACK_WRITE_DATA;\n            end\n            ACK_WRITE_DATA: begin\n                // Wait for ACK from slave\n                next_state = (I2C_SDA == 1'b0)? (RW? READ_DATA : STOP) : WRITE_DATA;\n            end\n            READ_DATA: begin\n                // Read data from slave\n                data_out[7] <= I2C_SDA;\n                next_state = ACK_READ_DATA;\n            end\n            ACK_READ_DATA: begin\n                // Send ACK/NACK to slave\n                next_state = STOP;\n            end\n            STOP: begin\n                I2C_SDA <= 1'b1;\n                next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule\n```\n\nThis SystemVerilog module implements an I2C master controller with a state machine to handle start, address, data transfer, and stop conditions. It includes a clock divider to generate the appropriate I2C SCL frequency and manages the bidirectional I2C_SDA line. The module asserts the busy signal during active transactions and deasserts it once the transaction is complete."
}
