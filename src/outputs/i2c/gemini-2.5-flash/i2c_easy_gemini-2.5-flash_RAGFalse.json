{
    "prompt_0": " Write a SystemVerilog module to implement an I2C master controller. The controller should generate proper start and stop conditions, handle data transfers with acknowledgments, and support both write and read operations. The design must include a clock divider to produce the appropriate I2C SCL frequency. The I2C module should have the following interface:\nmodule I2C_driver( input  logic       clk,         // System clock input  logic       rst,         // Asynchronous reset input  logic       I2C_Start,   // Initiate a transaction when high input  logic       RW,          // Read/Write control: 0 for write, 1 for read input  logic [6:0] slave_addr,  // 7-bit I2C slave address input  logic [7:0] data_in,     // Data to be written (for write transactions) inout  logic       I2C_SDA,     // I2C data line (bidirectional) output logic       I2C_SCL,     // I2C clock line output logic [7:0] data_out,    // Data received from slave (for read transactions) output logic       I2C_En,      // Module enable signal (active during transaction) output logic       busy         // Indicates the module is busy with a transaction ); The I2C master controller should operate as follows: Start Condition: When I2C_Start is asserted, generate a start condition on the I2C bus. Addressing: Transmit the 7-bit slave address along with a R/W bit. Data Transfer: For write transactions (RW = 0), send the provided data (data_in) and handle the ACK from the slave. For read transactions (RW = 1), read the data from the slave and output it on data_out while sending the necessary ACK/NACK. Stop Condition: After the data transfer, generate a stop condition on the bus. Clock Generation: Use a clock divider to derive the I2C SCL frequency from the system clock. Control Signals: The module should assert busy during active transactions and deassert it once the transaction is complete. Design your code with clear state machine implementation, proper handling of bidirectional signals (I2C_SDA), and ensure that all I2C protocol timing requirements are met.\n",
    "answer_0": "To implement the I2C master controller in SystemVerilog, we will design a state machine that manages the I2C protocol's various phases: Start, Address Transmission, Data Transfer (Write/Read), Acknowledgment handling, and Stop. A clock divider will generate the I2C SCL signal from the system clock.\n\n### I2C Protocol Overview\n\n*   **Idle State**: SDA and SCL are high.\n*   **Start Condition**: SDA transitions from high to low while SCL is high.\n*   **Data/Address Transfer**: 8 bits are transferred. SDA must be stable when SCL is high and can only change when SCL is low.\n*   **Acknowledgment (ACK) / Not Acknowledgment (NACK)**: After every 8 bits, the receiver sends an ACK (pulls SDA low) or NACK (leaves SDA high) for one SCL clock cycle. The master generates the 9th clock pulse.\n*   **Stop Condition**: SDA transitions from low to high while SCL is high.\n\n### Module Interface\n\nThe module will adhere to the specified interface:\n\n\n```systemverilog\nmodule I2C_driver(\n    input  logic       clk,         // System clock\n    input  logic       rst,         // Asynchronous reset\n    input  logic       I2C_Start,   // Initiate a transaction when high\n    input  logic       RW,          // Read/Write control: 0 for write, 1 for read\n    input  logic [6:0] slave_addr,  // 7-bit I2C slave address\n    input  logic [7:0] data_in,     // Data to be written (for write transactions)\n    inout  logic       I2C_SDA,     // I2C data line (bidirectional)\n    output logic       I2C_SCL,     // I2C clock line\n    output logic [7:0] data_out,    // Data received from slave (for read transactions)\n    output logic       I2C_En,      // Module enable signal (active during transaction)\n    output logic       busy         // Indicates the module is busy with a transaction\n);\n```\n\n\n### Design Components\n\n1.  **Clock Divider**: Generates the I2C SCL signal. It counts system clock cycles to achieve the desired SCL frequency (e.g., 100 kHz or 400 kHz). SCL is toggled when the counter reaches `SCL_DIV_COUNT`.\n2.  **SDA Bidirectional Control**: The `inout` `I2C_SDA` port is managed using an internal tri-state buffer. `I2C_SDA_en` controls whether the master drives the line (`1'b1`) or releases it (`1'b0`) for the slave to drive or for reading.\n3.  **State Machine**: A finite state machine (FSM) controls the I2C transaction flow. The states include:\n    *   `IDLE`: Waiting for `I2C_Start`.\n    *   `START`: Generates the I2C Start condition.\n    *   `SEND_ADDR`: Transmits the 7-bit slave address and R/W bit.\n    *   `ACK_ADDR`: Waits for the slave's ACK after address transmission.\n    *   `SEND_DATA`: Transmits 8-bit data for write operations.\n    *   `ACK_DATA`: Waits for the slave's ACK after data transmission.\n    *   `RECV_DATA`: Receives 8-bit data for read operations.\n    *   `SEND_ACK_NACK`: Master sends ACK (for multi-byte read, not implemented here) or NACK (for single-byte read) after receiving data.\n    *   `STOP`: Generates the I2C Stop condition.\n4.  **Bit Counter**: A `bit_cnt` register tracks the 8 bits of data/address being transferred.\n\n### SystemVerilog Code\n\n\n```systemverilog\n// Define parameters for clock frequencies\n// These can be overridden during instantiation, e.g.,\n// I2C_driver #(.CLK_FREQ_HZ(50_000_000), .SCL_FREQ_HZ(400_000)) i2c_inst (...);\nmodule I2C_driver #(\n    parameter CLK_FREQ_HZ = 100_000_000, // System clock frequency (e.g., 100 MHz)\n    parameter SCL_FREQ_HZ = 100_000      // I2C SCL frequency (e.g., 100 kHz)\n) (\n    input  logic       clk,         // System clock\n    input  logic       rst,         // Asynchronous reset\n    input  logic       I2C_Start,   // Initiate a transaction when high\n    input  logic       RW,          // Read/Write control: 0 for write, 1 for read\n    input  logic [6:0] slave_addr,  // 7-bit I2C slave address\n    input  logic [7:0] data_in,     // Data to be written (for write transactions)\n    inout  logic       I2C_SDA,     // I2C data line (bidirectional)\n    output logic       I2C_SCL,     // I2C clock line\n    output logic [7:0] data_out,    // Data received from slave (for read transactions)\n    output logic       I2C_En,      // Module enable signal (active during transaction)\n    output logic       busy         // Indicates the module is busy with a transaction\n);\n\n    // Calculate the SCL clock divider count\n    // SCL_DIV_COUNT determines the number of system clock cycles for half of the SCL period.\n    // SCL_Period = 1 / SCL_FREQ_HZ\n    // Half_SCL_Period = SCL_Period / 2 = 1 / (2 * SCL_FREQ_HZ)\n    // Number of CLK cycles = Half_SCL_Period * CLK_FREQ_HZ = CLK_FREQ_HZ / (2 * SCL_FREQ_HZ)\n    // The counter counts from 0 to SCL_DIV_COUNT, so it's (value - 1)\n    localparam SCL_DIV_COUNT = (CLK_FREQ_HZ / (2 * SCL_FREQ_HZ)) - 1;\n\n    // Internal signals for I2C_SDA control\n    logic I2C_SDA_o;    // Output driver for SDA (1'b0 for low, 1'b1 for high)\n    logic I2C_SDA_en;   // Enable for SDA output driver (1'b1 for driving, 1'b0 for high-Z/input)\n    logic I2C_SDA_i;    // Input value of SDA (read from the bus)\n\n    // Tri-state buffer for I2C_SDA\n    // When I2C_SDA_en is 1, I2C_SDA_o drives the line.\n    // When I2C_SDA_en is 0, I2C_SDA is high-impedance (pulled high by external pull-up resistors).\n    assign I2C_SDA = I2C_SDA_en ? I2C_SDA_o : 1'bz;\n    assign I2C_SDA_i = I2C_SDA; // Read the actual SDA line value\n\n    // SCL Clock Divider Logic\n    // The size of the counter is determined by the maximum value it needs to reach.\n    logic [$clog2(SCL_DIV_COUNT+1)-1:0] scl_clk_cnt; // Counter for SCL generation\n    logic scl_high;           // Indicates SCL is high\n    logic scl_low;            // Indicates SCL is low\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            scl_clk_cnt <= 0;\n            I2C_SCL     <= 1'b1; // SCL defaults to high (idle state)\n        end else if (I2C_En) begin // Only divide clock when module is enabled (during transaction)\n            if (scl_clk_cnt == SCL_DIV_COUNT) begin\n                scl_clk_cnt <= 0;\n                I2C_SCL     <= ~I2C_SCL; // Toggle SCL every SCL_DIV_COUNT + 1 cycles\n            end else begin\n                scl_clk_cnt <= scl_clk_cnt + 1;\n            end\n        end else begin // When not enabled (IDLE state), keep SCL high and reset counter\n            scl_clk_cnt <= 0;\n            I2C_SCL     <= 1'b1;\n        end\n    end\n\n    assign scl_high = I2C_SCL;\n    assign scl_low  = ~I2C_SCL;\n\n    // State Machine Definition\n    typedef enum logic [3:0] { // 4 bits for up to 16 states, currently 9 states\n        IDLE,           // Waiting for a transaction request\n        START,          // Generating I2C Start condition\n        SEND_ADDR,      // Sending 7-bit slave address + R/W bit\n        ACK_ADDR,       // Waiting for ACK from slave after address\n        SEND_DATA,      // Sending 8-bit data (for write transactions)\n        ACK_DATA,       // Waiting for ACK from slave after data (for write transactions)\n        RECV_DATA,      // Receiving 8-bit data (for read transactions)\n        SEND_ACK_NACK,  // Master sends ACK/NACK after receiving data\n        STOP            // Generating I2C Stop condition\n    } i2c_state_e;\n\n    i2c_state_e current_state, next_state;\n\n    // Registers for data transfer and bit counting\n    logic [7:0] tx_byte;      // Byte to transmit (address + R/W, or data_in)\n    logic [7:0] rx_byte;      // Byte received from slave\n    logic [3:0] bit_cnt;      // Bit counter for 8 data bits + 1 ACK/NACK bit (0-8)\n    logic       ack_received; // Flag to indicate if ACK was received from slave\n\n    // Output registers to avoid combinational loops and ensure registered outputs\n    logic [7:0] data_out_reg;\n    logic       busy_reg;\n    logic       i2c_en_reg;\n\n    assign data_out = data_out_reg;\n    assign busy     = busy_reg;\n    assign I2C_En   = i2c_en_reg;\n\n    // State Register: Sequential logic for state transitions\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // FSM Logic: Combinational logic for next state and output generation\n    always_comb begin\n        // Default assignments for outputs and next state\n        next_state      = current_state;\n        I2C_SDA_o       = 1'b1;     // Default SDA to high (released)\n        I2C_SDA_en      = 1'b0;     // Default SDA to high-Z (input mode)\n        tx_byte         = tx_byte;  // Keep current value unless updated\n        rx_byte         = rx_byte;  // Keep current value unless updated\n        bit_cnt         = bit_cnt;  // Keep current value unless updated\n        ack_received    = 1'b0;     // Default no ACK received\n        data_out_reg    = data_out_reg; // Keep current value\n        busy_reg        = 1'b0;     // Default not busy\n        i2c_en_reg      = 1'b0;     // Default not enabled\n\n        case (current_state)\n            IDLE: begin\n                I2C_SDA_o  = 1'b1; // Ensure SDA is high (released)\n                I2C_SDA_en = 1'b0; // Ensure SDA is released\n                busy_reg   = 1'b0;\n                i2c_en_reg = 1'b0;\n                if (I2C_Start) begin\n                    next_state = START;\n                    busy_reg   = 1'b1;\n                    i2c_en_reg = 1'b1;\n                end\n            end\n\n            START: begin\n                busy_reg   = 1'b1;\n                i2c_en_reg = 1'b1;\n                // Start condition: SDA goes low while SCL is high\n                // Master must ensure SCL is high before pulling SDA low.\n                // The clock divider ensures SCL is high for half a period.\n                if (scl_high) begin // SCL is high, perform SDA transition\n                    I2C_SDA_o  = 1'b0; // Drive SDA low\n                    I2C_SDA_en = 1'b1; // Enable SDA output\n                    next_state = SEND_ADDR;\n                    tx_byte    = {slave_addr, RW}; // Prepare address + R/W bit\n                    bit_cnt    = 8; // Start with 8 bits (7 address + 1 R/W)\n                end else begin\n                    // Wait for SCL to go high if it's currently low (e.g., coming from IDLE where SCL is high, but for robustness)\n                    I2C_SDA_o  = 1'b1; // Keep SDA high\n                    I2C_SDA_en = 1'b0; // Release SDA\n                end\n            end\n\n            SEND_ADDR: begin\n                busy_reg   = 1'b1;\n                i2c_en_reg = 1'b1;\n\n                if (scl_low) begin // SDA can change only when SCL is low\n                    I2C_SDA_o  = tx_byte[bit_cnt-1]; // Send MSB first\n                    I2C_SDA_en = 1'b1;\n                end else if (scl_high) begin // SDA must be stable when SCL is high\n                    if (bit_cnt == 1) begin // Last bit (bit 0) has just been driven and SCL went high\n                        next_state   = ACK_ADDR;\n                        I2C_SDA_en   = 1'b0; // Release SDA for slave ACK\n                        bit_cnt      = 0; // Reset bit_cnt for ACK\n                    end else begin\n                        bit_cnt = bit_cnt - 1;\n                    end\n                end\n            end\n\n            ACK_ADDR: begin\n                busy_reg   = 1'b1;\n                i2c_en_reg = 1'b1;\n\n                I2C_SDA_en = 1'b0; // Master releases SDA for slave to ACK\n\n                if (scl_high) begin // Read ACK when SCL is high\n                    ack_received = ~I2C_SDA_i; // ACK is SDA low (0), NACK is SDA high (1)\n                    if (ack_received) begin\n                        if (RW == 1'b0) begin // Write transaction\n                            next_state = SEND_DATA;\n                            tx_byte    = data_in; // Prepare data to write\n                            bit_cnt    = 8;\n                        end else begin // Read transaction\n                            next_state = RECV_DATA;\n                            bit_cnt    = 8; // Prepare to receive 8 bits\n                            rx_byte    = 8'h00; // Clear receive buffer\n                        end\n                    end else begin\n                        // NACK received after address, go to STOP\n                        next_state = STOP;\n                    end\n                end\n            end\n\n            SEND_DATA: begin\n                busy_reg   = 1'b1;\n                i2c_en_reg = 1'b1;\n\n                if (scl_low) begin\n                    I2C_SDA_o  = tx_byte[bit_cnt-1];\n                    I2C_SDA_en = 1'b1;\n                end else if (scl_high) begin\n                    if (bit_cnt == 1) begin // Last bit (bit 0) has just been driven and SCL went high\n                        next_state   = ACK_DATA;\n                        I2C_SDA_en   = 1'b0; // Release SDA for slave ACK\n                        bit_cnt      = 0; // Reset bit_cnt for ACK\n                    end else begin\n                        bit_cnt = bit_cnt - 1;\n                    end\n                end\n            end\n\n            ACK_DATA: begin\n                busy_reg   = 1'b1;\n                i2c_en_reg = 1'b1;\n\n                I2C_SDA_en = 1'b0; // Master releases SDA for slave to ACK\n\n                if (scl_high) begin\n                    ack_received = ~I2C_SDA_i; // ACK is SDA low\n                    // For a single byte write, whether ACK or NACK, the transaction is complete.\n                    // In a multi-byte write, NACK would typically stop the transfer.\n                    next_state = STOP;\n                end\n            end\n\n            RECV_DATA: begin\n                busy_reg   = 1'b1;\n                i2c_en_reg = 1'b1;\n\n                I2C_SDA_en = 1'b0; // Master releases SDA to receive data from slave\n\n                if (scl_high) begin // Read data when SCL is high\n                    rx_byte[bit_cnt-1] = I2C_SDA_i; // Store received bit\n                    if (bit_cnt == 1) begin // Last bit (bit 0) has just been received\n                        data_out_reg = rx_byte; // Output the received byte\n                        next_state   = SEND_ACK_NACK;\n                        bit_cnt      = 0; // Prepare for ACK/NACK bit\n                    end else begin\n                        bit_cnt = bit_cnt - 1;\n                    end\n                end\n            end\n\n            SEND_ACK_NACK: begin\n                busy_reg   = 1'b1;\n                i2c_en_reg = 1'b1;\n\n                if (scl_low) begin\n                    // For a single byte read, master sends NACK to indicate end of read.\n                    // If multiple bytes were to be read, master would send ACK for all but the last byte.\n                    I2C_SDA_o  = 1'b1; // NACK (SDA high)\n                    I2C_SDA_en = 1'b1;\n                end else if (scl_high) begin\n                    // ACK/NACK bit sent, go to STOP\n                    next_state = STOP;\n                end\n            end\n\n            STOP: begin\n                busy_reg   = 1'b1;\n                i2c_en_reg = 1'b1;\n                // Stop condition: SDA goes high while SCL is high\n                // First, ensure SDA is low while SCL is low (from previous state or just before stop)\n                if (scl_low) begin\n                    I2C_SDA_o  = 1'b0; // Ensure SDA is low\n                    I2C_SDA_en = 1'b1;\n                end else if (scl_high) begin\n                    I2C_SDA_o  = 1'b1; // Drive SDA high\n                    I2C_SDA_en = 1'b1;\n                    next_state = IDLE; // Transaction complete\n                end\n            end\n\n            default: begin\n                next_state = IDLE; // Should not happen, but good for safety\n            end\n        endcase\n    end\n\nendmodule\n```",
    "prompt_1": " Write a SystemVerilog module to implement an I2C master controller. The controller should generate proper start and stop conditions, handle data transfers with acknowledgments, and support both write and read operations. The design must include a clock divider to produce the appropriate I2C SCL frequency. The I2C module should have the following interface:\nmodule I2C_driver( input  logic       clk,         // System clock input  logic       rst,         // Asynchronous reset input  logic       I2C_Start,   // Initiate a transaction when high input  logic       RW,          // Read/Write control: 0 for write, 1 for read input  logic [9:0] slave_addr,  // 10-bit I2C slave address input  logic [7:0] data_in,     // Data to be written (for write transactions) inout  logic       I2C_SDA,     // I2C data line (bidirectional) output logic       I2C_SCL,     // I2C clock line output logic [7:0] data_out,    // Data received from slave (for read transactions) output logic       I2C_En,      // Module enable signal (active during transaction) output logic       busy         // Indicates the module is busy with a transaction ); The I2C master controller should operate as follows: Start Condition: When I2C_Start is asserted, generate a start condition on the I2C bus. Addressing: Transmit the 10-bit slave address along with a R/W bit. Data Transfer: For write transactions (RW = 0), send the provided data (data_in) and handle the ACK from the slave. For read transactions (RW = 1), read the data from the slave and output it on data_out while sending the necessary ACK/NACK. Stop Condition: After the data transfer, generate a stop condition on the bus. Clock Generation: Use a clock divider to derive the I2C SCL frequency from the system clock. Control Signals: The module should assert busy during active transactions and deassert it once the transaction is complete. Design your code with clear state machine implementation, proper handling of bidirectional signals (I2C_SDA), and ensure that all I2C protocol timing requirements are met.\n",
    "answer_1": "Here's a SystemVerilog module for an I2C master controller, designed according to your specifications.\n\nThe design includes:\n*   A state machine to manage the I2C protocol steps.\n*   A clock divider to generate the I2C SCL signal.\n*   Proper handling of the bidirectional SDA line.\n*   Support for 10-bit addressing, write operations, and read operations.\n*   Generation of Start and Stop conditions.\n*   Handling of ACK/NACK during data transfers.\n\n**Assumptions:**\n*   The `SCL_HALF_PERIOD_COUNT` parameter needs to be adjusted based on your system clock frequency (`clk`) and the desired I2C SCL frequency. For example, if `clk` is 50 MHz and you want a 100 kHz I2C SCL, `SCL_HALF_PERIOD_COUNT = (50_000_000 / (2 * 100_000)) - 1 = 250 - 1 = 249`.\n*   The design assumes a single byte transfer for both write and read operations after addressing. For multi-byte transfers, the `DATA_TX_ACK` and `DATA_RX_ACK` states would need to loop back to `DATA_TX` or `DATA_RX` respectively, with a mechanism to send NACK on the last byte of a read.\n*   Basic ACK/NACK handling is implemented (NACK from slave leads to STOP). More robust error handling (e.g., retries, timeouts) would be needed for a production-grade design.\n\n\n```systemverilog\nmodule I2C_driver(\n    input  logic       clk,         // System clock\n    input  logic       rst,         // Asynchronous reset\n    input  logic       I2C_Start,   // Initiate a transaction when high\n    input  logic       RW,          // Read/Write control: 0 for write, 1 for read\n    input  logic [9:0] slave_addr,  // 10-bit I2C slave address\n    input  logic [7:0] data_in,     // Data to be written (for write transactions)\n    inout  logic       I2C_SDA,     // I2C data line (bidirectional)\n    output logic       I2C_SCL,     // I2C clock line\n    output logic [7:0] data_out,    // Data received from slave (for read transactions)\n    output logic       I2C_En,      // Module enable signal (active during transaction)\n    output logic       busy         // Indicates the module is busy with a transaction\n);\n\n    // --- Parameters ---\n    // SCL_HALF_PERIOD_COUNT = (SYS_CLK_FREQ / (2 * I2C_SCL_FREQ)) - 1\n    // Example: For SYS_CLK_FREQ = 50 MHz and I2C_SCL_FREQ = 100 kHz (Standard Mode)\n    // SCL_HALF_PERIOD_COUNT = (50_000_000 / (2 * 100_000)) - 1 = 250 - 1 = 249\n    parameter SCL_HALF_PERIOD_COUNT = 249; // *** ADJUST THIS VALUE FOR YOUR CLOCK FREQUENCIES ***\n\n    // --- State Definitions ---\n    typedef enum logic [4:0] {\n        IDLE,           // Waiting for a new transaction\n        START_COND_1,   // Generate Start: SDA high -> low while SCL high\n        START_COND_2,   // Generate Start: SCL high -> low while SDA low\n        ADDR_HIGH_TX,   // Transmit 7 MSBs of 10-bit address\n        ADDR_HIGH_ACK,  // Wait for ACK after 7 MSBs\n        ADDR_LOW_TX,    // Transmit 3 LSBs of 10-bit address + R/W bit\n        ADDR_LOW_ACK,   // Wait for ACK after 3 LSBs + R/W bit\n        DATA_TX,        // Transmit 8 bits of data\n        DATA_TX_ACK,    // Wait for ACK after data transmission\n        DATA_RX,        // Receive 8 bits of data\n        DATA_RX_ACK,    // Master sends ACK/NACK after data reception\n        STOP_COND_1,    // Generate Stop: SCL low -> high while SDA low\n        STOP_COND_2     // Generate Stop: SDA low -> high while SCL high\n    } i2c_state_t;\n\n    i2c_state_t current_state, next_state;\n\n    // --- Internal Signals ---\n    logic [9:0] scl_clk_counter; // Counter for SCL clock division\n    logic       scl_toggle;      // Flag to indicate SCL has just toggled\n    logic       i2c_scl_reg;     // Internal SCL register (output to I2C_SCL)\n    logic       i2c_sda_out;     // Data to drive onto I2C_SDA\n    logic       i2c_sda_en;      // Enable for driving I2C_SDA (1: master drives, 0: master releases)\n    logic [3:0] bit_counter;     // Counts bits for data/address transfer (0 to 7 for 8 bits)\n    logic [9:0] addr_reg;        // Register to hold slave address for current transaction\n    logic [7:0] data_tx_reg;     // Register to hold data to transmit for current transaction\n    logic [7:0] data_rx_reg;     // Register to hold received data\n    logic       rw_reg;          // Register to hold R/W bit for current transaction\n    logic       start_req_reg;   // Latch for I2C_Start input\n\n    // --- Output Assignments ---\n    assign I2C_SCL  = i2c_scl_reg;\n    assign I2C_SDA  = i2c_sda_en ? i2c_sda_out : 1'bz; // Bidirectional SDA control\n    assign data_out = data_rx_reg;\n    assign I2C_En   = (current_state != IDLE); // Active during transaction\n    assign busy     = (current_state != IDLE);   // Busy during transaction\n\n    // --- SCL Clock Generation ---\n    // This block generates the I2C_SCL signal with a 50% duty cycle.\n    // The SCL signal toggles when scl_clk_counter reaches SCL_HALF_PERIOD_COUNT.\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            scl_clk_counter <= 0;\n            i2c_scl_reg     <= 1'b1; // SCL starts high (idle state)\n            scl_toggle      <= 1'b0;\n        end else begin\n            if (current_state != IDLE) begin // Only generate SCL when busy\n                if (scl_clk_counter == SCL_HALF_PERIOD_COUNT) begin\n                    scl_clk_counter <= 0;\n                    i2c_scl_reg     <= ~i2c_scl_reg; // Toggle SCL\n                    scl_toggle      <= 1'b1;         // Indicate SCL has just toggled\n                end else begin\n                    scl_clk_counter <= scl_clk_counter + 1;\n                    scl_toggle      <= 1'b0;\n                end\n            end else begin // In IDLE state, SCL is held high\n                scl_clk_counter <= 0;\n                i2c_scl_reg     <= 1'b1;\n                scl_toggle      <= 1'b0;\n            end\n        end\n    end\n\n    // --- State Register ---\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // --- Input Registers (to sample inputs at start of transaction) ---\n    // These registers hold the transaction parameters stable throughout the transaction.\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            addr_reg      <= 10'b0;\n            data_tx_reg   <= 8'b0;\n            rw_reg        <= 1'b0;\n            start_req_reg <= 1'b0;\n        end else begin\n            // Sample inputs only when a new transaction is requested and module is idle\n            if (I2C_Start && !busy) begin\n                addr_reg      <= slave_addr;\n                data_tx_reg   <= data_in;\n                rw_reg        <= RW;\n                start_req_reg <= 1'b1; // Latch the start request\n            end else if (busy && current_state == IDLE) begin // Clear start request once transaction is done\n                start_req_reg <= 1'b0;\n            end\n        end\n    end\n\n    // --- Next State Logic and Output Control ---\n    always_comb begin\n        next_state   = current_state;\n        i2c_sda_out  = 1'b1; // Default to high (released state for SDA)\n        i2c_sda_en   = 1'b0; // Default to input (master releases SDA)\n        // data_rx_reg retains its value unless explicitly updated in DATA_RX state\n\n        case (current_state)\n            IDLE: begin\n                if (start_req_reg) begin // I2C_Start asserted and latched\n                    next_state = START_COND_1;\n                    // SCL is already high from idle state, SDA is high (released)\n                end\n            end\n\n            START_COND_1: begin // Generate Start: SDA high -> low while SCL high\n                i2c_sda_out = 1'b0; // Drive SDA low\n                i2c_sda_en  = 1'b1; // Master drives SDA\n                // Wait for SCL to be high and stable after SDA has fallen\n                // Transition on the next SCL low edge\n                if (scl_toggle && i2c_scl_reg == 1'b1) begin\n                    next_state = START_COND_2;\n                end\n            end\n\n            START_COND_2: begin // Generate Start: SCL high -> low while SDA low\n                i2c_sda_out = 1'b0; // Keep SDA low\n                i2c_sda_en  = 1'b1; // Master drives SDA\n                if (scl_toggle && i2c_scl_reg == 1'b0) begin // SCL just went low\n                    next_state  = ADDR_HIGH_TX;\n                    bit_counter = 0; // Reset bit counter for address transmission\n                end\n            end\n\n            ADDR_HIGH_TX: begin // Transmit 7 MSBs of 10-bit address (bits 9 to 3)\n                i2c_sda_en = 1'b1; // Master drives SDA\n                if (scl_toggle) begin\n                    if (i2c_scl_reg == 1'b0) begin // SCL just went low, prepare next bit\n                        i2c_sda_out = addr_reg[9 - bit_counter];\n                    end else begin // SCL just went high, bit is stable\n                        if (bit_counter == 6) begin // After 7 bits (0 to 6)\n                            next_state = ADDR_HIGH_ACK;\n                        end else begin\n                            bit_counter = bit_counter + 1;\n                        end\n                    end\n                end\n            end\n\n            ADDR_HIGH_ACK: begin // Wait for ACK from slave after 7 MSBs\n                i2c_sda_en = 1'b0; // Master releases SDA (slave drives ACK/NACK)\n                if (scl_toggle) begin\n                    if (i2c_scl_reg == 1'b0) begin // SCL just went low, sample ACK\n                        if (I2C_SDA == 1'b1) begin // NACK received\n                            next_state = STOP_COND_1; // Go to stop on NACK\n                        end else begin // ACK received\n                            next_state = ADDR_LOW_TX;\n                            bit_counter = 0; // Reset bit counter for next address part\n                        end\n                    end\n                end\n            end\n\n            ADDR_LOW_TX: begin // Transmit 3 LSBs of 10-bit address (bits 2 to 0) + R/W bit\n                i2c_sda_en = 1'b1; // Master drives SDA\n                if (scl_toggle) begin\n                    if (i2c_scl_reg == 1'b0) begin // SCL just went low, prepare next bit\n                        if (bit_counter < 3) begin // Bits 2, 1, 0 of address\n                            i2c_sda_out = addr_reg[2 - bit_counter];\n                        end else begin // R/W bit (bit_counter == 3)\n                            i2c_sda_out = rw_reg;\n                        end\n                    end else begin // SCL just went high, bit is stable\n                        if (bit_counter == 3) begin // After 4 bits (0 to 3)\n                            next_state = ADDR_LOW_ACK;\n                        end else begin\n                            bit_counter = bit_counter + 1;\n                        end\n                    end\n                end\n            end\n\n            ADDR_LOW_ACK: begin // Wait for ACK from slave after 3 LSBs + R/W bit\n                i2c_sda_en = 1'b0; // Master releases SDA\n                if (scl_toggle) begin\n                    if (i2c_scl_reg == 1'b0) begin // SCL just went low, sample ACK\n                        if (I2C_SDA == 1'b1) begin // NACK received\n                            next_state = STOP_COND_1; // Go to stop on NACK\n                        end else begin // ACK received\n                            if (rw_reg == 1'b0) begin // Write transaction\n                                next_state = DATA_TX;\n                                bit_counter = 0; // Reset bit counter for data\n                            end else begin // Read transaction\n                                next_state = DATA_RX;\n                                bit_counter = 0; // Reset bit counter for data\n                                data_rx_reg = 8'b0; // Clear data_out for new read\n                            end\n                        end\n                    end\n                end\n            end\n\n            DATA_TX: begin // Transmit 8 bits of data\n                i2c_sda_en = 1'b1; // Master drives SDA\n                if (scl_toggle) begin\n                    if (i2c_scl_reg == 1'b0) begin // SCL just went low, prepare next bit\n                        i2c_sda_out = data_tx_reg[7 - bit_counter];\n                    end else begin // SCL just went high, bit is stable\n                        if (bit_counter == 7) begin // After 8 bits (0 to 7)\n                            next_state = DATA_TX_ACK;\n                        end else begin\n                            bit_counter = bit_counter + 1;\n                        end\n                    end\n                end\n            end\n\n            DATA_TX_ACK: begin // Wait for ACK from slave after data transmission\n                i2c_sda_en = 1'b0; // Master releases SDA\n                if (scl_toggle) begin\n                    if (i2c_scl_reg == 1'b0) begin // SCL just went low, sample ACK\n                        // For simplicity, assume ACK and proceed to STOP.\n                        // In a real design, NACK might trigger a retry or error.\n                        next_state = STOP_COND_1;\n                    end\n                end\n            end\n\n            DATA_RX: begin // Receive 8 bits of data\n                i2c_sda_en = 1'b0; // Master releases SDA (slave drives data)\n                if (scl_toggle) begin\n                    if (i2c_scl_reg == 1'b1) begin // SCL just went high, sample data\n                        data_rx_reg[7 - bit_counter] = I2C_SDA;\n                        if (bit_counter == 7) begin // After 8 bits (0 to 7)\n                            next_state = DATA_RX_ACK;\n                        end else begin\n                            bit_counter = bit_counter + 1;\n                        end\n                    end\n                end\n            end\n\n            DATA_RX_ACK: begin // Master sends ACK/NACK after data reception\n                i2c_sda_en = 1'b1; // Master drives SDA\n                // For a single byte read, send NACK (1'b1) to indicate end of read.\n                // For multiple bytes, send ACK (1'b0) for all but the last byte.\n                i2c_sda_out = 1'b1; // Send NACK (high) for single byte read\n                if (scl_toggle) begin\n                    if (i2c_scl_reg == 1'b0) begin // SCL just went low, ACK/NACK sent\n                        next_state = STOP_COND_1;\n                    end\n                end\n            end\n\n            STOP_COND_1: begin // Generate Stop: SCL low -> high while SDA low\n                i2c_sda_out = 1'b0; // Keep SDA low\n                i2c_sda_en  = 1'b1; // Master drives SDA\n                if (scl_toggle && i2c_scl_reg == 1'b1) begin // SCL just went high\n                    next_state = STOP_COND_2;\n                end\n            end\n\n            STOP_COND_2: begin // Generate Stop: SDA low -> high while SCL high\n                i2c_sda_out = 1'b1; // Drive SDA high\n                i2c_sda_en  = 1'b1; // Master drives SDA\n                if (scl_toggle && i2c_scl_reg == 1'b1) begin // SCL is high, SDA just went high\n                    next_state = IDLE; // Transaction complete\n                end\n            end\n\n            default: begin\n                next_state = IDLE; // Should not happen, return to IDLE\n            end\n        endcase\n    end\n\nendmodule\n```"
}
