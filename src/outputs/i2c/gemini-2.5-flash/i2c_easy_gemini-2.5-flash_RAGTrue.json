{
    "prompt_0": "a STOP or Repeated START signal. To write data to a slave, store the data to be transmitted in the Transmit Register and set the WR bit. To read data from a slave, set the RD bit. During a transfer the core set the TIP flag, indicating that a Transfer is In Progress. When the transfer is done the TIP flag is reset, the IF flag set and, when enabled, an interrupt generated. The Receive Register contains valid data after the IF flag has been set. The user may issue a new write or read command when the TIP flag is reset. 4.2.4 STOP signal The master can terminate the communication by generating a STOP signal. A STOP signal, usually referred to as the P-bit, is defined as a low-to-high transition of SDA while SCL is at logical \u20181\u2019. OpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 9 of 15 4.3 Arbitration Procedure 4.3.1 Clock Synchronization The I2C bus is a true multimaster bus that allows more than one master to be connected on it. If two or more masters simultaneously try to control the bus, a clock synchronization procedure determines the bus clock. Because of the wired-AND connection of the I 2C signals a high to low transition affects all devices connected to the bus. Therefore a high to low transition on the SCL line causes all concerned devices to count off their low period. Once a device clock has gone low it will hold the SCL line in that state until the clock high state is reached. Due to the wired-AND connection the SCL line will therefore be held low by the device with the longest low period, and held high by the device with the shortest high period. Start counting low period wait stateStart counting high period SCL1 SCL2 SCLMaster1 SCL Master2 SCL wired-AND SCL 4.3.2 Clock Stretching Slave devices can use the clock synchronization mechanism to slow down the transfer bit rate. After the master has driven SCL low, the slave can drive SCL low for the required period and then release it. If the slave\u2019s SCL low period is greater than the master\u2019s SCL low period, the resulting SCL bus signal low period is stretched, thus inserting wait-states. OpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 10 of 15 5 Architecture The I2C core is built around four primary blocks; the Clock Generator, the Byte Command Controller, the Bit Command Controller and the DataIO Shift Register. All other blocks are used for interfacing or for storing temporary values. 5.1 Clock Generator The Clock Generator generates an internal 4*Fscl clock enable signal that triggers all synchronous elements in the Bit Command Controller. It also handles clock stretching needed by some slaves. 5.2 Byte Command Controller The Byte Command Controller handles I2C traffic at the byte level. It takes data from the Command Register and translates it into sequences based on the transmission of a single byte. By setting the START, STOP, and READ bit in the\nbyte has been read the contents are copied into the Receive Register. During a write action, the Transmit Register\u2019s contents are copied into the DataIO Shift Register and are then transmitted onto the SDA line. A B C DOpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 13 of 15 6 Programming examples Example 1 Write 1 byte of data to a slave. Slave address = 0x51 (b\u201d1010001\u201d) Data to write = 0xAC I2C Sequence: 1) generate start command 2) write slave address + write bit 3) receive acknowledge from slave 4) write data 5) receive acknowledge from slave 6) generate stop command Commands: 1) write 0xA2 (address + write bit) to Transmit Register, set STA bit, set WR bit. -- wait for interrupt or TIP flag to negate -- 2) read RxACK bit from Status Register, should be \u20180\u2019. write 0xAC to Transmit register, set STO bit, set WR bit. -- wait for interrupt or TIP flag to negate -- 3) read RxACK bit from Status Register, should be \u20180\u2019. Please note that the time for the Interrupt Service Routine is not shown here. It is assumed that the ISR is much faster then the I2C cycle time, and therefore not visible. Second command sequence First command sequence SDA S Wr ack ack P SCL OpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 14 of 15 Example 2 Read a byte of data from an I2C memory device. Slave address = 0x4E Memory location to read from = 0x20 I2C sequence: 1) generate start signal 2) write slave address + write bit 3) receive acknowledge from slave 4) write memory location 5) receive acknowledge from slave 6) generate repeated start signal 7) write slave address + read bit 8) receive acknowledge from slave 9) read byte from slave 10) write no acknowledge (NACK) to slave, indicating end of transfer 11) generate stop signal Commands: 1) write 0x9C (address + write bit) to Transmit Register, set STA bit, set WR bit. -- wait for interrupt or TIP flag to negate -- 2) read RxACK bit from Status Register, should be \u20180\u2019. write 0x20 to Transmit register, set WR bit. -- wait for interrupt or TIP flag to negate -- 3) read RxACK bit from Status Register, should be \u20180\u2019. write 0x9D (address + read bit) to Transmit Register, set STA bit, set WR bit. -- wait for interrupt or TIP flag to negate -- 4) set RD bit, set ACK to \u20181\u2019 (NACK), set STO bit Please note that the time for the Interrupt Service Routine is not shown here. It is assumed that the ISR is much faster then the I2C cycle time, and therefore not visible. Second command sequence First command sequence SDA S Wr ack ack SCL Fourth command sequence Third command sequence SDA R Rd ack D7 D6 D5 D4 D3 D2 D1 D0 nack P SCL OpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 15 of 15 Appendix A Synthesis results Synthesis tool: Synplify Pro Technology\nCommand Controller, the Bit Command Controller and the DataIO Shift Register. All other blocks are used for interfacing or for storing temporary values. 5.1 Clock Generator The Clock Generator generates an internal 4*Fscl clock enable signal that triggers all synchronous elements in the Bit Command Controller. It also handles clock stretching needed by some slaves. 5.2 Byte Command Controller The Byte Command Controller handles I2C traffic at the byte level. It takes data from the Command Register and translates it into sequences based on the transmission of a single byte. By setting the START, STOP, and READ bit in the Command Register, for example, the Byte Command Controller generates a sequence that results in the SCL SDA Prescale Register clock generator Command Register Status Register Byte Command Controller Bit Command Controller WISHBONE Interface Transmit Register Receive Register DataIO Shift Register Fig. 5.1 Internal structure I2C Master Core OpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 11 of 15 generation of a START signal, the reading of a byte from the slave device, and the generation of a STOP signal. It does this by dividing each byte operation into separate bit-operations, which are then sent to the Bit Command Controller. NoIdle state Read / Write bit set ? Yes START bit set ? Yes START signal state No START generated ? No Yes Read bit set ? Yes READ state Byte Read ? No Yes ACK state WRITE state Byte Written ? No YesNo ACK bit Read Written No YesOpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 12 of 15 5.3 Bit Command Controller The Bit Command Controller handles the actual transmission of data and the generation of the specific levels for START, Repeated START, and STOP signals by controlling the SCL and SDA lines. The Byte Command Controller tells the Bit Command Controller which operation has to be performed. For a single byte read, the Bit Command Controller receives 8 separate read commands. Each bit-operation is divided into 5 pieces (idle and A, B, C, and D), except for a STOP operation which is divided into 4 pieces (idle and A, B, and C). Start SCL SDA Rep Start SCL SDA Stop SCL SDA Write SCL SDA Read SCL SDA 5.4 DataIO Shift Register The DataIO Shift Register contains the data associated with the current transfer. During a read action, data is shifted in from the SDA line. After a byte has been read the contents are copied into the Receive Register. During a write action, the Transmit Register\u2019s contents are copied into the DataIO Shift Register and are then transmitted onto the SDA line. A B C DOpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 13 of 15 6 Programming examples Example 1 Write 1 byte of data to a slave. Slave address = 0x51 (b\u201d1010001\u201d) Data to write = 0xAC I2C Sequence: 1) generate start command 2) write slave address + write bit 3) receive acknowledge from slave 4) write data 5) receive acknowledge from slave 6) generate\n Write a SystemVerilog module to implement an I2C master controller. The controller should generate proper start and stop conditions, handle data transfers with acknowledgments, and support both write and read operations. The design must include a clock divider to produce the appropriate I2C SCL frequency. The I2C module should have the following interface:\nmodule I2C_driver( input  logic       clk,         // System clock input  logic       rst,         // Asynchronous reset input  logic       I2C_Start,   // Initiate a transaction when high input  logic       RW,          // Read/Write control: 0 for write, 1 for read input  logic [6:0] slave_addr,  // 7-bit I2C slave address input  logic [7:0] data_in,     // Data to be written (for write transactions) inout  logic       I2C_SDA,     // I2C data line (bidirectional) output logic       I2C_SCL,     // I2C clock line output logic [7:0] data_out,    // Data received from slave (for read transactions) output logic       I2C_En,      // Module enable signal (active during transaction) output logic       busy         // Indicates the module is busy with a transaction ); The I2C master controller should operate as follows: Start Condition: When I2C_Start is asserted, generate a start condition on the I2C bus. Addressing: Transmit the 7-bit slave address along with a R/W bit. Data Transfer: For write transactions (RW = 0), send the provided data (data_in) and handle the ACK from the slave. For read transactions (RW = 1), read the data from the slave and output it on data_out while sending the necessary ACK/NACK. Stop Condition: After the data transfer, generate a stop condition on the bus. Clock Generation: Use a clock divider to derive the I2C SCL frequency from the system clock. Control Signals: The module should assert busy during active transactions and deassert it once the transaction is complete. Design your code with clear state machine implementation, proper handling of bidirectional signals (I2C_SDA), and ensure that all I2C protocol timing requirements are met.\n",
    "answer_0": "To implement the I2C master controller in SystemVerilog, we will design a state machine that manages the I2C protocol's various phases: Start, Address Transmission, Data Transmission/Reception, Acknowledgment (ACK)/No Acknowledgment (NACK), Repeated Start, and Stop. A clock divider will generate the I2C SCL signal, and the design will handle the bidirectional SDA line and clock stretching.\n\n**1. Parameters and Internal Signals:**\n\n*   **Clock Division:** We'll define parameters for the system clock frequency and the desired I2C SCL frequency to calculate the `SCL_HALF_PERIOD_CYCLES`.\n*   **SCL Control:** An internal counter and a `scl_i` signal will manage the SCL clock generation. `I2C_SCL` will be driven low when `scl_i` is low, and tri-stated (released) when `scl_i` is high, allowing external pull-ups to pull it high and enabling clock stretching.\n*   **SDA Control:** `sda_out_val` will hold the data to be driven on SDA, and `sda_out_en` will enable/disable the SDA output driver (tri-state). `sda_in_val` will capture the value on the SDA bus.\n*   **State Machine Registers:** `current_state` and `next_state` for the FSM.\n*   **Data Registers:** `tx_byte_reg` for the byte being transmitted, `rx_byte_reg` for the byte being received, and `bit_counter` to track the current bit within a byte transfer.\n*   **Input Storage:** `stored_slave_addr`, `stored_rw`, and `stored_data_in` will capture the input values at the start of a transaction to ensure they remain stable.\n\n**2. State Machine Definition:**\n\nThe state machine will manage the I2C transaction flow. The states are designed to handle the sequence described in the problem and the provided examples (especially Example 2 for read operations with a memory address write and repeated start).\n\n\n```systemverilog\ntypedef enum logic [4:0] {\n    IDLE,\n    START_COND_1, START_COND_2, // Generate Start condition (SDA high->low while SCL high)\n    ADDR_WRITE_TX,              // Transmit slave address + write bit\n    ADDR_WRITE_ACK,             // Wait for ACK after address write\n    DATA_WRITE_TX,              // Transmit data_in (or memory address for read)\n    DATA_WRITE_ACK,             // Wait for ACK after data write\n    REPEATED_START_COND_1,      // Prepare for Repeated Start (SCL low -> high)\n    REPEATED_START_COND_2,      // Generate Repeated Start (SDA high -> low while SCL high)\n    ADDR_READ_TX,               // Transmit slave address + read bit\n    ADDR_READ_ACK,              // Wait for ACK after address read\n    DATA_READ_RX,               // Receive data from slave\n    DATA_READ_NACK,             // Send NACK after reading the last byte\n    STOP_COND_1,                // Prepare for Stop (SDA low while SCL low -> SCL high)\n    STOP_COND_2                 // Generate Stop (SDA low -> high while SCL high)\n} i2c_state_e;\n```\n\n\n**3. Clock Generation (`I2C_SCL`):**\n\nA counter `scl_clk_cnt` will divide the system clock (`clk`) to generate the I2C SCL frequency. The `scl_i` signal will toggle every half SCL period. `I2C_SCL` is driven low when `scl_i` is 0, and tri-stated (released) when `scl_i` is 1. The state machine will then wait for the actual `I2C_SCL` line to go high to account for clock stretching by the slave.\n\n**4. SDA Control (`I2C_SDA`):**\n\n`I2C_SDA` is a bidirectional signal. The master drives it by asserting `sda_out_en` and setting `sda_out_val`. To read from the slave, `sda_out_en` is deasserted (SDA is tri-stated), and the value on `I2C_SDA` is read into `sda_in_val`.\n\n**5. State Machine Logic:**\n\nThe state machine transitions based on the current state, the `scl_cnt_done` flag (indicating a half-SCL period has passed), the actual `I2C_SCL` line value (for clock stretching), and the `sda_in_val` (for ACK/NACK).\n\n*   **IDLE:** Waits for `I2C_Start`. Captures input parameters.\n*   **START_COND_1, START_COND_2:** Generates the Start condition (SDA high-to-low while SCL is high).\n*   **ADDR_WRITE_TX:** Transmits the 7-bit slave address plus the R/W bit (0 for write).\n*   **ADDR_WRITE_ACK:** Checks for ACK from the slave. If `RW` is 0 (write transaction), proceeds to `DATA_WRITE_TX`. If `RW` is 1 (read transaction), it means we just sent the slave address for a write phase (e.g., to specify a memory location), so it proceeds to `DATA_WRITE_TX` to send the `data_in` (which is the memory address in this case).\n*   **DATA_WRITE_TX:** Transmits the `data_in` (either the actual data for a write transaction or the memory address for a read transaction).\n*   **DATA_WRITE_ACK:** Checks for ACK from the slave. If it was a write transaction, it proceeds to `STOP_COND_1`. If it was a read transaction (meaning the memory address was just sent), it proceeds to `REPEATED_START_COND_1`.\n*   **REPEATED_START_COND_1, REPEATED_START_COND_2:** Generates a Repeated Start condition (SDA high-to-low while SCL is high, without a preceding Stop). This is crucial for the read example.\n*   **ADDR_READ_TX:** Transmits the 7-bit slave address plus the R/W bit (1 for read).\n*   **ADDR_READ_ACK:** Checks for ACK from the slave. If ACK, proceeds to `DATA_READ_RX`.\n\n*   **DATA_READ_RX:** Reads 8 bits of data from the slave.\n*   **DATA_READ_NACK:** Sends a NACK to the slave after reading the last byte, indicating the end of the read transfer.\n*   **STOP_COND_1, STOP_COND_2:** Generates the Stop condition (SDA low-to-high while SCL is high).\n*   **busy / I2C_En:** Asserted when the state machine is not in `IDLE`.\n*   **data_out:** Updated with `rx_byte_reg` when data is received.\n\n\n```systemverilog\nmodule I2C_driver(\n    input  logic       clk,         // System clock\n    input  logic       rst,         // Asynchronous reset\n    input  logic       I2C_Start,   // Initiate a transaction when high\n    input  logic       RW,          // Read/Write control: 0 for write, 1 for read\n    input  logic [6:0] slave_addr,  // 7-bit I2C slave address\n    input  logic [7:0] data_in,     // Data to be written (for write transactions)\n    inout  logic       I2C_SDA,     // I2C data line (bidirectional)\n    output logic       I2C_SCL,     // I2C clock line\n    output logic [7:0] data_out,    // Data received from slave (for read transactions)\n    output logic       I2C_En,      // Module enable signal (active during transaction)\n    output logic       busy         // Indicates the module is busy with a transaction\n);\n\n    // Parameters for clock division\n    parameter CLK_FREQ_HZ = 100_000_000; // Example: 100 MHz system clock\n    parameter I2C_FREQ_HZ = 100_000;    // Example: 100 kHz I2C SCL frequency\n    parameter SCL_HALF_PERIOD_CYCLES = (CLK_FREQ_HZ / I2C_FREQ_HZ) / 2;\n    localparam SCL_COUNTER_WIDTH = $clog2(SCL_HALF_PERIOD_CYCLES);\n\n    // Internal SCL clock generation signals\n    logic [SCL_COUNTER_WIDTH-1:0] scl_clk_cnt;\n    logic scl_i;        // Internal SCL state (0: low, 1: high)\n    logic scl_cnt_done; // Flag indicating end of a half SCL period\n\n    // SDA control signals\n    logic sda_out_val; // Value to drive on SDA\n    logic sda_out_en;  // Enable for SDA output (1 to drive, 0 to release)\n    logic sda_in_val;  // Value read from SDA bus\n\n    // State machine registers\n    typedef enum logic [4:0] {\n        IDLE,\n        START_COND_1, START_COND_2,\n        ADDR_WRITE_TX, ADDR_WRITE_ACK,\n        DATA_WRITE_TX, DATA_WRITE_ACK,\n        REPEATED_START_COND_1, REPEATED_START_COND_2,\n        ADDR_READ_TX, ADDR_READ_ACK,\n        DATA_READ_RX, DATA_READ_NACK,\n        STOP_COND_1, STOP_COND_2\n    } i2c_state_e;\n\n    i2c_state_e current_state, next_state;\n\n    // Data and bit counters\n    logic [7:0] tx_byte_reg; // Byte currently being transmitted\n    logic [7:0] rx_byte_reg; // Byte currently being received\n    logic [3:0] bit_counter; // Counts 0 to 8 for 9 bits (8 data + 1 ACK/NACK)\n\n    // Registers to store inputs at the start of a transaction\n    logic [6:0] stored_slave_addr;\n    logic       stored_rw;\n    logic [7:0] stored_data_in;\n\n    // Output assignments\n    assign busy = (current_state != IDLE);\n    assign I2C_En = busy;\n    assign data_out = rx_byte_reg;\n\n    // I2C_SCL output driver (master drives low, releases high)\n    assign I2C_SCL = (scl_i == 1'b0) ? 1'b0 : 1'bz;\n\n    // I2C_SDA output driver (master drives or releases)\n    assign I2C_SDA = sda_out_en ? sda_out_val : 1'bz;\n\n    // Read actual SDA bus value\n    assign sda_in_val = I2C_SDA;\n\n    // Clock divider for SCL\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            scl_clk_cnt <= '0;\n            scl_i <= 1'b1; // SCL starts high (released)\n            scl_cnt_done <= 1'b0;\n        end else begin\n            scl_cnt_done <= 1'b0;\n            if (scl_clk_cnt == SCL_HALF_PERIOD_CYCLES - 1) begin\n                scl_clk_cnt <= '0;\n                scl_i <= ~scl_i; // Toggle internal SCL state\n                scl_cnt_done <= 1'b1; // Indicate half-period is done\n            end else begin\n                scl_clk_cnt <= scl_clk_cnt + 1;\n            end\n        end\n    end\n\n    // Store input parameters when a transaction starts\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            stored_slave_addr <= '0;\n            stored_rw <= '0;\n            stored_data_in <= '0;\n        end else if (I2C_Start && current_state == IDLE) begin\n            stored_slave_addr <= slave_addr;\n            stored_rw <= RW;\n            stored_data_in <= data_in;\n        end\n    end\n\n    // State machine sequential logic\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_state <= IDLE;\n            tx_byte_reg <= '0;\n            rx_byte_reg <= '0;\n            bit_counter <= '0;\n            // Initial SDA state: released (high due to pull-up)\n            sda_out_val <= 1'b1;\n            sda_out_en <= 1'b0;\n        end else begin\n            current_state <= next_state;\n            // Default SDA to released unless explicitly driven in combinational logic\n            sda_out_en <= 1'b0;\n            sda_out_val <= 1'b1; // Default to high when released\n        end\n    end\n\n    // State machine combinational logic\n    always_comb begin\n        next_state = current_state;\n        // Default values for outputs driven by FSM\n        sda_out_val = 1'b1; // Default SDA to high\n        sda_out_en = 1'b0;   // Default SDA to released\n\n        case (current_state)\n            IDLE: begin\n                if (I2C_Start) begin\n                    next_state = START_COND_1;\n                end\n            end\n\n            START_COND_1: begin // SCL high, SDA high -> SDA low\n                // SCL is high (scl_i = 1). Drive SDA low.\n                sda_out_val = 1'b0;\n                sda_out_en = 1'b1;\n                if (scl_cnt_done && scl_i == 1'b0) begin // SCL just went low\n                    next_state = ADDR_WRITE_TX;\n                    bit_counter = 0;\n                    tx_byte_reg = {stored_slave_addr, 1'b0}; // First byte: Address + Write bit\n                end\n            end\n\n            ADDR_WRITE_TX: begin // Transmit 8 bits of address + R/W\n                // SCL is low (scl_i = 0). Drive SDA with current bit.\n                sda_out_val = tx_byte_reg[7 - bit_counter];\n                sda_out_en = 1'b1;\n\n                if (scl_cnt_done) begin // SCL just went high\n                    if (I2C_SCL == 1'b1) begin // Wait for actual SCL to be high (clock stretching)\n                        if (bit_counter == 7) begin // Last bit sent\n                            next_state = ADDR_WRITE_ACK;\n                        end else begin\n                            bit_counter = bit_counter + 1;\n                        end\n                    end\n                end\n            end\n\n            ADDR_WRITE_ACK: begin // Check ACK after address write\n                // SCL is low (scl_i = 0). Release SDA for slave ACK.\n                sda_out_en = 1'b0;\n\n                if (scl_cnt_done) begin // SCL just went high\n                    if (I2C_SCL == 1'b1) begin // Wait for actual SCL to be high\n                        if (sda_in_val == 1'b0) begin // ACK received\n                            if (stored_rw == 1'b0) begin // Write transaction: next send data_in\n                                tx_byte_reg = stored_data_in;\n                                next_state = DATA_WRITE_TX;\n                                bit_counter = 0;\n                            end else begin // Read transaction: next send memory address (data_in)\n                                tx_byte_reg = stored_data_in; // data_in is memory address for read\n                                next_state = DATA_WRITE_TX;\n                                bit_counter = 0;\n                            end\n                        end else begin // NACK received\n                            next_state = STOP_COND_1; // NACK means end of transfer or error\n                        end\n                    end\n                end\n            end\n\n            DATA_WRITE_TX: begin // Transmit 8 bits of data (or memory address)\n                // SCL is low (scl_i = 0). Drive SDA with current bit.\n                sda_out_val = tx_byte_reg[7 - bit_counter];\n                sda_out_en = 1'b1;\n\n                if (scl_cnt_done) begin // SCL just went high\n                    if (I2C_SCL == 1'b1) begin // Wait for actual SCL to be high\n                        if (bit_counter == 7) begin // Last bit sent\n                            next_state = DATA_WRITE_ACK;\n                        end else begin\n                            bit_counter = bit_counter + 1;\n                        end\n                    end\n                end\n            end\n\n            DATA_WRITE_ACK: begin // Check ACK after data write (or memory address write)\n                // SCL is low (scl_i = 0). Release SDA for slave ACK.\n                sda_out_en = 1'b0;\n\n                if (scl_cnt_done) begin // SCL just went high\n                    if (I2C_SCL == 1'b1) begin // Wait for actual SCL to be high\n                        if (sda_in_val == 1'b0) begin // ACK received\n                            if (stored_rw == 1'b0) begin // Write transaction: single byte write done\n                                next_state = STOP_COND_1;\n                            end else begin // Read transaction: memory address sent, now repeated start\n                                next_state = REPEATED_START_COND_1;\n                            end\n                        end else begin // NACK received\n                            next_state = STOP_COND_1; // NACK means end of transfer or error\n                        end\n                    end\n                end\n            end\n\n            REPEATED_START_COND_1: begin // Prepare for Repeated Start (SCL low -> high)\n                // From previous ACK, SCL is low, SDA is low.\n                // Release SDA to allow it to be pulled high.\n                sda_out_en = 1'b0;\n                if (scl_cnt_done && I2C_SCL == 1'b1) begin // SCL just went high and is high\n                    next_state = REPEATED_START_COND_2;\n                end\n            end\n\n            REPEATED_START_COND_2: begin // Generate Repeated Start (SDA high -> low while SCL high)\n                // SCL is high. Drive SDA low.\n                sda_out_val = 1'b0;\n                sda_out_en = 1'b1;\n                if (scl_cnt_done && scl_i == 1'b0) begin // SCL just went low\n                    next_state = ADDR_READ_TX;\n                    bit_counter = 0;\n                    tx_byte_reg = {stored_slave_addr, 1'b1}; // Next byte: Address + Read bit\n                end\n            end\n\n            ADDR_READ_TX: begin // Transmit 8 bits of address + read bit\n                // SCL is low (scl_i = 0). Drive SDA with current bit.\n                sda_out_val = tx_byte_reg[7 - bit_counter];\n                sda_out_en = 1'b1;\n\n                if (scl_cnt_done) begin // SCL just went high\n                    if (I2C_SCL == 1'b1) begin // Wait for actual SCL to be high\n                        if (bit_counter == 7) begin // Last bit sent\n                            next_state = ADDR_READ_ACK;\n                        end else begin\n                            bit_counter = bit_counter + 1;\n                        end\n                    end\n                end\n            end\n\n            ADDR_READ_ACK: begin // Check ACK after address read\n                // SCL is low (scl_i = 0). Release SDA for slave ACK.\n                sda_out_en = 1'b0;\n\n                if (scl_cnt_done) begin // SCL just went high\n                    if (I2C_SCL == 1'b1) begin // Wait for actual SCL to be high\n                        if (sda_in_val == 1'b0) begin // ACK received\n                            next_state = DATA_READ_RX;\n                            bit_counter = 0; // Reset for data read\n                            rx_byte_reg = '0; // Clear previous received data\n                        end else begin // NACK received\n                            next_state = STOP_COND_1; // NACK means end of transfer or error\n                        end\n                    end\n                end\n            end\n\n            DATA_READ_RX: begin // Receive 8 bits of data\n                // SCL is low (scl_i = 0). Release SDA for slave to drive data.\n                sda_out_en = 1'b0;\n\n                if (scl_cnt_done) begin // SCL just went high\n                    if (I2C_SCL == 1'b1) begin // Wait for actual SCL to be high\n                        rx_byte_reg[7 - bit_counter] = sda_in_val; // Capture data bit\n                        if (bit_counter == 7) begin // Last bit read\n                            next_state = DATA_READ_NACK; // Send NACK after last byte read\n                        end else begin\n                            bit_counter = bit_counter + 1;\n                        end\n                    end\n                end\n            end\n\n            DATA_READ_NACK: begin // Send NACK after reading\n                // SCL is low (scl_i = 0). Drive SDA high for NACK.\n                sda_out_val = 1'b1;\n                sda_out_en = 1'b1;\n\n                if (scl_cnt_done) begin // SCL just went high\n                    if (I2C_SCL == 1'b1) begin // Wait for actual SCL to be high\n                        next_state = STOP_COND_1;\n                    end\n                end\n            end\n\n            STOP_COND_1: begin // Prepare for Stop (SDA low while SCL low -> SCL high)\n                // SCL is low (scl_i = 0). Ensure SDA is low.\n                sda_out_val = 1'b0;\n                sda_out_en = 1'b1;\n                if (scl_cnt_done && I2C_SCL == 1'b1) begin // SCL just went high and is high\n                    next_state = STOP_COND_2;\n                end\n            end\n\n            STOP_COND_2: begin // Generate Stop (SDA low -> high while SCL high)\n                // SCL is high. Drive SDA high.\n                sda_out_val = 1'b1;\n                sda_out_en = 1'b1;\n                if (scl_cnt_done && scl_i == 1'b0) begin // SCL just went low\n                    next_state = IDLE; // Transaction complete\n                end\n            end\n\n            default: next_state = IDLE; // Should not happen\n        endcase\n    end\n\nendmodule\n```",
    "prompt_1": "a STOP or Repeated START signal. To write data to a slave, store the data to be transmitted in the Transmit Register and set the WR bit. To read data from a slave, set the RD bit. During a transfer the core set the TIP flag, indicating that a Transfer is In Progress. When the transfer is done the TIP flag is reset, the IF flag set and, when enabled, an interrupt generated. The Receive Register contains valid data after the IF flag has been set. The user may issue a new write or read command when the TIP flag is reset. 4.2.4 STOP signal The master can terminate the communication by generating a STOP signal. A STOP signal, usually referred to as the P-bit, is defined as a low-to-high transition of SDA while SCL is at logical \u20181\u2019. OpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 9 of 15 4.3 Arbitration Procedure 4.3.1 Clock Synchronization The I2C bus is a true multimaster bus that allows more than one master to be connected on it. If two or more masters simultaneously try to control the bus, a clock synchronization procedure determines the bus clock. Because of the wired-AND connection of the I 2C signals a high to low transition affects all devices connected to the bus. Therefore a high to low transition on the SCL line causes all concerned devices to count off their low period. Once a device clock has gone low it will hold the SCL line in that state until the clock high state is reached. Due to the wired-AND connection the SCL line will therefore be held low by the device with the longest low period, and held high by the device with the shortest high period. Start counting low period wait stateStart counting high period SCL1 SCL2 SCLMaster1 SCL Master2 SCL wired-AND SCL 4.3.2 Clock Stretching Slave devices can use the clock synchronization mechanism to slow down the transfer bit rate. After the master has driven SCL low, the slave can drive SCL low for the required period and then release it. If the slave\u2019s SCL low period is greater than the master\u2019s SCL low period, the resulting SCL bus signal low period is stretched, thus inserting wait-states. OpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 10 of 15 5 Architecture The I2C core is built around four primary blocks; the Clock Generator, the Byte Command Controller, the Bit Command Controller and the DataIO Shift Register. All other blocks are used for interfacing or for storing temporary values. 5.1 Clock Generator The Clock Generator generates an internal 4*Fscl clock enable signal that triggers all synchronous elements in the Bit Command Controller. It also handles clock stretching needed by some slaves. 5.2 Byte Command Controller The Byte Command Controller handles I2C traffic at the byte level. It takes data from the Command Register and translates it into sequences based on the transmission of a single byte. By setting the START, STOP, and READ bit in the\nbyte has been read the contents are copied into the Receive Register. During a write action, the Transmit Register\u2019s contents are copied into the DataIO Shift Register and are then transmitted onto the SDA line. A B C DOpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 13 of 15 6 Programming examples Example 1 Write 1 byte of data to a slave. Slave address = 0x51 (b\u201d1010001\u201d) Data to write = 0xAC I2C Sequence: 1) generate start command 2) write slave address + write bit 3) receive acknowledge from slave 4) write data 5) receive acknowledge from slave 6) generate stop command Commands: 1) write 0xA2 (address + write bit) to Transmit Register, set STA bit, set WR bit. -- wait for interrupt or TIP flag to negate -- 2) read RxACK bit from Status Register, should be \u20180\u2019. write 0xAC to Transmit register, set STO bit, set WR bit. -- wait for interrupt or TIP flag to negate -- 3) read RxACK bit from Status Register, should be \u20180\u2019. Please note that the time for the Interrupt Service Routine is not shown here. It is assumed that the ISR is much faster then the I2C cycle time, and therefore not visible. Second command sequence First command sequence SDA S Wr ack ack P SCL OpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 14 of 15 Example 2 Read a byte of data from an I2C memory device. Slave address = 0x4E Memory location to read from = 0x20 I2C sequence: 1) generate start signal 2) write slave address + write bit 3) receive acknowledge from slave 4) write memory location 5) receive acknowledge from slave 6) generate repeated start signal 7) write slave address + read bit 8) receive acknowledge from slave 9) read byte from slave 10) write no acknowledge (NACK) to slave, indicating end of transfer 11) generate stop signal Commands: 1) write 0x9C (address + write bit) to Transmit Register, set STA bit, set WR bit. -- wait for interrupt or TIP flag to negate -- 2) read RxACK bit from Status Register, should be \u20180\u2019. write 0x20 to Transmit register, set WR bit. -- wait for interrupt or TIP flag to negate -- 3) read RxACK bit from Status Register, should be \u20180\u2019. write 0x9D (address + read bit) to Transmit Register, set STA bit, set WR bit. -- wait for interrupt or TIP flag to negate -- 4) set RD bit, set ACK to \u20181\u2019 (NACK), set STO bit Please note that the time for the Interrupt Service Routine is not shown here. It is assumed that the ISR is much faster then the I2C cycle time, and therefore not visible. Second command sequence First command sequence SDA S Wr ack ack SCL Fourth command sequence Third command sequence SDA R Rd ack D7 D6 D5 D4 D3 D2 D1 D0 nack P SCL OpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 15 of 15 Appendix A Synthesis results Synthesis tool: Synplify Pro Technology\nCommand Controller, the Bit Command Controller and the DataIO Shift Register. All other blocks are used for interfacing or for storing temporary values. 5.1 Clock Generator The Clock Generator generates an internal 4*Fscl clock enable signal that triggers all synchronous elements in the Bit Command Controller. It also handles clock stretching needed by some slaves. 5.2 Byte Command Controller The Byte Command Controller handles I2C traffic at the byte level. It takes data from the Command Register and translates it into sequences based on the transmission of a single byte. By setting the START, STOP, and READ bit in the Command Register, for example, the Byte Command Controller generates a sequence that results in the SCL SDA Prescale Register clock generator Command Register Status Register Byte Command Controller Bit Command Controller WISHBONE Interface Transmit Register Receive Register DataIO Shift Register Fig. 5.1 Internal structure I2C Master Core OpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 11 of 15 generation of a START signal, the reading of a byte from the slave device, and the generation of a STOP signal. It does this by dividing each byte operation into separate bit-operations, which are then sent to the Bit Command Controller. NoIdle state Read / Write bit set ? Yes START bit set ? Yes START signal state No START generated ? No Yes Read bit set ? Yes READ state Byte Read ? No Yes ACK state WRITE state Byte Written ? No YesNo ACK bit Read Written No YesOpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 12 of 15 5.3 Bit Command Controller The Bit Command Controller handles the actual transmission of data and the generation of the specific levels for START, Repeated START, and STOP signals by controlling the SCL and SDA lines. The Byte Command Controller tells the Bit Command Controller which operation has to be performed. For a single byte read, the Bit Command Controller receives 8 separate read commands. Each bit-operation is divided into 5 pieces (idle and A, B, C, and D), except for a STOP operation which is divided into 4 pieces (idle and A, B, and C). Start SCL SDA Rep Start SCL SDA Stop SCL SDA Write SCL SDA Read SCL SDA 5.4 DataIO Shift Register The DataIO Shift Register contains the data associated with the current transfer. During a read action, data is shifted in from the SDA line. After a byte has been read the contents are copied into the Receive Register. During a write action, the Transmit Register\u2019s contents are copied into the DataIO Shift Register and are then transmitted onto the SDA line. A B C DOpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 13 of 15 6 Programming examples Example 1 Write 1 byte of data to a slave. Slave address = 0x51 (b\u201d1010001\u201d) Data to write = 0xAC I2C Sequence: 1) generate start command 2) write slave address + write bit 3) receive acknowledge from slave 4) write data 5) receive acknowledge from slave 6) generate\n Write a SystemVerilog module to implement an I2C master controller. The controller should generate proper start and stop conditions, handle data transfers with acknowledgments, and support both write and read operations. The design must include a clock divider to produce the appropriate I2C SCL frequency. The I2C module should have the following interface:\nmodule I2C_driver( input  logic       clk,         // System clock input  logic       rst,         // Asynchronous reset input  logic       I2C_Start,   // Initiate a transaction when high input  logic       RW,          // Read/Write control: 0 for write, 1 for read input  logic [9:0] slave_addr,  // 10-bit I2C slave address input  logic [7:0] data_in,     // Data to be written (for write transactions) inout  logic       I2C_SDA,     // I2C data line (bidirectional) output logic       I2C_SCL,     // I2C clock line output logic [7:0] data_out,    // Data received from slave (for read transactions) output logic       I2C_En,      // Module enable signal (active during transaction) output logic       busy         // Indicates the module is busy with a transaction ); The I2C master controller should operate as follows: Start Condition: When I2C_Start is asserted, generate a start condition on the I2C bus. Addressing: Transmit the 10-bit slave address along with a R/W bit. Data Transfer: For write transactions (RW = 0), send the provided data (data_in) and handle the ACK from the slave. For read transactions (RW = 1), read the data from the slave and output it on data_out while sending the necessary ACK/NACK. Stop Condition: After the data transfer, generate a stop condition on the bus. Clock Generation: Use a clock divider to derive the I2C SCL frequency from the system clock. Control Signals: The module should assert busy during active transactions and deassert it once the transaction is complete. Design your code with clear state machine implementation, proper handling of bidirectional signals (I2C_SDA), and ensure that all I2C protocol timing requirements are met.\n",
    "answer_1": "To implement the I2C master controller in SystemVerilog, we will follow a state machine approach to manage the I2C protocol steps: Start, Address (with R/W), Data Transfer (Write/Read with ACK/NACK), and Stop. The design will include a clock divider for the SCL signal and proper handling of the bidirectional SDA line, including implicit clock stretching by waiting for SCL to go high.\n\n**Assumptions and Clarifications:**\n\n1.  **10-bit Slave Address:** The problem states `input logic [9:0] slave_addr; // 10-bit I2C slave address` and \"Transmit the 10-bit slave address along with a R/W bit.\" Given the examples provided are for 7-bit addresses and the phrasing, we will implement a simplified 10-bit addressing where the 10-bit `slave_addr` is transmitted as 10 bits, followed by the 1-bit `RW` (Read/Write) bit, making it an 11-bit transfer for the address phase. This deviates from the standard I2C 10-bit addressing mode (which uses two bytes for the address and a specific header), but aligns with the problem's phrasing for simplicity.\n2.  **Single Byte Transfer:** The examples and problem description imply single-byte data transfers (one byte written or one byte read). The design will support this. For read operations, a NACK will be sent after the single byte is read to indicate the end of the transfer.\n3.  **Clock Stretching:** The SCL generation logic will implicitly handle clock stretching by releasing the SCL line high and waiting for the actual `I2C_SCL` line to go high before proceeding with the next SCL half-period.\n4.  **Error Handling:** For simplicity, if a NACK is received after the address or data, the master will proceed to generate a STOP condition. More robust error handling (e.g., retries, error flags) could be added.\n\n**Module Structure:**\n\n1.  **Parameters:** Define `CLK_FREQ` and `SCL_FREQ` to calculate the clock divider count.\n2.  **State Machine:** A `typedef enum` will define the various states of the I2C transaction.\n3.  **Clock Generator:** Generates the `I2C_SCL` signal with the specified frequency and handles open-drain behavior and clock stretching.\n4.  **SDA Control:** Manages the bidirectional `I2C_SDA` line using an output enable (`sda_oe_reg`) and output value (`sda_out_reg`).\n5.  **Start Pulse Logic:** Ensures `I2C_Start` triggers only one transaction per assertion.\n6.  **Main State Machine Logic:** Controls the I2C protocol sequence, including bit shifting, ACK/NACK handling, and state transitions based on SCL edges.\n\n\n```systemverilog\n// I2C_Master_Controller.sv\n// Implements an I2C Master Controller with 10-bit address (simplified 11-bit transfer)\n// and single byte read/write.\n\nmodule I2C_driver(\n    input  logic       clk,         // System clock\n    input  logic       rst,         // Asynchronous reset\n    input  logic       I2C_Start,   // Initiate a transaction when high\n    input  logic       RW,          // Read/Write control: 0 for write, 1 for read\n    input  logic [9:0] slave_addr,  // 10-bit I2C slave address\n    input  logic [7:0] data_in,     // Data to be written (for write transactions)\n    inout  logic       I2C_SDA,     // I2C data line (bidirectional)\n    output logic       I2C_SCL,     // I2C clock line (open-drain, master drives low, releases high)\n    output logic [7:0] data_out,    // Data received from slave (for read transactions)\n    output logic       I2C_En,      // Module enable signal (active during transaction)\n    output logic       busy         // Indicates the module is busy with a transaction\n);\n\n    // --- Parameters ---\n    parameter CLK_FREQ = 50_000_000; // 50 MHz system clock\n    parameter SCL_FREQ = 100_000;   // 100 kHz I2C SCL clock\n    // Calculate the count for half an SCL period.\n    // For 100kHz SCL from 50MHz CLK: (50,000,000 / 100,000) / 2 = 500 / 2 = 250\n    localparam SCL_HALF_PERIOD_COUNT = (CLK_FREQ / SCL_FREQ) / 2;\n\n    // --- State Machine Definition ---\n    typedef enum logic [4:0] {\n        IDLE,              // Waiting for a new transaction request\n        START_COND_1,      // SCL high, SDA high (pre-start setup)\n        START_COND_2,      // SCL high, SDA low (actual start condition)\n        ADDR_TX_BIT,       // Transmitting address/RW bit (SCL low, SDA set)\n        ADDR_TX_CLK,       // Transmitting address/RW bit (SCL high, SDA stable)\n        ACK_ADDR_RX_BIT,   // Receiving ACK for address (SCL low, SDA released)\n        ACK_ADDR_RX_CLK,   // Receiving ACK for address (SCL high, SDA sampled)\n        DATA_TX_BIT,       // Transmitting data bit (SCL low, SDA set)\n        DATA_TX_CLK,       // Transmitting data bit (SCL high, SDA stable)\n        ACK_DATA_RX_BIT,   // Receiving ACK for data (SCL low, SDA released)\n        ACK_DATA_RX_CLK,   // Receiving ACK for data (SCL high, SDA sampled)\n        DATA_RX_BIT,       // Receiving data bit (SCL low, SDA released)\n        DATA_RX_CLK,       // Receiving data bit (SCL high, SDA sampled)\n        ACK_TX_BIT,        // Transmitting ACK/NACK (SCL low, SDA set)\n        ACK_TX_CLK,        // Transmitting ACK/NACK (SCL high, SDA stable)\n        STOP_COND_1,       // SCL low, SDA low (pre-stop setup)\n        STOP_COND_2,       // SCL high, SDA low (stop condition part 1)\n        STOP_COND_3,       // SCL high, SDA high (actual stop condition)\n        DONE_STATE         // Transaction complete, brief hold before IDLE\n    } i2c_state_t;\n\n    // --- Internal Signals ---\n    i2c_state_t current_state, next_state;\n\n    // SCL control signals (open-drain implementation)\n    logic scl_out_reg;       // Value to drive SCL (always 0 when driving low)\n    logic scl_oe_reg;        // Output enable for SCL (1 to drive, 0 to release)\n    logic scl_internal_high; // Flag indicating I2C_SCL line is actually high (pulled up)\n    logic [15:0] scl_clk_cnt; // Counter for SCL half-period timing\n    logic scl_target_high;   // What the master *wants* SCL to be (high or low)\n    logic scl_posedge_en;    // Pulse on SCL rising edge (after clock stretching)\n    logic scl_negedge_en;    // Pulse on SCL falling edge\n\n    // SDA control signals (bidirectional)\n    logic sda_out_reg;       // Value to drive SDA (0 or 1)\n    logic sda_oe_reg;        // Output enable for SDA (1 to drive, 0 to release)\n    logic sda_in_reg;        // Registered value of I2C_SDA input\n\n    // Data transfer registers\n    logic [10:0] tx_addr_reg; // Holds 10-bit slave_addr + 1-bit R/W for transmission\n    logic [7:0] tx_data_reg;  // Holds data_in for transmission\n    logic [7:0] rx_data_reg;  // Accumulates received data\n    logic [3:0] bit_counter;  // Counts bits for address (0-10) or data (0-7)\n\n    // Control signals for module interface\n    logic busy_reg;    // Internal busy status\n    logic i2c_en_reg;  // Internal enable status\n    logic start_pulse; // Edge detection for I2C_Start input\n\n    // --- Output Assignments ---\n    assign I2C_En = i2c_en_reg;\n    assign busy = busy_reg;\n    assign data_out = rx_data_reg;\n\n    // I2C_SCL is open-drain: drive low (0) or release (1'bz)\n    assign I2C_SCL = scl_oe_reg ? scl_out_reg : 1'bz;\n    // I2C_SDA is bidirectional: drive low/high (0/1) or release (1'bz)\n    assign I2C_SDA = sda_oe_reg ? sda_out_reg : 1'bz;\n\n    // Register I2C_SDA input to avoid combinational loops and for stable sampling\n    always_ff @(posedge clk) begin\n        sda_in_reg <= I2C_SDA;\n    end\n\n    // --- SCL Clock Generator with Clock Stretching Support ---\n    // This block generates the SCL clock and the synchronization pulses (posedge_en, negedge_en)\n    // It also handles clock stretching by waiting for the actual I2C_SCL line to go high.\n    always_ff @(posedge clk, posedge rst) begin\n        if (rst) begin\n            scl_clk_cnt <= 0;\n            scl_target_high <= 1'b1; // Master wants SCL high initially\n            scl_oe_reg <= 1'b0;      // Release SCL (pulled high externally)\n            scl_out_reg <= 1'b0;     // Default drive low\n            scl_posedge_en <= 1'b0;\n            scl_negedge_en <= 1'b0;\n            scl_internal_high <= 1'b1; // Assume SCL is high at reset\n        end else begin\n            scl_posedge_en <= 1'b0; // Clear pulses each clock cycle\n            scl_negedge_en <= 1'b0;\n\n            // Update scl_internal_high based on actual I2C_SCL line\n            scl_internal_high <= I2C_SCL;\n\n            \n// Clock counter logic: increments every system clock cycle\n            if (scl_clk_cnt == SCL_HALF_PERIOD_COUNT - 1) begin\n                scl_clk_cnt <= 0;\n                scl_target_high <= ~scl_target_high; // Toggle master's SCL target\n            end else begin\n                scl_clk_cnt <= scl_clk_cnt + 1;\n            end\n\n            // Control SCL output based on master's target and actual line state\n            if (scl_target_high) begin // Master wants SCL high\n                scl_oe_reg <= 1'b0; // Release SCL (allow pull-up to make it high)\n                // Generate scl_posedge_en when SCL is actually high AND internal half-period elapsed\n                if (scl_internal_high && (scl_clk_cnt == SCL_HALF_PERIOD_COUNT - 1)) begin\n                    scl_posedge_en <= 1'b1;\n                end\n            end else begin // Master wants SCL low\n                scl_oe_reg <= 1'b1; // Drive SCL\n                scl_out_reg <= 1'b0; // Drive low\n                // Generate scl_negedge_en when internal half-period elapsed (SCL is driven low)\n                if (scl_clk_cnt == SCL_HALF_PERIOD_COUNT - 1) begin\n                    scl_negedge_en <= 1'b1;\n                end\n            end\n        end\n    end\n\n    // --- Start Pulse Generation ---\n    // This logic ensures that a transaction is initiated only once per I2C_Start assertion.\n    always_ff @(posedge clk, posedge rst) begin\n        if (rst) begin\n            start_pulse <= 1'b0;\n        end else begin\n            // Generate a pulse when I2C_Start is asserted and the module is not busy\n            start_pulse <= I2C_Start && !busy_reg;\n        end\n    end\n\n    // --- State Machine Logic ---\n    // This block controls the I2C protocol sequence based on the current state and SCL edges.\n    always_ff @(posedge clk, posedge rst) begin\n        if (rst) begin\n            current_state <= IDLE;\n            busy_reg <= 1'b0;\n            i2c_en_reg <= 1'b0;\n            sda_oe_reg <= 1'b0;\n            sda_out_reg <= 1'b1; // SDA high when idle (released, pulled up)\n            bit_counter <= 0;\n            tx_addr_reg <= 0;\n            tx_data_reg <= 0;\n            rx_data_reg <= 0;\n        end else begin\n            // Default assignments for signals that are not always driven in every state\n            // These are active during a transaction and reset in IDLE/DONE_STATE\n            busy_reg <= 1'b1;\n            i2c_en_reg <= 1'b1;\n\n            case (current_state)\n                IDLE: begin\n                    busy_reg <= 1'b0; // Not busy in IDLE\n                    i2c_en_reg <= 1'b0; // Not enabled in IDLE\n                    sda_oe_reg <= 1'b0; // SDA released (pulled high externally)\n                    sda_out_reg <= 1'b1; // Ensure SDA is high if we were driving it\n                    if (start_pulse) begin // Only start on a pulse from I2C_Start\n                        next_state <= START_COND_1;\n                        // Prepare address for transmission (10-bit address + 1-bit R/W)\n                        tx_addr_reg[10:1] <= slave_addr; // MSB of slave_addr at tx_addr_reg[10]\n                        tx_addr_reg[0] <= RW;            // R/W bit at tx_addr_reg[0]\n                        bit_counter <= 10;               // Start count for 11 bits (10 down to 0)\n                    end else begin\n                        next_state <= IDLE;\n                    end\n                end\n\n                START_COND_1: begin // SCL high, SDA high (pre-start setup)\n                    sda_oe_reg <= 1'b1; // Master drives SDA\n                    sda_out_reg <= 1'b1; // Drive SDA high\n                    if (scl_posedge_en) begin // SCL just went high (or was high and half-period elapsed)\n                        next_state <= START_COND_2;\n                    end else begin\n                        next_state <= START_COND_1;\n                    end\n                end\n\n                START_COND_2: begin // SCL high, SDA low (actual start condition)\n                    sda_oe_reg <= 1'b1;\n                    sda_out_reg <= 1'b0; // Drive SDA low\n                    if (scl_negedge_en) begin // SCL just went low, start address transmission\n                        next_state <= ADDR_TX_BIT;\n                    end else begin\n                        next_state <= START_COND_2;\n                    end\n                end\n\n                ADDR_TX_BIT: begin // SCL low, SDA set for address/RW bit\n                    sda_oe_reg <= 1'b1;\n                    sda_out_reg <= tx_addr_reg[bit_counter]; // Output current bit (MSB first)\n                    if (scl_posedge_en) begin // SCL just went high, bit is stable\n                        next_state <= ADDR_TX_CLK;\n                    end else begin\n                        next_state <= ADDR_TX_BIT;\n                    end\n                end\n\n                ADDR_TX_CLK: begin // SCL high, SDA stable for address/RW bit\n                    if (scl_negedge_en) begin // SCL just went low\n                        if (bit_counter == 0) begin // All 11 bits (10 addr + 1 R/W) sent\n                            next_state <= ACK_ADDR_RX_BIT; // Go to receive ACK\n                        end else begin\n                            bit_counter <= bit_counter - 1; // Move to next bit\n                            next_state <= ADDR_TX_BIT;\n                        end\n                    end else begin\n                        next_state <= ADDR_TX_CLK;\n                    end\n                end\n\n                ACK_ADDR_RX_BIT: begin // SCL low, SDA released for ACK\n                    sda_oe_reg <= 1'b0; // Release SDA for slave to drive ACK\n                    if (scl_posedge_en) begin // SCL just went high, sample ACK\n                        next_state <= ACK_ADDR_RX_CLK;\n                    end else begin\n                        next_state <= ACK_ADDR_RX_BIT;\n                    end\n                end\n\n                ACK_ADDR_RX_CLK: begin // SCL high, SDA sampled for ACK\n                    if (scl_negedge_en) begin // SCL just went low\n                        if (sda_in_reg == 1'b1) begin // NACK received (SDA high)\n                            // For simplicity, just stop on NACK. In a real design, might retry or signal error.\n                            next_state <= STOP_COND_1;\n                        end else begin // ACK received (SDA low)\n                            if (RW == 1'b0) begin // Write transaction\n                                bit_counter <= 7; // Prepare for 8 data bits (7 down to 0)\n                                tx_data_reg <= data_in; // Load data to transmit\n                                next_state <= DATA_TX_BIT;\n                            end else begin // Read transaction\n                                bit_counter <= 7; // Prepare for 8 data bits (7 down to 0)\n                                next_state <= DATA_RX_BIT;\n                            end\n                        end\n                    end else begin\n                        next_state <= ACK_ADDR_RX_CLK;\n                    end\n                end\n\n                DATA_TX_BIT: begin // SCL low, SDA set for data bit\n                    sda_oe_reg <= 1'b1;\n                    sda_out_reg <= tx_data_reg[bit_counter]; // Output current data bit (MSB first)\n                    if (scl_posedge_en) begin\n                        next_state <= DATA_TX_CLK;\n                    end else begin\n                        next_state <= DATA_TX_BIT;\n                    end\n                end\n\n                DATA_TX_CLK: begin // SCL high, SDA stable for data bit\n                    if (scl_negedge_en) begin\n                        if (bit_counter == 0) begin // All 8 data bits sent\n                            next_state <= ACK_DATA_RX_BIT; // Go to receive ACK\n                        end else begin\n                            bit_counter <= bit_counter - 1;\n                            next_state <= DATA_TX_BIT;\n                        end\n                    end else begin\n                        next_state <= DATA_TX_CLK;\n                    end\n                end\n\n                ACK_DATA_RX_BIT: begin // SCL low, SDA released for ACK (after data write)\n                    sda_oe_reg <= 1'b0; // Release SDA\n                    if (scl_posedge_en) begin\n                        next_state <= ACK_DATA_RX_CLK;\n                    end else begin\n                        next_state <= ACK_DATA_RX_BIT;\n                    end\n                end\n\n                ACK_DATA_RX_CLK: begin // SCL high, SDA sampled for ACK (after data write)\n                    if (scl_negedge_en) begin\n                        if (sda_in_reg == 1'b1) begin // NACK received\n                            // Handle NACK if needed, for now just proceed to stop\n                        end\n                        next_state <= STOP_COND_1; // After single byte write, go to STOP\n                    end else begin\n                        next_state <= ACK_DATA_RX_CLK;\n                    end\n                end\n\n                DATA_RX_BIT: begin // SCL low, SDA released for data read\n                    sda_oe_reg <= 1'b0; // Release SDA for slave to drive data\n                    if (scl_posedge_en) begin\n                        next_state <= DATA_RX_CLK;\n                    end else begin\n                        next_state <= DATA_RX_BIT;\n                    end\n                end\n\n                DATA_RX_CLK: begin // SCL high, SDA sampled for data read\n                    if (scl_negedge_en) begin\n                        rx_data_reg[bit_counter] <= sda_in_reg; // Store received bit (MSB first)\n                        if (bit_counter == 0) begin // All 8 data bits received\n                            next_state <= ACK_TX_BIT; // Go to transmit ACK/NACK\n                        end else begin\n                            bit_counter <= bit_counter - 1;\n                            next_state <= DATA_RX_BIT;\n                        end\n                    end else begin\n                        next_state <= DATA_RX_CLK;\n                    end\n                end\n\n                ACK_TX_BIT: begin // SCL low, SDA set for ACK/NACK (after data read)\n                    sda_oe_reg <= 1'b1;\n                    // For single byte read, send NACK (SDA high)\n                    sda_out_reg <= 1'b1; // NACK\n                    if (scl_posedge_en) begin\n                        next_state <= ACK_TX_CLK;\n                    end else begin\n                        next_state <= ACK_TX_BIT;\n                    end\n                end\n\n                ACK_TX_CLK: begin // SCL high, SDA stable for ACK/NACK (after data read)\n                    if (scl_negedge_en) begin\n                        next_state <= STOP_COND_1; // After single byte read, go to STOP\n                    end else begin\n                        next_state <= ACK_TX_CLK;\n                    end\n                end\n\n                STOP_COND_1: begin // SCL low, SDA low (pre-stop setup)\n                    sda_oe_reg <= 1'b1;\n                    sda_out_reg <= 1'b0; // Drive SDA low\n                    if (scl_posedge_en) begin // SCL just went high\n                        next_state <= STOP_COND_2;\n                    end else begin\n                        next_state <= STOP_COND_1;\n                    end\n                end\n\n                STOP_COND_2: begin // SCL high, SDA low (stop condition part 1)\n                    sda_oe_reg <= 1'b1;\n                    sda_out_reg <= 1'b0; // Keep SDA low\n                    if (scl_posedge_en) begin // SCL is high, wait for next SCL half-period\n                        next_state <= STOP_COND_3;\n                    end else begin\n                        next_state <= STOP_COND_2;\n                    end\n                end\n\n                STOP_COND_3: begin // SCL high, SDA high (actual stop condition)\n                    sda_oe_reg <= 1'b1;\n                    sda_out_reg <= 1'b1; // Drive SDA high\n                    if (scl_negedge_en) begin // SCL just went low, stop condition complete\n                        next_state <= DONE_STATE;\n                    end else begin\n                        next_state <= STOP_COND_3;\n                    end\n                end\n\n                DONE_STATE: begin\n                    busy_reg <= 1'b0; // Transaction finished\n                    i2c_en_reg <= 1'b0; // Module disabled\n                    sda_oe_reg <= 1'b0; // Release SDA\n                    sda_out_reg <= 1'b1; // Ensure SDA is high (pulled up)\n                    next_state <= IDLE; // Return to idle\n                end\n\n                default: begin\n                    next_state <= IDLE; // Should not happen, reset to IDLE\n                end\n            endcase\n            current_state <= next_state;\n        end\n    end\n\nendmodule\n\n```"
}
