{
    "prompt_0": " Write a SystemVerilog module to implement an I2C master controller. The controller should generate proper start and stop conditions, handle data transfers with acknowledgments, and support both write and read operations. The design must include a clock divider to produce the appropriate I2C SCL frequency. The I2C module should have the following interface:\nmodule I2C_driver( input  logic       clk,         // System clock input  logic       rst,         // Asynchronous reset input  logic       I2C_Start,   // Initiate a transaction when high input  logic       RW,          // Read/Write control: 0 for write, 1 for read input  logic [6:0] slave_addr,  // 7-bit I2C slave address input  logic [7:0] data_in,     // Data to be written (for write transactions) inout  logic       I2C_SDA,     // I2C data line (bidirectional) output logic       I2C_SCL,     // I2C clock line output logic [7:0] data_out,    // Data received from slave (for read transactions) output logic       I2C_En,      // Module enable signal (active during transaction) output logic       busy         // Indicates the module is busy with a transaction ); The I2C master controller should operate as follows: Start Condition: When I2C_Start is asserted, generate a start condition on the I2C bus. Addressing: Transmit the 7-bit slave address along with a R/W bit. Data Transfer: For write transactions (RW = 0), send the provided data (data_in) and handle the ACK from the slave. For read transactions (RW = 1), read the data from the slave and output it on data_out while sending the necessary ACK/NACK. Stop Condition: After the data transfer, generate a stop condition on the bus. Clock Generation: Use a clock divider to derive the I2C SCL frequency from the system clock. Control Signals: The module should assert busy during active transactions and deassert it once the transaction is complete. Design your code with clear state machine implementation, proper handling of bidirectional signals (I2C_SDA), and ensure that all I2C protocol timing requirements are met.\n",
    "answer_0": "I'll implement a comprehensive I2C master controller in SystemVerilog. This design includes a state machine for protocol handling, clock generation, and proper bidirectional signal management.\n\n```systemverilog\nmodule I2C_driver(\n    input  logic       clk,         // System clock\n    input  logic       rst,         // Asynchronous reset\n    input  logic       I2C_Start,   // Initiate a transaction when high\n    input  logic       RW,          // Read/Write control: 0 for write, 1 for read\n    input  logic [6:0] slave_addr,  // 7-bit I2C slave address\n    input  logic [7:0] data_in,     // Data to be written (for write transactions)\n    inout  logic       I2C_SDA,     // I2C data line (bidirectional)\n    output logic       I2C_SCL,     // I2C clock line\n    output logic [7:0] data_out,    // Data received from slave (for read transactions)\n    output logic       I2C_En,      // Module enable signal (active during transaction)\n    output logic       busy         // Indicates the module is busy with a transaction\n);\n\n    // State machine states\n    typedef enum logic [4:0] {\n        IDLE         = 5'b00000,\n        START        = 5'b00001,\n        ADDR_SEND    = 5'b00010,\n        ADDR_ACK     = 5'b00011,\n        DATA_SEND    = 5'b00100,\n        DATA_ACK     = 5'b00101,\n        DATA_READ    = 5'b00110,\n        DATA_NACK    = 5'b00111,\n        STOP         = 5'b01000,\n        COMPLETE     = 5'b01001\n    } state_t;\n\n    // Internal signals\n    state_t current_state, next_state;\n    logic [7:0] clk_divider;\n    logic       i2c_clk_en;\n    logic       sda_out;\n    logic       sda_oe;        // SDA output enable\n    logic [3:0] bit_counter;\n    logic [7:0] shift_reg;\n    logic [7:0] addr_byte;\n    logic       ack_received;\n    logic       start_condition;\n    logic       i2c_start_sync;\n    logic       i2c_start_prev;\n    \n    // Clock divider parameters (adjust based on system clock frequency)\n    // For 100kHz I2C with 50MHz system clock: divide by 500\n    // For 400kHz I2C with 50MHz system clock: divide by 125\n    parameter CLK_DIVIDER = 8'd125; // Adjust based on desired I2C frequency\n    \n    // Clock divider for I2C SCL generation\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            clk_divider <= 8'd0;\n            i2c_clk_en <= 1'b0;\n        end else begin\n            if (clk_divider >= (CLK_DIVIDER - 1)) begin\n                clk_divider <= 8'd0;\n                i2c_clk_en <= 1'b1;\n            end else begin\n                clk_divider <= clk_divider + 1'b1;\n                i2c_clk_en <= 1'b0;\n            end\n        end\n    end\n    \n    // Input synchronization\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            i2c_start_prev <= 1'b0;\n            i2c_start_sync <= 1'b0;\n        end else begin\n            i2c_start_prev <= I2C_Start;\n            i2c_start_sync <= I2C_Start && !i2c_start_prev; // Edge detection\n        end\n    end\n    \n    // State machine - sequential logic\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_state <= IDLE;\n        end else if (i2c_clk_en) begin\n            current_state <= next_state;\n        end\n    end\n    \n    // State machine - combinational logic\n    always_comb begin\n        next_state = current_state;\n        \n        case (current_state)\n            IDLE: begin\n                if (i2c_start_sync) begin\n                    next_state = START;\n                end\n            end\n            \n            START: begin\n                next_state = ADDR_SEND;\n            end\n            \n            ADDR_SEND: begin\n                if (bit_counter == 4'd7) begin\n                    next_state = ADDR_ACK;\n                end\n            end\n            \n            ADDR_ACK: begin\n                if (RW) begin\n                    next_state = DATA_READ;\n                end else begin\n                    next_state = DATA_SEND;\n                end\n            end\n            \n            DATA_SEND: begin\n                if (bit_counter == 4'd7) begin\n                    next_state = DATA_ACK;\n                end\n            end\n            \n            DATA_ACK: begin\n                next_state = STOP;\n            end\n            \n            DATA_READ: begin\n                if (bit_counter == 4'd7) begin\n                    next_state = DATA_NACK;\n                end\n            end\n            \n            DATA_NACK: begin\n                next_state = STOP;\n            end\n            \n            STOP: begin\n                next_state = COMPLETE;\n            end\n            \n            COMPLETE: begin\n                next_state = IDLE;\n            end\n            \n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n    \n    // Bit counter management\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            bit_counter <= 4'd0;\n        end else if (i2c_clk_en) begin\n            if (current_state == ADDR_SEND || current_state == DATA_SEND || current_state == DATA_READ) begin\n                bit_counter <= bit_counter + 1'b1;\n            end else begin\n                bit_counter <= 4'd0;\n            end\n        end\n    end\n    \n    // Address byte preparation\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            addr_byte <= 8'd0;\n        end else if (current_state == IDLE && i2c_start_sync) begin\n            addr_byte <= {slave_addr, RW};\n        end\n    end\n    \n    // Shift register for data transmission/reception\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            shift_reg <= 8'd0;\n        end else if (i2c_clk_en) begin\n            case (current_state)\n                START: begin\n                    shift_reg <= addr_byte;\n                end\n                \n                ADDR_SEND: begin\n                    shift_reg <= {shift_reg[6:0], 1'b0};\n                end\n                \n                ADDR_ACK: begin\n                    if (RW) begin\n                        shift_reg <= 8'd0; // Prepare for reading\n                    end else begin\n                        shift_reg <= data_in; // Load data to send\n                    end\n                end\n                \n                DATA_SEND: begin\n                    shift_reg <= {shift_reg[6:0], 1'b0};\n                end\n                \n                DATA_READ: begin\n                    shift_reg <= {shift_reg[6:0], I2C_SDA};\n                end\n            endcase\n        end\n    end\n    \n    // ACK detection\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            ack_received <= 1'b0;\n        end else if (i2c_clk_en) begin\n            if (current_state == ADDR_ACK || current_state == DATA_ACK) begin\n                ack_received <= ~I2C_SDA; // ACK is active low\n            end\n        end\n    end\n    \n    // SDA control logic\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sda_out <= 1'b1;\n            sda_oe <= 1'b0;\n        end else if (i2c_clk_en) begin\n            case (current_state)\n                IDLE: begin\n                    sda_out <= 1'b1;\n                    sda_oe <= 1'b0;\n                end\n                \n                START: begin\n                    sda_out <= 1'b0; // Start condition: SDA low while SCL high\n                    sda_oe <= 1'b1;\n                end\n                \n                ADDR_SEND: begin\n                    sda_out <= shift_reg[7];\n                    sda_oe <= 1'b1;\n                end\n                \n                ADDR_ACK: begin\n                    sda_out <= 1'b1;\n                    sda_oe <= 1'b0; // Release SDA for ACK\n                end\n                \n                DATA_SEND: begin\n                    sda_out <= shift_reg[7];\n                    sda_oe <= 1'b1;\n                end\n                \n                DATA_ACK: begin\n                    sda_out <= 1'b1;\n                    sda_oe <= 1'b0; // Release SDA for ACK\n                end\n                \n                DATA_READ: begin\n                    sda_out <= 1'b1;\n                    sda_oe <= 1'b0; // Release SDA for slave to drive\n                end\n                \n                DATA_NACK: begin\n                    sda_out <= 1'b1; // NACK: SDA high during ACK clock\n                    sda_oe <= 1'b1;\n                end\n                \n                STOP: begin\n                    sda_out <= 1'b1; // Stop condition: SDA high while SCL high\n                    sda_oe <= 1'b1;\n                end\n                \n                COMPLETE: begin\n                    sda_out <= 1'b1;\n                    sda_oe <= 1'b0;\n                end\n                \n                default: begin\n                    sda_out <= 1'b1;\n                    sda_oe <= 1'b0;\n                end\n            endcase\n        end\n    end\n    \n    // SCL generation\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            I2C_SCL <= 1'b1;\n        end else if (i2c_clk_en) begin\n            case (current_state)\n                IDLE, COMPLETE: begin\n                    I2C_SCL <= 1'b1;\n                end\n                \n                START: begin\n                    I2C_SCL <= 1'b1; // SCL stays high during start condition\n                end\n                \n                STOP: begin\n                    I2C_SCL <= 1'b1; // SCL goes high before stop condition\n                end\n                \n                default: begin\n                    I2C_SCL <= ~I2C_SCL; // Toggle SCL for data transfer\n                end\n            endcase\n        end\n    end\n    \n    // Output data register\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            data_out <= 8'd0;\n        end else if (i2c_clk_en && current_state == DATA_NACK) begin\n            data_out <= shift_reg;\n        end\n    end\n    \n    // Control signals\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            busy <= 1'b0;\n            I2C_En <= 1'b0;\n        end else begin\n            busy <= (current_state != IDLE);\n            I2C_En <= (current_state != IDLE && current_state != COMPLETE);\n        end\n    end\n    \n    // Bidirectional SDA control\n    assign I2C_SDA = sda_oe ? sda_out : 1'bz;\n\nendmodule\n```\n\nThis I2C master controller implementation includes:\n\n## Key Features:\n\n1. **State Machine**: Comprehensive state machine handling all I2C protocol phases\n2. **Clock Generation**: Configurable clock divider for proper I2C timing\n3. **Bidirectional SDA**: Proper handling of the bidirectional data line\n4. **Protocol Compliance**: Implements proper start/stop conditions, addressing, and ACK/NACK handling\n\n## State Machine States:\n\n- **IDLE**: Waiting for transaction initiation\n- **START**: Generating start condition\n- **ADDR_SEND**: Transmitting 7-bit address + R/W bit\n- **ADDR_ACK**: Waiting for address acknowledgment\n- **DATA_SEND**: Transmitting data (write operations)\n- **DATA_ACK**: Waiting for data acknowledgment\n- **DATA_READ**: Reading data from slave\n- **DATA_NACK**: Sending NACK after read\n- **STOP**: Generating stop condition\n- **COMPLETE**: Transaction complete\n\n## Key Design Considerations:\n\n1. **Clock Divider**: Adjustable parameter for different I2C frequencies\n2. **Edge Detection**: Proper start signal synchronization\n3. **Bidirectional Control**: SDA output enable logic for proper bus control\n4. **ACK Handling**: Automatic ACK detection and generation\n5. **Status Signals**: Clear busy and enable indicators\n\nThe module supports both 100kHz and 400kHz I2C operation by adjusting the `CLK_DIVIDER` parameter based on your system clock frequency.",
    "prompt_1": " Write a SystemVerilog module to implement an I2C master controller. The controller should generate proper start and stop conditions, handle data transfers with acknowledgments, and support both write and read operations. The design must include a clock divider to produce the appropriate I2C SCL frequency. The I2C module should have the following interface:\nmodule I2C_driver( input  logic       clk,         // System clock input  logic       rst,         // Asynchronous reset input  logic       I2C_Start,   // Initiate a transaction when high input  logic       RW,          // Read/Write control: 0 for write, 1 for read input  logic [9:0] slave_addr,  // 10-bit I2C slave address input  logic [7:0] data_in,     // Data to be written (for write transactions) inout  logic       I2C_SDA,     // I2C data line (bidirectional) output logic       I2C_SCL,     // I2C clock line output logic [7:0] data_out,    // Data received from slave (for read transactions) output logic       I2C_En,      // Module enable signal (active during transaction) output logic       busy         // Indicates the module is busy with a transaction ); The I2C master controller should operate as follows: Start Condition: When I2C_Start is asserted, generate a start condition on the I2C bus. Addressing: Transmit the 10-bit slave address along with a R/W bit. Data Transfer: For write transactions (RW = 0), send the provided data (data_in) and handle the ACK from the slave. For read transactions (RW = 1), read the data from the slave and output it on data_out while sending the necessary ACK/NACK. Stop Condition: After the data transfer, generate a stop condition on the bus. Clock Generation: Use a clock divider to derive the I2C SCL frequency from the system clock. Control Signals: The module should assert busy during active transactions and deassert it once the transaction is complete. Design your code with clear state machine implementation, proper handling of bidirectional signals (I2C_SDA), and ensure that all I2C protocol timing requirements are met.\n",
    "answer_1": "I'll design a comprehensive I2C master controller in SystemVerilog. Here's the complete implementation:\n\n```systemverilog\nmodule I2C_driver(\n    input  logic       clk,         // System clock\n    input  logic       rst,         // Asynchronous reset\n    input  logic       I2C_Start,   // Initiate a transaction when high\n    input  logic       RW,          // Read/Write control: 0 for write, 1 for read\n    input  logic [9:0] slave_addr,  // 10-bit I2C slave address\n    input  logic [7:0] data_in,     // Data to be written (for write transactions)\n    inout  logic       I2C_SDA,     // I2C data line (bidirectional)\n    output logic       I2C_SCL,     // I2C clock line\n    output logic [7:0] data_out,    // Data received from slave (for read transactions)\n    output logic       I2C_En,      // Module enable signal (active during transaction)\n    output logic       busy         // Indicates the module is busy with a transaction\n);\n\n    // State machine definitions\n    typedef enum logic [4:0] {\n        IDLE           = 5'b00000,\n        START          = 5'b00001,\n        ADDR_FIRST     = 5'b00010,\n        ADDR_FIRST_ACK = 5'b00011,\n        ADDR_SECOND    = 5'b00100,\n        ADDR_SECOND_ACK= 5'b00101,\n        WRITE_DATA     = 5'b00110,\n        WRITE_ACK      = 5'b00111,\n        READ_DATA      = 5'b01000,\n        READ_ACK       = 5'b01001,\n        STOP           = 5'b01010,\n        COMPLETE       = 5'b01011\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Clock divider for I2C SCL generation\n    // Assuming 100 MHz system clock, targeting 100 kHz I2C clock\n    // Clock divider value = 100MHz / (100kHz * 4) = 250\n    // We divide by 4 because we need 4 clock phases for each SCL period\n    localparam CLK_DIVIDER = 250;\n    localparam CLK_COUNTER_WIDTH = $clog2(CLK_DIVIDER);\n    \n    logic [CLK_COUNTER_WIDTH-1:0] clk_counter;\n    logic [1:0] scl_phase;  // 4 phases: 00, 01, 10, 11\n    logic scl_tick;\n    \n    // I2C signals\n    logic sda_out, sda_oe;  // SDA output and output enable\n    logic scl_out;\n    \n    // Internal registers\n    logic [10:0] addr_shift_reg;  // 11 bits: 10-bit addr + R/W bit\n    logic [7:0] data_shift_reg;\n    logic [7:0] read_data_reg;\n    logic [3:0] bit_counter;\n    logic ack_received;\n    logic transaction_rw;\n    \n    // Bidirectional SDA handling\n    assign I2C_SDA = sda_oe ? sda_out : 1'bz;\n    assign I2C_SCL = scl_out;\n    \n    // Clock divider and SCL generation\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            clk_counter <= 0;\n            scl_phase <= 2'b00;\n            scl_tick <= 1'b0;\n        end else begin\n            scl_tick <= 1'b0;\n            if (clk_counter >= CLK_DIVIDER - 1) begin\n                clk_counter <= 0;\n                scl_phase <= scl_phase + 1;\n                scl_tick <= 1'b1;\n            end else begin\n                clk_counter <= clk_counter + 1;\n            end\n        end\n    end\n    \n    // SCL generation based on phase\n    always_comb begin\n        case (scl_phase)\n            2'b00, 2'b01: scl_out = 1'b0;  // SCL low\n            2'b10, 2'b11: scl_out = 1'b1;  // SCL high\n        endcase\n    end\n    \n    // State machine - sequential logic\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n    \n    // State machine - combinational logic\n    always_comb begin\n        next_state = current_state;\n        \n        case (current_state)\n            IDLE: begin\n                if (I2C_Start) begin\n                    next_state = START;\n                end\n            end\n            \n            START: begin\n                if (scl_tick && scl_phase == 2'b01) begin\n                    next_state = ADDR_FIRST;\n                end\n            end\n            \n            ADDR_FIRST: begin\n                if (scl_tick && scl_phase == 2'b01 && bit_counter == 0) begin\n                    next_state = ADDR_FIRST_ACK;\n                end\n            end\n            \n            ADDR_FIRST_ACK: begin\n                if (scl_tick && scl_phase == 2'b01) begin\n                    if (ack_received) begin\n                        next_state = ADDR_SECOND;\n                    end else begin\n                        next_state = STOP;  // NACK received, abort\n                    end\n                end\n            end\n            \n            ADDR_SECOND: begin\n                if (scl_tick && scl_phase == 2'b01 && bit_counter == 0) begin\n                    next_state = ADDR_SECOND_ACK;\n                end\n            end\n            \n            ADDR_SECOND_ACK: begin\n                if (scl_tick && scl_phase == 2'b01) begin\n                    if (ack_received) begin\n                        if (transaction_rw) begin\n                            next_state = READ_DATA;\n                        end else begin\n                            next_state = WRITE_DATA;\n                        end\n                    end else begin\n                        next_state = STOP;  // NACK received, abort\n                    end\n                end\n            end\n            \n            WRITE_DATA: begin\n                if (scl_tick && scl_phase == 2'b01 && bit_counter == 0) begin\n                    next_state = WRITE_ACK;\n                end\n            end\n            \n            WRITE_ACK: begin\n                if (scl_tick && scl_phase == 2'b01) begin\n                    next_state = STOP;\n                end\n            end\n            \n            READ_DATA: begin\n                if (scl_tick && scl_phase == 2'b01 && bit_counter == 0) begin\n                    next_state = READ_ACK;\n                end\n            end\n            \n            READ_ACK: begin\n                if (scl_tick && scl_phase == 2'b01) begin\n                    next_state = STOP;\n                end\n            end\n            \n            STOP: begin\n                if (scl_tick && scl_phase == 2'b01) begin\n                    next_state = COMPLETE;\n                end\n            end\n            \n            COMPLETE: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n    \n    // Control logic and data handling\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sda_out <= 1'b1;\n            sda_oe <= 1'b1;\n            addr_shift_reg <= 11'b0;\n            data_shift_reg <= 8'b0;\n            read_data_reg <= 8'b0;\n            bit_counter <= 4'b0;\n            ack_received <= 1'b0;\n            transaction_rw <= 1'b0;\n            data_out <= 8'b0;\n            busy <= 1'b0;\n            I2C_En <= 1'b0;\n        end else begin\n            case (current_state)\n                IDLE: begin\n                    sda_out <= 1'b1;\n                    sda_oe <= 1'b1;\n                    busy <= 1'b0;\n                    I2C_En <= 1'b0;\n                    if (I2C_Start) begin\n                        // Prepare for transaction\n                        addr_shift_reg <= {1'b1, 1'b1, 1'b1, 1'b1, 1'b0, slave_addr[9:6], 1'b0}; // First byte: 11110XX0\n                        data_shift_reg <= {slave_addr[5:0], RW, 1'b0}; // Second byte: lower 6 bits + R/W\n                        transaction_rw <= RW;\n                        busy <= 1'b1;\n                        I2C_En <= 1'b1;\n                    end\n                end\n                \n                START: begin\n                    if (scl_tick && scl_phase == 2'b11) begin\n                        // Generate start condition: SDA goes low while SCL is high\n                        sda_out <= 1'b0;\n                        bit_counter <= 4'd7;  // Prepare for 8-bit transmission\n                    end\n                end\n                \n                ADDR_FIRST: begin\n                    if (scl_tick) begin\n                        case (scl_phase)\n                            2'b00: begin\n                                // Setup data during SCL low\n                                sda_out <= addr_shift_reg[bit_counter];\n                                sda_oe <= 1'b1;\n                            end\n                            2'b01: begin\n                                // Data should be stable during SCL low to high transition\n                                if (bit_counter > 0) begin\n                                    bit_counter <= bit_counter - 1;\n                                end else begin\n                                    // Prepare for ACK\n                                    sda_oe <= 1'b0;  // Release SDA for slave ACK\n                                end\n                            end\n                        endcase\n                    end\n                end\n                \n                ADDR_FIRST_ACK: begin\n                    if (scl_tick && scl_phase == 2'b10) begin\n                        // Sample ACK during SCL high\n                        ack_received <= ~I2C_SDA;\n                    end else if (scl_tick && scl_phase == 2'b01) begin\n                        // Prepare for next byte\n                        sda_oe <= 1'b1;\n                        bit_counter <= 4'd7;\n                    end\n                end\n                \n                ADDR_SECOND: begin\n                    if (scl_tick) begin\n                        case (scl_phase)\n                            2'b00: begin\n                                sda_out <= data_shift_reg[bit_counter];\n                                sda_oe <= 1'b1;\n                            end\n                            2'b01: begin\n                                if (bit_counter > 0) begin\n                                    bit_counter <= bit_counter - 1;\n                                end else begin\n                                    sda_oe <= 1'b0;  // Release SDA for slave ACK\n                                end\n                            end\n                        endcase\n                    end\n                end\n                \n                ADDR_SECOND_ACK: begin\n                    if (scl_tick && scl_phase == 2'b10) begin\n                        ack_received <= ~I2C_SDA;\n                    end else if (scl_tick && scl_phase == 2'b01) begin\n                        sda_oe <= 1'b1;\n                        bit_counter <= 4'd7;\n                        if (transaction_rw == 1'b0) begin\n                            // Prepare write data\n                            data_shift_reg <= data_in;\n                        end\n                    end\n                end\n                \n                WRITE_DATA: begin\n                    if (scl_tick) begin\n                        case (scl_phase)\n                            2'b00: begin\n                                sda_out <= data_shift_reg[bit_counter];\n                                sda_oe <= 1'b1;\n                            end\n                            2'b01: begin\n                                if (bit_counter > 0) begin\n                                    bit_counter <= bit_counter - 1;\n                                end else begin\n                                    sda_oe <= 1'b0;  // Release SDA for slave ACK\n                                end\n                            end\n                        endcase\n                    end\n                end\n                \n                WRITE_ACK: begin\n                    if (scl_tick && scl_phase == 2'b10) begin\n                        ack_received <= ~I2C_SDA;\n                    end else if (scl_tick && scl_phase == 2'b01) begin\n                        sda_oe <= 1'b1;\n                    end\n                end\n                \n                READ_DATA: begin\n                    if (scl_tick) begin\n                        case (scl_phase)\n                            2'b00: begin\n                                sda_oe <= 1'b0;  // Release SDA for slave data\n                            end\n                            2'b10: begin\n                                // Sample data during SCL high\n                                read_data_reg[bit_counter] <= I2C_SDA;\n                            end\n                            2'b01: begin\n                                if (bit_counter > 0) begin\n                                    bit_counter <= bit_counter - 1;\n                                end else begin\n                                    data_out <= read_data_reg;\n                                end\n                            end\n                        endcase\n                    end\n                end\n                \n                READ_ACK: begin\n                    if (scl_tick) begin\n                        case (scl_phase)\n                            2'b00: begin\n                                // Send NACK to indicate end of read\n                                sda_out <= 1'b1;\n                                sda_oe <= 1'b1;\n                            end\n                        endcase\n                    end\n                end\n                \n                STOP: begin\n                    if (scl_tick) begin\n                        case (scl_phase)\n                            2'b00: begin\n                                sda_out <= 1'b0;\n                                sda_oe <= 1'b1;\n                            end\n                            2'b10: begin\n                                // Generate stop condition: SDA goes high while SCL is high\n                                sda_out <= 1'b1;\n                            end\n                        endcase\n                    end\n                end\n                \n                COMPLETE: begin\n                    busy <= 1'b0;\n                    I2C_En <= 1'b0;\n                end\n            endcase\n        end\n    end\n\nendmodule\n```\n\nThis I2C master controller implementation includes:\n\n## Key Features:\n\n1. **10-bit Addressing Support**: Handles 10-bit slave addresses using the standard I2C 10-bit addressing protocol (first byte: 11110XX0, second byte: lower 6 bits + R/W).\n\n2. **Clock Generation**: Configurable clock divider that generates proper I2C SCL timing from the system clock.\n\n3. **Bidirectional SDA Handling**: Proper tristate control for the bidirectional SDA line.\n\n4. **Complete State Machine**: Comprehensive state machine covering all I2C protocol phases.\n\n5. **Protocol Compliance**: Generates proper START and STOP conditions, handles ACK/NACK responses.\n\n## State Machine Flow:\n\n- **IDLE**: Wait for transaction initiation\n- **START**: Generate start condition\n- **ADDR_FIRST/ADDR_FIRST_ACK**: Send first address byte and handle ACK\n- **ADDR_SECOND/ADDR_SECOND_ACK**: Send second address byte and handle ACK\n- **WRITE_DATA/WRITE_ACK**: Write data and handle ACK (for write operations)\n- **READ_DATA/READ_ACK**: Read data and send NACK (for read operations)\n- **STOP**: Generate stop condition\n- **COMPLETE**: Transaction complete\n\n## Timing Considerations:\n\n- Clock divider creates 4 phases per SCL period for proper setup/hold timing\n- Data changes during SCL low phases\n- Data sampling occurs during SCL high phases\n- START/STOP conditions are generated with proper timing relationships\n\nThe module is designed to be robust and handle all standard I2C protocol requirements while providing clear status signals for system integration."
}
