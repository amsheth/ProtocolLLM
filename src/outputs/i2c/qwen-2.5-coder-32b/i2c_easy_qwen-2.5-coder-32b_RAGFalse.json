{
    "prompt_0": " Write a SystemVerilog module to implement an I2C master controller. The controller should generate proper start and stop conditions, handle data transfers with acknowledgments, and support both write and read operations. The design must include a clock divider to produce the appropriate I2C SCL frequency. The I2C module should have the following interface:\nmodule I2C_driver( input  logic       clk,         // System clock input  logic       rst,         // Asynchronous reset input  logic       I2C_Start,   // Initiate a transaction when high input  logic       RW,          // Read/Write control: 0 for write, 1 for read input  logic [6:0] slave_addr,  // 7-bit I2C slave address input  logic [7:0] data_in,     // Data to be written (for write transactions) inout  logic       I2C_SDA,     // I2C data line (bidirectional) output logic       I2C_SCL,     // I2C clock line output logic [7:0] data_out,    // Data received from slave (for read transactions) output logic       I2C_En,      // Module enable signal (active during transaction) output logic       busy         // Indicates the module is busy with a transaction ); The I2C master controller should operate as follows: Start Condition: When I2C_Start is asserted, generate a start condition on the I2C bus. Addressing: Transmit the 7-bit slave address along with a R/W bit. Data Transfer: For write transactions (RW = 0), send the provided data (data_in) and handle the ACK from the slave. For read transactions (RW = 1), read the data from the slave and output it on data_out while sending the necessary ACK/NACK. Stop Condition: After the data transfer, generate a stop condition on the bus. Clock Generation: Use a clock divider to derive the I2C SCL frequency from the system clock. Control Signals: The module should assert busy during active transactions and deassert it once the transaction is complete. Design your code with clear state machine implementation, proper handling of bidirectional signals (I2C_SDA), and ensure that all I2C protocol timing requirements are met.\n",
    "answer_0": "```systemverilog\nmodule I2C_driver(\n    input  logic       clk,         // System clock input\n    input  logic       rst,         // Asynchronous reset input\n    input  logic       I2C_Start,   // Initiate a transaction when high\n    input  logic       RW,          // Read/Write control: 0 for write, 1 for read\n    input  logic [6:0] slave_addr,  // 7-bit I2C slave address\n    input  logic [7:0] data_in,     // Data to be written (for write transactions)\n    inout  logic       I2C_SDA,     // I2C data line (bidirectional)\n    output logic       I2C_SCL,     // I2C clock line\n    output logic [7:0] data_out,    // Data received from slave (for read transactions)\n    output logic       I2C_En,      // Module enable signal (active during transaction)\n    output logic       busy         // Indicates the module is busy with a transaction\n);\n\n    // Parameters\n    parameter CLK_FREQ = 50_000_000; // System clock frequency in Hz\n    parameter I2C_FREQ = 100_000;   // Desired I2C frequency in Hz\n    parameter CLK_DIV  = CLK_FREQ / (5 * I2C_FREQ); // Clock divider factor for 50% duty cycle\n\n    // Internal signals\n    logic [15:0] clk_div_cnt; // Clock divider counter\n    logic        scl;           // Internal SCL signal\n    logic        scl_en;        // SCL enable signal\n    logic        sda;           // Internal SDA signal\n    logic        sda_en;        // SDA enable signal\n    logic [3:0]  state;         // State machine state\n    logic [3:0]  next_state;    // Next state machine state\n    logic [2:0]  bit_cnt;       // Bit counter for data/address transfer\n    logic [7:0]  shift_reg;     // Shift register for data/address transfer\n    logic        start_cond;    // Start condition flag\n    logic        stop_cond;     // Stop condition flag\n    logic        ack;           // Acknowledge signal from slave\n\n    // Clock divider\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            clk_div_cnt <= '0;\n            scl <= 1'b1;\n        end else if (scl_en) begin\n            if (clk_div_cnt == CLK_DIV - 1) begin\n                clk_div_cnt <= '0;\n                scl <= ~scl;\n            end else begin\n                clk_div_cnt <= clk_div_cnt + 1;\n            end\n        end\n    end\n\n    // SCL enable\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            scl_en <= 1'b0;\n        else if (state == IDLE && I2C_Start)\n            scl_en <= 1'b1;\n        else if (state == STOP)\n            scl_en <= 1'b0;\n    end\n\n    // State machine\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    always_comb begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (I2C_Start) begin\n                    next_state = START;\n                end\n            end\n            START: begin\n                next_state = ADDR;\n            end\n            ADDR: begin\n                if (bit_cnt == 0) begin\n                    next_state = RW ? RDATA : WDATA;\n                end\n            end\n            WDATA: begin\n                if (bit_cnt == 0) begin\n                    next_state = ACK;\n                end\n            end\n            ACK: begin\n                next_state = RW ? RDATA : STOP;\n            end\n            RDATA: begin\n                if (bit_cnt == 0) begin\n                    next_state = RW ? ACK : STOP;\n                end\n            end\n            STOP: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Bit counter\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            bit_cnt <= 3'b111;\n        else if (state == START || state == ACK || state == STOP)\n            bit_cnt <= 3'b111;\n        else if (scl && ~scl_en)\n            bit_cnt <= bit_cnt - 1;\n    end\n\n    // Shift register\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            shift_reg <= {slave_addr, RW};\n        else if (state == ADDR && scl && ~scl_en)\n            shift_reg <= {shift_reg[6:0], 1'b0};\n        else if (state == WDATA && scl && ~scl_en)\n            shift_reg <= {shift_reg[6:0], 1'b0};\n        else if (state == RDATA && scl && ~scl_en)\n            shift_reg <= {shift_reg[6:0], I2C_SDA};\n    end\n\n    // SDA enable\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            sda_en <= 1'b0;\n        else if (state == START || state == STOP)\n            sda_en <= 1'b1;\n        else if (state == ADDR || state == WDATA)\n            sda_en <= 1'b1;\n        else if (state == ACK || state == RDATA)\n            sda_en <= 1'b0;\n    end\n\n    // SDA output\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            sda <= 1'b1;\n        else if (sda_en)\n            sda <= (state == START) ? 1'b0 : (state == STOP) ? 1'b1 : shift_reg[7];\n        else if (state == ACK)\n            sda <= 1'b0; // Master sends ACK (low)\n    end\n\n    // I2C_SCL output\n    assign I2C_SCL = scl;\n\n    // I2C_SDA bidirectional handling\n    assign I2C_SDA = sda_en ? sda : 1'bz;\n\n    // Data output\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            data_out <= '0;\n        else if (state == RDATA && scl && ~scl_en)\n            data_out <= {data_out[6:0], I2C_SDA};\n    end\n\n    // Busy signal\n    assign busy = (state != IDLE);\n\n    // Module enable signal\n    assign I2C_En = (state != IDLE);\n\nendmodule\n\n// State definitions\nlocalparam IDLE   = 4'b0000;\nlocalparam START  = 4'b0001;\nlocalparam ADDR   = 4'b0010;\nlocalparam WDATA  = 4'b0011;\nlocalparam ACK    = 4'b0100;\nlocalparam RDATA  = 4'b0101;\nlocalparam STOP   = 4'b0110;\n```\n\nThis SystemVerilog module implements an I2C master controller with a state machine to handle start and stop conditions, address transmission, data transfer, and acknowledgment. The clock divider generates the appropriate I2C SCL frequency from the system clock. The module handles bidirectional I2C_SDA line and ensures proper timing for I2C protocol."
}
