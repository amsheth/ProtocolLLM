{
    "prompt_0": " Write a SystemVerilog module to implement an I2C master controller. The controller should generate proper start and stop conditions, handle data transfers with acknowledgments, and support both write and read operations. The design must include a clock divider to produce the appropriate I2C SCL frequency. The I2C module should have the following interface:\nmodule I2C_driver( input  logic       clk,         // System clock input  logic       rst,         // Asynchronous reset input  logic       I2C_Start,   // Initiate a transaction when high input  logic       RW,          // Read/Write control: 0 for write, 1 for read input  logic [6:0] slave_addr,  // 7-bit I2C slave address input  logic [7:0] data_in,     // Data to be written (for write transactions) inout  logic       I2C_SDA,     // I2C data line (bidirectional) output logic       I2C_SCL,     // I2C clock line output logic [7:0] data_out,    // Data received from slave (for read transactions) output logic       I2C_En,      // Module enable signal (active during transaction) output logic       busy         // Indicates the module is busy with a transaction ); The I2C master controller should operate as follows: Start Condition: When I2C_Start is asserted, generate a start condition on the I2C bus. Addressing: Transmit the 7-bit slave address along with a R/W bit. Data Transfer: For write transactions (RW = 0), send the provided data (data_in) and handle the ACK from the slave. For read transactions (RW = 1), read the data from the slave and output it on data_out while sending the necessary ACK/NACK. Stop Condition: After the data transfer, generate a stop condition on the bus. Clock Generation: Use a clock divider to derive the I2C SCL frequency from the system clock. Control Signals: The module should assert busy during active transactions and deassert it once the transaction is complete. Design your code with clear state machine implementation, proper handling of bidirectional signals (I2C_SDA), and ensure that all I2C protocol timing requirements are met.\n",
    "answer_0": "Creating an I2C master controller in SystemVerilog involves defining a state machine to handle the different phases of the I2C protocol: start condition, addressing, data transfer, and stop condition. Below is a simplified implementation of such a module.\n\n```systemverilog\nmodule I2C_driver(\n    input  logic       clk,         // System clock input\n    input  logic       rst,         // Asynchronous reset input\n    input  logic       I2C_Start,   // Initiate a transaction when high input\n    input  logic       RW,          // Read/Write control: 0 for write, 1 for read\n    input  logic [6:0] slave_addr,  // 7-bit I2C slave address\n    input  logic [7:0] data_in,     // Data to be written (for write transactions)\n    inout  logic       I2C_SDA,     // I2C data line (bidirectional)\n    output logic       I2C_SCL,     // I2C clock line\n    output logic [7:0] data_out,    // Data received from slave (for read transactions)\n    output logic       I2C_En,      // Module enable signal (active during transaction)\n    output logic       busy         // Indicates the module is busy with a transaction\n);\n\n    // Clock divider parameters\n    parameter int CLK_DIV = 100;  // Adjust this to get the desired SCL frequency from clk\n\n    // State machine states\n    typedef enum logic [3:0] {\n        IDLE, START, ADDR_SEND, R_W_SEND, DATA_SEND, DATA_RECEIVE,\n        ACK_NACK_CHECK, STOP, ERROR\n    } state_t;\n\n    state_t current_state, next_state;\n    logic [7:0] bit_cnt;  // Bit counter for data/address transfer\n    logic [7:0] data_reg; // Register to hold the byte being sent/received\n    logic scl_en;         // Enable signal for SCL generation\n    logic scl_pulse;      // Pulse signal for SCL transitions\n    logic scl_rst_cnt;    // Reset counter for SCL pulse generation\n    logic sda_out, sda_dir;  // SDA output and direction control\n\n    // Clock divider logic\n    logic [7:0] clk_div_counter;\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            clk_div_counter <= '0;\n            scl_pulse <= 0;\n        end else if (scl_en && !busy) begin\n            if (clk_div_counter == CLK_DIV - 1) begin\n                clk_div_counter <= '0;\n                scl_pulse <= ~scl_pulse; // Toggle SCL pulse\n            end else begin\n                clk_div_counter <= clk_div_counter + 1;\n            end\n        end\n    end\n\n    assign I2C_SCL = scl_pulse;\n\n    // State machine to handle I2C transactions\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n\n    always_comb begin\n        next_state = current_state;\n        scl_en = 0;\n        sda_out = 'Z; // Default to high-impedance for SDA\n        sda_dir = 1'b1; // Default direction is input (tri-state)\n        busy = 1'b1;\n\n        case (current_state)\n            IDLE: begin\n                if (I2C_Start) begin\n                    next_state = START;\n                    scl_en = 1;\n                    busy = 1'b0;\n                end else begin\n                    busy = 1'b0;\n                end\n            end\n\n            START: begin\n                sda_dir = 1'b0; // SDA is output\n                sda_out = 0;    // Generate start condition\n                if (scl_pulse) begin\n                    scl_rst_cnt = 1;\n                    next_state = ADDR_SEND;\n                end\n            end\n\n            ADDR_SEND: begin\n                data_reg = {slave_addr, RW}; // Load address and R/W bit\n                scl_en = 1;\n                sda_dir = 1'b0; // SDA is output\n                if (scl_pulse) begin\n                    if (bit_cnt < 8) begin\n                        sda_out = data_reg[7 - bit_cnt]; // Send bits MSB first\n                        bit_cnt++;\n                    end else begin\n                        next_state = ACK_NACK_CHECK;\n                        scl_rst_cnt = 1;\n                        bit_cnt = '0;\n                    end\n                end\n            end\n\n            R_W_SEND: begin\n                data_reg = RW; // Load R/W bit\n                scl_en = 1;\n                sda_dir = 1'b0; // SDA is output\n                if (scl_pulse) begin\n                    if (bit_cnt < 8) begin\n                        sda_out = data_reg[7 - bit_cnt]; // Send bits MSB first\n                        bit_cnt++;\n                    end else begin\n                        next_state = ACK_NACK_CHECK;\n                        scl_rst_cnt = 1;\n                        bit_cnt = '0;\n                    end\n                end\n            end\n\n            DATA_SEND: begin\n                data_reg = data_in; // Load data to send\n                scl_en = 1;\n                sda_dir = 1'b0; // SDA is output\n                if (scl_pulse) begin\n                    if (bit_cnt < 8) begin\n                        sda_out = data_reg[7 - bit_cnt]; // Send bits MSB first\n                        bit_cnt++;\n                    end else begin\n                        next_state = ACK_NACK_CHECK;\n                        scl_rst_cnt = 1;\n                        bit_cnt = '0;\n                    end\n                end\n            end\n\n            DATA_RECEIVE: begin\n                scl_en = 1;\n                sda_dir = 1'b1; // SDA is input\n                if (scl_pulse) begin\n                    if (bit_cnt < 8) begin\n                        data_out[7 - bit_cnt] = I2C_SDA; // Receive bits MSB first\n                        bit_cnt++;\n                    end else begin\n                        next_state = STOP;\n                        scl_rst_cnt = 1;\n                        bit_cnt = '0;\n                    end\n                end\n            end\n\n            ACK_NACK_CHECK: begin\n                scl_en = 1;\n                sda_dir = 1'b1; // SDA is input\n                if (scl_pulse) begin\n                    if (I2C_SDA) begin\n                        next_state = ERROR; // NACK received\n                    end else begin\n                        if (!RW)\n                            next_state = DATA_SEND;\n                        else\n                            next_state = DATA_RECEIVE;\n                    end\n                    scl_rst_cnt = 1;\n                end\n            end\n\n            STOP: begin\n                sda_dir = 1'b0; // SDA is output\n                sda_out = 0;    // Set SDA low\n                if (scl_pulse) begin\n                    next_state = IDLE;\n                    scl_rst_cnt = 1;\n                    busy = 1'b0;\n                end else begin\n                    sda_out = 1; // Release SDA to high\n                end\n            end\n\n            ERROR: begin\n                // Handle error state\n                next_state = IDLE;\n                scl_rst_cnt = 1;\n                busy = 1'b0;\n            end\n\n            default:\n                next_state = IDLE;\n        endcase\n    end\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            bit_cnt <= '0;\n        else if (scl_rst_cnt)\n            bit_cnt <= '0;\n    end\n\nendmodule\n```\n\n### Explanation:\n- **Clock and Reset**: The module is synchronous to a clock signal (`clk`) and can be reset using an active-high reset signal (`rst`).\n- **State Machine**: The state machine handles different stages of the I2C transaction, including start, address send, data send/receive, ACK/NACK check, and stop.\n- **Data Handling**: Data is sent/received MSB first. For sending, data is loaded into `data_reg`, and bits are shifted out on each clock pulse. For receiving, bits are sampled into `data_out`.\n- **Control Signals**:\n  - `scl_en` enables the SCL clock generation.\n  - `sda_dir` controls whether SDA is an input or output.\n  - `busy` indicates if a transaction is in progress.\n\n### Notes:\n- This implementation assumes a simple I2C protocol and does not include advanced features like repeated starts, error handling beyond basic ACK/NACK checks, or clock stretching.\n- The module is designed to be used with a specific clock frequency (`CLK_DIV`) that determines the SCL frequency. Adjust `CLK_DIV` based on your system's clock speed and desired I2C bus speed.\n\nThis Verilog code provides a basic framework for an I2C master controller. You can expand it further by adding more features and error handling as needed.",
    "prompt_1": " Write a SystemVerilog module to implement an I2C master controller. The controller should generate proper start and stop conditions, handle data transfers with acknowledgments, and support both write and read operations. The design must include a clock divider to produce the appropriate I2C SCL frequency. The I2C module should have the following interface:\nmodule I2C_driver( input  logic       clk,         // System clock input  logic       rst,         // Asynchronous reset input  logic       I2C_Start,   // Initiate a transaction when high input  logic       RW,          // Read/Write control: 0 for write, 1 for read input  logic [9:0] slave_addr,  // 10-bit I2C slave address input  logic [7:0] data_in,     // Data to be written (for write transactions) inout  logic       I2C_SDA,     // I2C data line (bidirectional) output logic       I2C_SCL,     // I2C clock line output logic [7:0] data_out,    // Data received from slave (for read transactions) output logic       I2C_En,      // Module enable signal (active during transaction) output logic       busy         // Indicates the module is busy with a transaction ); The I2C master controller should operate as follows: Start Condition: When I2C_Start is asserted, generate a start condition on the I2C bus. Addressing: Transmit the 10-bit slave address along with a R/W bit. Data Transfer: For write transactions (RW = 0), send the provided data (data_in) and handle the ACK from the slave. For read transactions (RW = 1), read the data from the slave and output it on data_out while sending the necessary ACK/NACK. Stop Condition: After the data transfer, generate a stop condition on the bus. Clock Generation: Use a clock divider to derive the I2C SCL frequency from the system clock. Control Signals: The module should assert busy during active transactions and deassert it once the transaction is complete. Design your code with clear state machine implementation, proper handling of bidirectional signals (I2C_SDA), and ensure that all I2C protocol timing requirements are met.\n",
    "answer_1": "Creating an I2C master controller in SystemVerilog involves designing a state machine to handle various stages of the I2C protocol. Below is a detailed implementation of such a module, including a clock divider for generating the appropriate I2C SCL frequency.\n\n```systemverilog\nmodule I2C_driver(\n    input  logic       clk,         // System clock input\n    input  logic       rst,         // Asynchronous reset input\n    input  logic       I2C_Start,   // Initiate a transaction when high input\n    input  logic       RW,          // Read/Write control: 0 for write, 1 for read input\n    input  logic [9:0] slave_addr,  // 10-bit I2C slave address input\n    input  logic [7:0] data_in,     // Data to be written (for write transactions)\n    inout  logic       I2C_SDA,     // I2C data line (bidirectional)\n    output logic       I2C_SCL,     // I2C clock line\n    output logic [7:0] data_out,    // Data received from slave (for read transactions)\n    output logic       I2C_En,      // Module enable signal (active during transaction)\n    output logic       busy         // Indicates the module is busy with a transaction\n);\n\n// Constants for I2C timing and clock division\nlocalparam CLK_DIV = 100;          // Example clock divider value for 100MHz clk -> 1MHz SCL\nlocalparam BIT_WIDTH = 9;           // Number of bits to transfer (including start/stop)\nlocalparam ADDR_WIDTH = 10;         // Width of the slave address\n\n// Clock divider and state machine signals\nlogic [$clog2(CLK_DIV)-1:0] clk_div_cnt;\nlogic scl_clk;\n\n// State machine states\ntypedef enum logic [3:0] {\n    IDLE,\n    START_COND,\n    ADDR_TRANS,\n    DATA_TRANS,\n    STOP_COND,\n    DONE\n} i2c_state_t;\n\ni2c_state_t state, next_state;\n\n// Internal signals\nlogic [ADDR_WIDTH-1:0] addr_reg;\nlogic [7:0] data_reg;\nlogic bit_cnt_done;\nlogic bit_cnt;\nlogic start_cond_done;\nlogic stop_cond_done;\nlogic write_ack_error;\nlogic read_nack_error;\n\nassign I2C_En = (state != IDLE);\nassign busy = (state != IDLE);\n\n// Clock divider\nalways_ff @(posedge clk or posedge rst) begin\n    if (rst) begin\n        clk_div_cnt <= '0;\n        scl_clk <= 1'b1; // Start with SCL high\n    end else begin\n        if (clk_div_cnt == CLK_DIV-1) begin\n            clk_div_cnt <= '0;\n            scl_clk <= ~scl_clk; // Toggle SCL\n        end else begin\n            clk_div_cnt <= clk_div_cnt + 1;\n        end\n    end\nend\n\n// I2C_SCL output assignment\nassign I2C_SCL = scl_clk;\n\n// State machine transition logic\nalways_ff @(posedge scl_clk or posedge rst) begin\n    if (rst)\n        state <= IDLE;\n    else\n        state <= next_state;\nend\n\n// State machine combinational logic\nalways_comb begin\n    next_state = state;\n    case (state)\n        IDLE: begin\n            if (I2C_Start)\n                next_state = START_COND;\n        end\n        START_COND: begin\n            if (start_cond_done)\n                next_state = ADDR_TRANS;\n        end\n        ADDR_TRANS: begin\n            if (bit_cnt_done) begin\n                if (RW == 1'b0) // Write operation\n                    next_state = DATA_TRANS;\n                else if (RW == 1'b1) // Read operation\n                    next_state = DATA_TRANS;\n            end\n        end\n        DATA_TRANS: begin\n            if (bit_cnt_done)\n                if (write_ack_error || read_nack_error)\n                    next_state = STOP_COND; // Handle error conditions\n                else if (RW == 1'b0 && bit_cnt < (ADDR_WIDTH + 8)) // More data to write\n                    next_state = DATA_TRANS;\n                else if (RW == 1'b1 && bit_cnt < 2*(ADDR_WIDTH + 8)) // More data to read\n                    next_state = DATA_TRANS;\n                else\n                    next_state = STOP_COND; // All data transferred\n        end\n        STOP_COND: begin\n            if (stop_cond_done)\n                next_state = DONE;\n        end\n        DONE: begin\n            next_state = IDLE;\n        end\n    endcase\nend\n\n// Start condition generation\nlogic start_cond_gen;\n\nalways_ff @(posedge scl_clk or posedge rst) begin\n    if (rst) begin\n        start_cond_done <= 1'b0;\n        I2C_SDA <= 1'bz; // Tri-state SDA for bidirectional use\n    end else begin\n        case (state)\n            START_COND: begin\n                if (!scl_clk && I2C_SDA == 1'b1) begin // Start condition is falling edge of SCL with SDA high to low\n                    start_cond_gen = 1'b1;\n                    I2C_SDA <= 1'b0; // Pull SDA low for start condition\n                end else if (start_cond_gen && scl_clk) begin // Wait for rising edge of SCL after start condition generation\n                    start_cond_done <= 1'b1;\n                    I2C_SDA <= 1'bz; // Release SDA\n                end\n            end\n            default: begin\n                start_cond_gen = 1'b0;\n                start_cond_done <= 1'b0;\n            end\n        endcase\n    end\nend\n\n// Stop condition generation\nalways_ff @(posedge scl_clk or posedge rst) begin\n    if (rst)\n        stop_cond_done <= 1'b0;\n    else if (state == STOP_COND && !scl_clk && I2C_SDA == 1'b0) // Generate stop condition on falling edge of SCL with SDA low to high\n        stop_cond_done <= 1'b0;\n    else if (stop_cond_done && scl_clk)\n        stop_cond_done <= 1'b1; // Wait for rising edge of SCL after stop condition generation\nend\n\n// Bit counter logic\nalways_ff @(posedge scl_clk or posedge rst) begin\n    if (rst || state == IDLE)\n        bit_cnt <= '0;\n    else if (!scl_clk && bit_cnt < BIT_WIDTH)\n        bit_cnt <= bit_cnt + 1;\n    else\n        bit_cnt <= '0; // Reset after all bits are transferred\nend\n\n// Data transfer logic\nalways_ff @(posedge scl_clk or posedge rst) begin\n    if (rst || state == IDLE) begin\n        addr_reg <= slave_addr;\n        data_reg <= data_in;\n        write_ack_error <= 1'b0;\n        read_nack_error <= 1'b0;\n        bit_cnt_done <= 1'b0;\n        I2C_SDA <= 1'bz; // Tri-state SDA for bidirectional use\n    end else begin\n        case (state)\n            ADDR_TRANS, DATA_TRANS: begin\n                if (!scl_clk) begin // On falling edge of SCL, output data bit or ACK/NACK\n                    if (bit_cnt < ADDR_WIDTH)\n                        I2C_SDA <= addr_reg[ADDR_WIDTH-1-bit_cnt]; // Output address bits MSB first\n                    else if (RW == 1'b0 && bit_cnt < (ADDR_WIDTH + 8))\n                        I2C_SDA <= data_reg[7-(bit_cnt - ADDR_WIDTH)]; // Output data bits for write operation MSB first\n                    else if (RW == 1'b1) begin\n                        if (bit_cnt == ADDR_WIDTH)\n                            I2C_SDA <= 1'bz; // Release SDA to input mode for ACK/NACK during read operation\n                        else if (bit_cnt > ADDR_WIDTH && bit_cnt < (ADDR_WIDTH + 9))\n                            data_reg[7-(bit_cnt - ADDR_WIDTH - 1)] <= I2C_SDA; // Capture received data bits LSB first\n                    end\n\n                    if ((RW == 1'b0 || RW == 1'b1) && bit_cnt == BIT_WIDTH-1)\n                        bit_cnt_done <= 1'b1;\n                end else begin // On rising edge of SCL, read ACK/NACK or release SDA for next bit\n                    if (bit_cnt == ADDR_WIDTH-1 && RW == 1'b0) // Write operation, check ACK from slave on last address bit clock cycle\n                        write_ack_error <= I2C_SDA;\n                    else if (RW == 1'b1) begin // Read operation, output ACK/NACK to slave\n                        if (bit_cnt == ADDR_WIDTH-1)\n                            I2C_SDA <= 1'b0; // Send ACK for address reception\n                        else if (bit_cnt == BIT_WIDTH - 2) // Last data bit clock cycle\n                            I2C_SDA <= 1'b1; // Send NACK to indicate end of read operation\n                    end\n\n                    bit_cnt_done <= 1'b0;\n                end\n            end\n            default: begin\n                bit_cnt_done <= 1'b0;\n                I2C_SDA <= 1'bz; // Tri-state SDA for bidirectional use\n            end\n        endcase\n    end\nend\n\n// Output received data (for read operation)\nassign output_data = RW == 1'b1 ? data_reg : 'z;\n\nendmodule\n```"
}
