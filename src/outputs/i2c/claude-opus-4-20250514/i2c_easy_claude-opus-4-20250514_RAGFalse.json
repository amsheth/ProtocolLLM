{
    "prompt_0": " Write a SystemVerilog module to implement an I2C master controller. The controller should generate proper start and stop conditions, handle data transfers with acknowledgments, and support both write and read operations. The design must include a clock divider to produce the appropriate I2C SCL frequency. The I2C module should have the following interface:\nmodule I2C_driver( input  logic       clk,         // System clock input  logic       rst,         // Asynchronous reset input  logic       I2C_Start,   // Initiate a transaction when high input  logic       RW,          // Read/Write control: 0 for write, 1 for read input  logic [6:0] slave_addr,  // 7-bit I2C slave address input  logic [7:0] data_in,     // Data to be written (for write transactions) inout  logic       I2C_SDA,     // I2C data line (bidirectional) output logic       I2C_SCL,     // I2C clock line output logic [7:0] data_out,    // Data received from slave (for read transactions) output logic       I2C_En,      // Module enable signal (active during transaction) output logic       busy         // Indicates the module is busy with a transaction ); The I2C master controller should operate as follows: Start Condition: When I2C_Start is asserted, generate a start condition on the I2C bus. Addressing: Transmit the 7-bit slave address along with a R/W bit. Data Transfer: For write transactions (RW = 0), send the provided data (data_in) and handle the ACK from the slave. For read transactions (RW = 1), read the data from the slave and output it on data_out while sending the necessary ACK/NACK. Stop Condition: After the data transfer, generate a stop condition on the bus. Clock Generation: Use a clock divider to derive the I2C SCL frequency from the system clock. Control Signals: The module should assert busy during active transactions and deassert it once the transaction is complete. Design your code with clear state machine implementation, proper handling of bidirectional signals (I2C_SDA), and ensure that all I2C protocol timing requirements are met.\n",
    "answer_0": "Here's a comprehensive SystemVerilog implementation of an I2C master controller:\n\n```systemverilog\nmodule I2C_driver(\n    input  logic       clk,         // System clock\n    input  logic       rst,         // Asynchronous reset\n    input  logic       I2C_Start,   // Initiate a transaction when high\n    input  logic       RW,          // Read/Write control: 0 for write, 1 for read\n    input  logic [6:0] slave_addr,  // 7-bit I2C slave address\n    input  logic [7:0] data_in,     // Data to be written (for write transactions)\n    inout  logic       I2C_SDA,     // I2C data line (bidirectional)\n    output logic       I2C_SCL,     // I2C clock line\n    output logic [7:0] data_out,    // Data received from slave (for read transactions)\n    output logic       I2C_En,      // Module enable signal (active during transaction)\n    output logic       busy         // Indicates the module is busy with a transaction\n);\n\n    // Clock divider parameters (adjust based on system clock and desired I2C frequency)\n    localparam CLK_DIV = 100;  // For 100MHz system clock -> 100kHz I2C clock\n    localparam CLK_DIV_HALF = CLK_DIV / 2;\n    \n    // State machine states\n    typedef enum logic [3:0] {\n        IDLE,\n        START,\n        SEND_ADDR,\n        ADDR_ACK,\n        SEND_DATA,\n        DATA_ACK,\n        READ_DATA,\n        SEND_ACK,\n        SEND_NACK,\n        STOP,\n        STOP_WAIT\n    } state_t;\n    \n    state_t state, next_state;\n    \n    // Internal registers\n    logic [7:0] clk_counter;\n    logic       clk_pulse;\n    logic       scl_enable;\n    logic       sda_out;\n    logic       sda_enable;  // 1 = drive SDA, 0 = high-Z (for reading)\n    logic [7:0] shift_reg;\n    logic [3:0] bit_counter;\n    logic       saved_rw;\n    logic [6:0] saved_addr;\n    logic [7:0] saved_data;\n    \n    // Clock divider for I2C clock generation\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            clk_counter <= 8'd0;\n            clk_pulse <= 1'b0;\n        end else begin\n            if (clk_counter >= CLK_DIV - 1) begin\n                clk_counter <= 8'd0;\n                clk_pulse <= 1'b1;\n            end else begin\n                clk_counter <= clk_counter + 1'b1;\n                clk_pulse <= 1'b0;\n            end\n        end\n    end\n    \n    // SCL generation\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            I2C_SCL <= 1'b1;\n        end else if (scl_enable) begin\n            if (clk_counter < CLK_DIV_HALF)\n                I2C_SCL <= 1'b0;\n            else\n                I2C_SCL <= 1'b1;\n        end else begin\n            I2C_SCL <= 1'b1;  // SCL high when idle\n        end\n    end\n    \n    // Bidirectional SDA handling\n    assign I2C_SDA = sda_enable ? sda_out : 1'bz;\n    \n    // State machine - sequential logic\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            shift_reg <= 8'd0;\n            bit_counter <= 4'd0;\n            data_out <= 8'd0;\n            saved_rw <= 1'b0;\n            saved_addr <= 7'd0;\n            saved_data <= 8'd0;\n        end else if (clk_pulse) begin\n            state <= next_state;\n            \n            case (state)\n                IDLE: begin\n                    if (I2C_Start) begin\n                        saved_addr <= slave_addr;\n                        saved_rw <= RW;\n                        saved_data <= data_in;\n                    end\n                end\n                \n                START: begin\n                    shift_reg <= {saved_addr, saved_rw};\n                    bit_counter <= 4'd8;\n                end\n                \n                SEND_ADDR, SEND_DATA: begin\n                    if (bit_counter > 0) begin\n                        shift_reg <= {shift_reg[6:0], 1'b0};\n                        bit_counter <= bit_counter - 1'b1;\n                    end\n                end\n                \n                DATA_ACK: begin\n                    if (saved_rw) begin  // Read operation\n                        bit_counter <= 4'd8;\n                    end else begin  // Write operation\n                        shift_reg <= saved_data;\n                        bit_counter <= 4'd8;\n                    end\n                end\n                \n                READ_DATA: begin\n                    if (bit_counter > 0) begin\n                        shift_reg <= {shift_reg[6:0], I2C_SDA};\n                        bit_counter <= bit_counter - 1'b1;\n                    end else begin\n                        data_out <= shift_reg;\n                    end\n                end\n            endcase\n        end\n    end\n    \n    // State machine - combinational logic\n    always_comb begin\n        // Default values\n        next_state = state;\n        sda_out = 1'b1;\n        sda_enable = 1'b1;\n        scl_enable = 1'b0;\n        busy = 1'b1;\n        I2C_En = 1'b1;\n        \n        case (state)\n            IDLE: begin\n                busy = 1'b0;\n                I2C_En = 1'b0;\n                if (I2C_Start) begin\n                    next_state = START;\n                end\n            end\n            \n            START: begin\n                // Generate start condition: SDA goes low while SCL is high\n                sda_out = 1'b0;\n                scl_enable = 1'b0;  // Keep SCL high\n                next_state = SEND_ADDR;\n            end\n            \n            SEND_ADDR: begin\n                scl_enable = 1'b1;\n                if (bit_counter > 0) begin\n                    sda_out = shift_reg[7];\n                end else begin\n                    next_state = ADDR_ACK;\n                end\n            end\n            \n            ADDR_ACK: begin\n                scl_enable = 1'b1;\n                sda_enable = 1'b0;  // Release SDA for slave ACK\n                if (!I2C_SDA) begin  // Check for ACK (SDA low)\n                    next_state = DATA_ACK;\n                end else begin\n                    next_state = STOP;  // NACK received, abort\n                end\n            end\n            \n            DATA_ACK: begin\n                scl_enable = 1'b1;\n                if (saved_rw) begin  // Read operation\n                    next_state = READ_DATA;\n                end else begin  // Write operation\n                    next_state = SEND_DATA;\n                end\n            end\n            \n            SEND_DATA: begin\n                scl_enable = 1'b1;\n                if (bit_counter > 0) begin\n                    sda_out = shift_reg[7];\n                end else begin\n                    next_state = SEND_ACK;\n                end\n            end\n            \n            SEND_ACK: begin\n                scl_enable = 1'b1;\n                sda_enable = 1'b0;  // Release SDA for slave ACK\n                next_state = STOP;\n            end\n            \n            READ_DATA: begin\n                scl_enable = 1'b1;\n                sda_enable = 1'b0;  // Release SDA for reading\n                if (bit_counter == 0) begin\n                    next_state = SEND_NACK;\n                end\n            end\n            \n            SEND_NACK: begin\n                scl_enable = 1'b1;\n                sda_out = 1'b1;  // Send NACK (SDA high)\n                next_state = STOP;\n            end\n            \n            STOP: begin\n                // Generate stop condition: SDA goes high while SCL is high\n                scl_enable = 1'b0;  // SCL high\n                sda_out = 1'b0;     // Keep SDA low initially\n                next_state = STOP_WAIT;\n            end\n            \n            STOP_WAIT: begin\n                scl_enable = 1'b0;  // SCL high\n                sda_out = 1'b1;     // Release SDA (goes high)\n                next_state = IDLE;\n            end\n            \n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule\n```\n\nThis I2C master controller implementation includes:\n\n**Key Features:**\n1. **State Machine**: A comprehensive FSM that handles all I2C operations including START, addressing, data transfer, ACK/NACK handling, and STOP conditions.\n\n2. **Clock Divider**: Generates the I2C clock (SCL) from the system clock with configurable division ratio.\n\n3. **Bidirectional SDA Handling**: Uses tri-state logic for proper SDA control - drives low/high when transmitting, releases (high-Z) when receiving.\n\n4. **Protocol Compliance**:\n   - START condition: SDA falls while SCL is high\n   - STOP condition: SDA rises while SCL is high\n   - Data changes only when SCL is low\n   - Data sampling when SCL is high\n\n5. **Read/Write Operations**:\n   - Write: Sends slave address + W bit, then data byte\n   - Read: Sends slave address + R bit, then reads data byte\n\n6. **ACK/NACK Handling**:\n   - Checks for slave ACK after address and data transmission\n   - Sends NACK after reading data (single byte read)\n\n**Usage Notes:**\n- Adjust `CLK_DIV` parameter based on your system clock frequency and desired I2C speed\n- The module assumes single-byte transfers; extend for multi-byte support if needed\n- Add pull-up resistors to SDA and SCL lines in your top-level design\n- The module aborts transaction on NACK reception\n\nThis implementation provides a robust foundation for I2C communication and can be extended with features like clock stretching support, multi-master arbitration, or repeated start conditions as needed.",
    "prompt_1": " Write a SystemVerilog module to implement an I2C master controller. The controller should generate proper start and stop conditions, handle data transfers with acknowledgments, and support both write and read operations. The design must include a clock divider to produce the appropriate I2C SCL frequency. The I2C module should have the following interface:\nmodule I2C_driver( input  logic       clk,         // System clock input  logic       rst,         // Asynchronous reset input  logic       I2C_Start,   // Initiate a transaction when high input  logic       RW,          // Read/Write control: 0 for write, 1 for read input  logic [9:0] slave_addr,  // 10-bit I2C slave address input  logic [7:0] data_in,     // Data to be written (for write transactions) inout  logic       I2C_SDA,     // I2C data line (bidirectional) output logic       I2C_SCL,     // I2C clock line output logic [7:0] data_out,    // Data received from slave (for read transactions) output logic       I2C_En,      // Module enable signal (active during transaction) output logic       busy         // Indicates the module is busy with a transaction ); The I2C master controller should operate as follows: Start Condition: When I2C_Start is asserted, generate a start condition on the I2C bus. Addressing: Transmit the 10-bit slave address along with a R/W bit. Data Transfer: For write transactions (RW = 0), send the provided data (data_in) and handle the ACK from the slave. For read transactions (RW = 1), read the data from the slave and output it on data_out while sending the necessary ACK/NACK. Stop Condition: After the data transfer, generate a stop condition on the bus. Clock Generation: Use a clock divider to derive the I2C SCL frequency from the system clock. Control Signals: The module should assert busy during active transactions and deassert it once the transaction is complete. Design your code with clear state machine implementation, proper handling of bidirectional signals (I2C_SDA), and ensure that all I2C protocol timing requirements are met.\n",
    "answer_1": "Here's a comprehensive SystemVerilog implementation of an I2C master controller:\n\n```systemverilog\nmodule I2C_driver(\n    input  logic       clk,         // System clock\n    input  logic       rst,         // Asynchronous reset\n    input  logic       I2C_Start,   // Initiate a transaction when high\n    input  logic       RW,          // Read/Write control: 0 for write, 1 for read\n    input  logic [9:0] slave_addr,  // 10-bit I2C slave address\n    input  logic [7:0] data_in,     // Data to be written (for write transactions)\n    inout  logic       I2C_SDA,     // I2C data line (bidirectional)\n    output logic       I2C_SCL,     // I2C clock line\n    output logic [7:0] data_out,    // Data received from slave (for read transactions)\n    output logic       I2C_En,      // Module enable signal (active during transaction)\n    output logic       busy         // Indicates the module is busy with a transaction\n);\n\n    // Clock divider parameters (adjust based on system clock and desired I2C frequency)\n    parameter CLK_DIV = 100;  // For 100MHz system clock -> 250kHz SCL (standard mode)\n    \n    // State machine states\n    typedef enum logic [4:0] {\n        IDLE,\n        START,\n        SEND_ADDR_HIGH,\n        CHECK_ADDR_ACK1,\n        SEND_ADDR_LOW,\n        CHECK_ADDR_ACK2,\n        WRITE_DATA,\n        CHECK_DATA_ACK,\n        READ_DATA,\n        SEND_ACK,\n        SEND_NACK,\n        STOP,\n        HOLD_STOP\n    } state_t;\n    \n    state_t current_state, next_state;\n    \n    // Internal signals\n    logic [7:0] clk_div_cnt;\n    logic clk_pulse;\n    logic scl_enable;\n    logic sda_out;\n    logic sda_oe;  // SDA output enable\n    logic [3:0] bit_cnt;\n    logic [7:0] addr_high_byte;\n    logic [7:0] addr_low_byte;\n    logic [7:0] data_buffer;\n    logic ack_received;\n    \n    // Clock divider for I2C clock generation\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            clk_div_cnt <= '0;\n            clk_pulse <= 1'b0;\n        end else begin\n            if (clk_div_cnt >= CLK_DIV - 1) begin\n                clk_div_cnt <= '0;\n                clk_pulse <= 1'b1;\n            end else begin\n                clk_div_cnt <= clk_div_cnt + 1'b1;\n                clk_pulse <= 1'b0;\n            end\n        end\n    end\n    \n    // SCL generation\n    logic scl_clk;\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            scl_clk <= 1'b1;\n        end else if (clk_pulse) begin\n            if (scl_enable)\n                scl_clk <= ~scl_clk;\n            else\n                scl_clk <= 1'b1;\n        end\n    end\n    \n    assign I2C_SCL = scl_clk;\n    \n    // Bidirectional SDA handling\n    assign I2C_SDA = sda_oe ? sda_out : 1'bz;\n    \n    // State machine\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n    \n    // Next state logic\n    always_comb begin\n        next_state = current_state;\n        \n        case (current_state)\n            IDLE: begin\n                if (I2C_Start)\n                    next_state = START;\n            end\n            \n            START: begin\n                if (clk_pulse && scl_clk)\n                    next_state = SEND_ADDR_HIGH;\n            end\n            \n            SEND_ADDR_HIGH: begin\n                if (clk_pulse && !scl_clk && bit_cnt == 8)\n                    next_state = CHECK_ADDR_ACK1;\n            end\n            \n            CHECK_ADDR_ACK1: begin\n                if (clk_pulse && !scl_clk)\n                    next_state = SEND_ADDR_LOW;\n            end\n            \n            SEND_ADDR_LOW: begin\n                if (clk_pulse && !scl_clk && bit_cnt == 8)\n                    next_state = CHECK_ADDR_ACK2;\n            end\n            \n            CHECK_ADDR_ACK2: begin\n                if (clk_pulse && !scl_clk) begin\n                    if (RW)\n                        next_state = READ_DATA;\n                    else\n                        next_state = WRITE_DATA;\n                end\n            end\n            \n            WRITE_DATA: begin\n                if (clk_pulse && !scl_clk && bit_cnt == 8)\n                    next_state = CHECK_DATA_ACK;\n            end\n            \n            CHECK_DATA_ACK: begin\n                if (clk_pulse && !scl_clk)\n                    next_state = STOP;\n            end\n            \n            READ_DATA: begin\n                if (clk_pulse && !scl_clk && bit_cnt == 8)\n                    next_state = SEND_NACK;\n            end\n            \n            SEND_NACK: begin\n                if (clk_pulse && !scl_clk)\n                    next_state = STOP;\n            end\n            \n            STOP: begin\n                if (clk_pulse && scl_clk)\n                    next_state = HOLD_STOP;\n            end\n            \n            HOLD_STOP: begin\n                if (clk_pulse)\n                    next_state = IDLE;\n            end\n            \n            default: next_state = IDLE;\n        endcase\n    end\n    \n    // Output and control logic\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sda_out <= 1'b1;\n            sda_oe <= 1'b0;\n            bit_cnt <= '0;\n            data_buffer <= '0;\n            data_out <= '0;\n            busy <= 1'b0;\n            I2C_En <= 1'b0;\n            scl_enable <= 1'b0;\n            addr_high_byte <= '0;\n            addr_low_byte <= '0;\n        end else begin\n            case (current_state)\n                IDLE: begin\n                    sda_out <= 1'b1;\n                    sda_oe <= 1'b1;\n                    bit_cnt <= '0;\n                    busy <= 1'b0;\n                    I2C_En <= 1'b0;\n                    scl_enable <= 1'b0;\n                    if (I2C_Start) begin\n                        busy <= 1'b1;\n                        I2C_En <= 1'b1;\n                        // Prepare 10-bit address format\n                        addr_high_byte <= {5'b11110, slave_addr[9:8], 1'b0}; // 10-bit addressing + W\n                        addr_low_byte <= slave_addr[7:0];\n                        data_buffer <= data_in;\n                    end\n                end\n                \n                START: begin\n                    sda_oe <= 1'b1;\n                    if (clk_pulse && scl_clk) begin\n                        sda_out <= 1'b0;  // Start condition: SDA falls while SCL is high\n                        scl_enable <= 1'b1;\n                    end\n                end\n                \n                SEND_ADDR_HIGH: begin\n                    sda_oe <= 1'b1;\n                    if (clk_pulse && !scl_clk) begin\n                        if (bit_cnt < 8) begin\n                            sda_out <= addr_high_byte[7 - bit_cnt];\n                            bit_cnt <= bit_cnt + 1'b1;\n                        end else begin\n                            bit_cnt <= '0;\n                        end\n                    end\n                end\n                \n                CHECK_ADDR_ACK1: begin\n                    sda_oe <= 1'b0;  // Release SDA for slave ACK\n                    if (clk_pulse && scl_clk) begin\n                        ack_received <= !I2C_SDA;  // ACK is low\n                    end\n                end\n                \n                SEND_ADDR_LOW: begin\n                    sda_oe <= 1'b1;\n                    if (clk_pulse && !scl_clk) begin\n                        if (bit_cnt < 8) begin\n                            sda_out <= addr_low_byte[7 - bit_cnt];\n                            bit_cnt <= bit_cnt + 1'b1;\n                        end else begin\n                            bit_cnt <= '0;\n                        end\n                    end\n                end\n                \n                CHECK_ADDR_ACK2: begin\n                    sda_oe <= 1'b0;  // Release SDA for slave ACK\n                    if (clk_pulse && scl_clk) begin\n                        ack_received <= !I2C_SDA;\n                    end\n                end\n                \n                WRITE_DATA: begin\n                    sda_oe <= 1'b1;\n                    if (clk_pulse && !scl_clk) begin\n                        if (bit_cnt < 8) begin\n                            sda_out <= data_buffer[7 - bit_cnt];\n                            bit_cnt <= bit_cnt + 1'b1;\n                        end else begin\n                            bit_cnt <= '0;\n                        end\n                    end\n                end\n                \n                CHECK_DATA_ACK: begin\n                    sda_oe <= 1'b0;  // Release SDA for slave ACK\n                    if (clk_pulse && scl_clk) begin\n                        ack_received <= !I2C_SDA;\n                    end\n                end\n                \n                READ_DATA: begin\n                    sda_oe <= 1'b0;  // Release SDA for slave to drive\n                    if (clk_pulse && scl_clk) begin\n                        if (bit_cnt < 8) begin\n                            data_out[7 - bit_cnt] <= I2C_SDA;\n                            bit_cnt <= bit_cnt + 1'b1;\n                        end\n                    end else if (clk_pulse && !scl_clk && bit_cnt == 8) begin\n                        bit_cnt <= '0;\n                    end\n                end\n                \n                SEND_NACK: begin\n                    sda_oe <= 1'b1;\n                    sda_out <= 1'b1;  // NACK (high)\n                end\n                \n                STOP: begin\n                    sda_oe <= 1'b1;\n                    if (clk_pulse && !scl_clk) begin\n                        sda_out <= 1'b0;  // Prepare for stop condition\n                    end else if (clk_pulse && scl_clk) begin\n                        sda_out <= 1'b1;  // Stop condition: SDA rises while SCL is high\n                    end\n                end\n                \n                HOLD_STOP: begin\n                    sda_oe <= 1'b1;\n                    sda_out <= 1'b1;\n                    scl_enable <= 1'b0;\n                end\n            endcase\n        end\n    end\n\nendmodule\n```\n\nThis I2C master controller implementation includes:\n\n1. **Clock Divider**: Generates the I2C SCL clock from the system clock with configurable divider ratio.\n\n2. **State Machine**: Implements all required I2C operations including:\n   - Start condition generation\n   - 10-bit addressing support\n   - Write and read operations\n   - ACK/NACK handling\n   - Stop condition generation\n\n3. **Bidirectional SDA Handling**: Uses output enable (`sda_oe`) to control when the master drives SDA and when it releases the line for slave responses.\n\n4. **Protocol Compliance**: \n   - Start condition: SDA falls while SCL is high\n   - Stop condition: SDA rises while SCL is high\n   - Data changes only when SCL is low\n   - Data sampling when SCL is high\n\n5. **Control Signals**:\n   - `busy`: Active during transactions\n   - `I2C_En`: Active during I2C operations\n   - `data_out`: Captures read data from slave\n\nThe module can be customized by adjusting the `CLK_DIV` parameter to achieve the desired I2C clock frequency based on your system clock."
}
