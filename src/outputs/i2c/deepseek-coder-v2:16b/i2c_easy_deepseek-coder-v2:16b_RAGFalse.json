{
    "prompt_0": " Write a SystemVerilog module to implement an I2C master controller. The controller should generate proper start and stop conditions, handle data transfers with acknowledgments, and support both write and read operations. The design must include a clock divider to produce the appropriate I2C SCL frequency. The I2C module should have the following interface:\nmodule I2C_driver( input  logic       clk,         // System clock input  logic       rst,         // Asynchronous reset input  logic       I2C_Start,   // Initiate a transaction when high input  logic       RW,          // Read/Write control: 0 for write, 1 for read input  logic [6:0] slave_addr,  // 7-bit I2C slave address input  logic [7:0] data_in,     // Data to be written (for write transactions) inout  logic       I2C_SDA,     // I2C data line (bidirectional) output logic       I2C_SCL,     // I2C clock line output logic [7:0] data_out,    // Data received from slave (for read transactions) output logic       I2C_En,      // Module enable signal (active during transaction) output logic       busy         // Indicates the module is busy with a transaction ); The I2C master controller should operate as follows: Start Condition: When I2C_Start is asserted, generate a start condition on the I2C bus. Addressing: Transmit the 7-bit slave address along with a R/W bit. Data Transfer: For write transactions (RW = 0), send the provided data (data_in) and handle the ACK from the slave. For read transactions (RW = 1), read the data from the slave and output it on data_out while sending the necessary ACK/NACK. Stop Condition: After the data transfer, generate a stop condition on the bus. Clock Generation: Use a clock divider to derive the I2C SCL frequency from the system clock. Control Signals: The module should assert busy during active transactions and deassert it once the transaction is complete. Design your code with clear state machine implementation, proper handling of bidirectional signals (I2C_SDA), and ensure that all I2C protocol timing requirements are met.\n",
    "answer_0": "Below is a SystemVerilog module for an I2C master controller that meets the specified requirements. The module includes a clock divider to generate the I2C SCL signal, state machine for handling start, address transmission, data transfer with acknowledgment, and stop conditions. It also handles read and write operations as per the provided interface.\n\n```systemverilog\nmodule I2C_driver(\n    input  logic       clk,         // System clock input\n    input  logic       rst,         // Asynchronous reset input\n    input  logic       I2C_Start,   // Initiate a transaction when high\n    input  logic       RW,          // Read/Write control: 0 for write, 1 for read\n    input  logic [6:0] slave_addr,  // 7-bit I2C slave address input\n    input  logic [7:0] data_in,     // Data to be written (for write transactions)\n    inout  logic       I2C_SDA,     // I2C data line (bidirectional)\n    output logic       I2C_SCL,     // I2C clock line output\n    output logic [7:0] data_out,    // Data received from slave (for read transactions)\n    output logic       I2C_En,      // Module enable signal (active during transaction)\n    output logic       busy         // Indicates the module is busy with a transaction\n);\n\n    typedef enum {IDLE, START, ADDR, DATA, ACK, STOP} state_t;\n    state_t state, next_state;\n\n    logic [7:0] data_buffer;  // Buffer to hold data for transmission/reception\n    logic       sda_out;      // Output control signal for I2C SDA\n    logic       scl_clk;      // Generated clock signal for I2C SCL\n    logic [3:0] bit_cnt;      // Counter for the bits being transmitted/received\n    logic [2:0] clk_div;      // Clock divider counter\n\n    // Clock Divider to generate SCL from system clock\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            clk_div <= 3'b0;\n            scl_clk <= 1'b0;\n        end else begin\n            clk_div <= clk_div + 1;\n            scl_clk <= (clk_div == 3'd4); // Adjust this value based on the required SCL frequency\n        end\n    end\n\n    // I2C SDA handling (bidirectional)\n    always_comb begin\n        if (sda_out) begin\n            I2C_SDA = 1'bz;\n        end else begin\n            I2C_SDA = data_buffer[7-bit_cnt];\n        end\n    end\n\n    // State Machine for I2C transaction\n    always_ff @(posedge scl_clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            bit_cnt <= 4'b0;\n            data_buffer <= 8'b0;\n            busy <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    if (I2C_Start) begin\n                        state <= START;\n                        busy <= 1'b1;\n                    end\n                end\n                START: begin\n                    // Generate start condition on I2C bus\n                    sda_out = 1'b0;\n                    bit_cnt = 4'd7;\n                    state <= ADDR;\n                end\n                ADDR: begin\n                    if (bit_cnt == 0) begin\n                        state <= DATA;\n                    end else begin\n                        // Shift data to I2C slave\n                        sda_out = slave_addr[6-bit_cnt];\n                        bit_cnt = bit_cnt - 1;\n                    end\n                end\n                DATA: begin\n                    if (RW == 0) begin\n                        // Write operation\n                        sda_out = data_in[7-bit_cnt];\n                        if (bit_cnt == 0) state <= ACK;\n                    end else begin\n                        // Read operation\n                        sda_out = 1'b0; // Send NACK after last bit for read\n                        if (bit_cnt == 0) state <= STOP;\n                    end\n                end\n                ACK: begin\n                    if (RW == 0) begin\n                        // Write operation, wait for ACK/NACK from slave\n                        sda_out = 1'b0; // Send ACK\n                        bit_cnt = 4'd7;\n                        state <= DATA;\n                    end else begin\n                        // Read operation, get data and send ACK/NACK\n                        data_buffer[7-bit_cnt] = I2C_SDA;\n                        if (bit_cnt == 0) state <= STOP;\n                    end\n                end\n                STOP: begin\n                    // Generate stop condition on I2C bus\n                    sda_out = 1'b0;\n                    busy <= 1'b0;\n                    state <= IDLE;\n                end\n            endcase\n        end\n    end\nendmodule\n```\n\nThis module defines an I2C master controller with a SystemVerilog state machine. The SCL signal is generated by a clock divider from the system clock, and the bidirectional I2C data line (SDA) is controlled based on the current state of the state machine. Each state handles specific tasks such as generating start conditions, addressing the slave device, transmitting or receiving data, and creating stop conditions according to the I2C protocol.",
    "prompt_1": " Write a SystemVerilog module to implement an I2C master controller. The controller should generate proper start and stop conditions, handle data transfers with acknowledgments, and support both write and read operations. The design must include a clock divider to produce the appropriate I2C SCL frequency. The I2C module should have the following interface:\nmodule I2C_driver( input  logic       clk,         // System clock input  logic       rst,         // Asynchronous reset input  logic       I2C_Start,   // Initiate a transaction when high input  logic       RW,          // Read/Write control: 0 for write, 1 for read input  logic [9:0] slave_addr,  // 10-bit I2C slave address input  logic [7:0] data_in,     // Data to be written (for write transactions) inout  logic       I2C_SDA,     // I2C data line (bidirectional) output logic       I2C_SCL,     // I2C clock line output logic [7:0] data_out,    // Data received from slave (for read transactions) output logic       I2C_En,      // Module enable signal (active during transaction) output logic       busy         // Indicates the module is busy with a transaction ); The I2C master controller should operate as follows: Start Condition: When I2C_Start is asserted, generate a start condition on the I2C bus. Addressing: Transmit the 10-bit slave address along with a R/W bit. Data Transfer: For write transactions (RW = 0), send the provided data (data_in) and handle the ACK from the slave. For read transactions (RW = 1), read the data from the slave and output it on data_out while sending the necessary ACK/NACK. Stop Condition: After the data transfer, generate a stop condition on the bus. Clock Generation: Use a clock divider to derive the I2C SCL frequency from the system clock. Control Signals: The module should assert busy during active transactions and deassert it once the transaction is complete. Design your code with clear state machine implementation, proper handling of bidirectional signals (I2C_SDA), and ensure that all I2C protocol timing requirements are met.\n",
    "answer_1": "To implement an I2C master controller in SystemVerilog, we will create a finite state machine (FSM) that handles the start condition, address transmission, data transfer with acknowledgment (ACK), stop condition, and clock generation. Below is the detailed implementation of the `I2C_driver` module:\n\n```systemverilog\nmodule I2C_driver(\n    input  logic       clk,         // System clock input\n    input  logic       rst,         // Asynchronous reset input\n    input  logic       I2C_Start,   // Initiate a transaction when high\n    input  logic       RW,          // Read/Write control: 0 for write, 1 for read\n    input  logic [9:0] slave_addr,  // 10-bit I2C slave address input\n    input  logic [7:0] data_in,     // Data to be written (for write transactions)\n    inout  logic       I2C_SDA,     // I2C data line (bidirectional)\n    output logic       I2C_SCL,     // I2C clock line output\n    output logic [7:0] data_out,    // Data received from slave (for read transactions)\n    output logic       I2C_En,      // Module enable signal (active during transaction)\n    output logic       busy         // Indicates the module is busy with a transaction\n);\n\n    // Clock divider to generate SCL\n    logic [15:0] clk_div;\n    parameter integer CLK_DIV_MAX = 16'd24; // Example value, adjust for your specific frequency\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            clk_div <= 16'd0;\n        end else begin\n            clk_div <= clk_div + 1;\n        end\n    end\n    assign I2C_SCL = clk_div[CLK_DIV_MAX];\n\n    // Define states for the FSM\n    typedef enum logic [3:0] {IDLE, START, ADDR, ACK_WAIT, DATA, RESP, STOP} state_t;\n    state_t state, next_state;\n\n    // Internal signals\n    logic start_condition;\n    logic stop_condition;\n    logic shift_data;\n    logic send_ack;\n    logic receive_ack;\n    logic [7:0] shift_reg;\n    logic [2:0] bit_cnt;\n    logic ack_received;\n\n    // I2C signals handling\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always_comb begin\n        next_state = state;\n        case (state)\n            IDLE: if (I2C_Start) next_state = START;\n            START: next_state = ADDR;\n            ADDR: if (bit_cnt == 3'd7 && RW == 1'b0) next_state = ACK_WAIT; // Write address case\n                  else if (bit_cnt == 3'd6) next_state = ACK_WAIT; // Read address case\n            ACK_WAIT: if (receive_ack) next_state = DATA;\n            DATA: if (bit_cnt == 3'd7 && RW == 1'b0) next_state = STOP;\n                  else if (bit_cnt == 3'd7 && RW == 1'b1) next_state = RESP;\n            RESP: next_state = ACK_WAIT; // Wait for acknowledge after reading data\n            STOP: next_state = IDLE;\n        endcase\n    end\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            bit_cnt <= 3'd0;\n        end else begin\n            case (state)\n                ADDR: if (!I2C_SCL && bit_cnt < 3'd7) bit_cnt <= bit_cnt + 1;\n                      else if (!I2C_SCL && bit_cnt == 3'd7) bit_cnt <= 3'd0; // Reset for next transaction or read operation\n                DATA: if (!I2C_SCL && shift_data) bit_cnt <= bit_cnt + 1;\n            endcase\n        end\n    end\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            shift_reg <= 8'd0;\n        end else begin\n            case (state)\n                ADDR: if (!I2C_SCL && bit_cnt < 3'd7) shift_reg <= {shift_reg[6:0], I2C_SDA};\n                      else if (!I2C_SCL && bit_cnt == 3'd7) begin\n                          if (RW == 1'b0) shift_reg <= data_in; // Load input data for write\n                          else shift_reg <= {shift_reg[6:0], I2C_SDA}; // For read, keep shifting until last bit\n                      end\n                DATA: if (!I2C_SCL && shift_data) shift_reg <= {shift_reg[6:0], I2C_SDA};\n            endcase\n        end\n    end\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            data_out <= 8'd0;\n        end else begin\n            case (state)\n                RESP: if (!I2C_SCL && bit_cnt == 3'd7) data_out <= shift_reg; // Output read data at the end of the transaction\n            endcase\n        end\n    end\n\n    // Generate start and stop conditions\n    assign start_condition = (state == START && !I2C_SCL);\n    assign stop_condition  = (state == STOP && I2C_SCL);\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            busy <= 1'b0;\n        end else begin\n            case (state)\n                START: busy <= 1'b1;\n                STOP: busy <= 1'b0;\n                default: ;\n            endcase\n        end\n    end\n\nendmodule\n```\n\nThis module implements an I2C master controller with a state machine that handles the start, address transmission, data handling, and stop conditions. The clock divider generates the SCL signal at the appropriate frequency for I2C communication. This code needs to be further refined based on specific requirements such as timing constraints and error checking mechanisms."
}
