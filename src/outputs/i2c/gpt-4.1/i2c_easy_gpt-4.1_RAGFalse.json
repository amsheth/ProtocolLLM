{
    "prompt_0": " Write a SystemVerilog module to implement an I2C master controller. The controller should generate proper start and stop conditions, handle data transfers with acknowledgments, and support both write and read operations. The design must include a clock divider to produce the appropriate I2C SCL frequency. The I2C module should have the following interface:\nmodule I2C_driver( input  logic       clk,         // System clock input  logic       rst,         // Asynchronous reset input  logic       I2C_Start,   // Initiate a transaction when high input  logic       RW,          // Read/Write control: 0 for write, 1 for read input  logic [6:0] slave_addr,  // 7-bit I2C slave address input  logic [7:0] data_in,     // Data to be written (for write transactions) inout  logic       I2C_SDA,     // I2C data line (bidirectional) output logic       I2C_SCL,     // I2C clock line output logic [7:0] data_out,    // Data received from slave (for read transactions) output logic       I2C_En,      // Module enable signal (active during transaction) output logic       busy         // Indicates the module is busy with a transaction ); The I2C master controller should operate as follows: Start Condition: When I2C_Start is asserted, generate a start condition on the I2C bus. Addressing: Transmit the 7-bit slave address along with a R/W bit. Data Transfer: For write transactions (RW = 0), send the provided data (data_in) and handle the ACK from the slave. For read transactions (RW = 1), read the data from the slave and output it on data_out while sending the necessary ACK/NACK. Stop Condition: After the data transfer, generate a stop condition on the bus. Clock Generation: Use a clock divider to derive the I2C SCL frequency from the system clock. Control Signals: The module should assert busy during active transactions and deassert it once the transaction is complete. Design your code with clear state machine implementation, proper handling of bidirectional signals (I2C_SDA), and ensure that all I2C protocol timing requirements are met.\n",
    "answer_0": "```systemverilog\nmodule I2C_driver(\n    input  logic        clk,         // System clock\n    input  logic        rst,         // Asynchronous reset\n    input  logic        I2C_Start,   // Initiate a transaction when high\n    input  logic        RW,          // Read/Write control: 0 for write, 1 for read\n    input  logic [6:0]  slave_addr,  // 7-bit I2C slave address\n    input  logic [7:0]  data_in,     // Data to be written (for write transactions)\n    inout  logic        I2C_SDA,     // I2C data line (bidirectional)\n    output logic        I2C_SCL,     // I2C clock line\n    output logic [7:0]  data_out,    // Data received from slave (for read transactions)\n    output logic        I2C_En,      // Module enable signal (active during transaction)\n    output logic        busy         // Indicates the module is busy with a transaction\n);\n\n    // Parameters\n    parameter SYS_CLK_FREQ = 50_000_000; // System clock frequency in Hz\n    parameter I2C_FREQ     = 100_000;    // I2C SCL frequency in Hz\n\n    // Clock Divider\n    localparam integer DIVIDER = SYS_CLK_FREQ / (I2C_FREQ * 4); // 4 phases per SCL\n    logic [$clog2(DIVIDER)-1:0] clk_div_cnt;\n    logic scl_tick; // SCL phase tick\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            clk_div_cnt <= 0;\n            scl_tick    <= 0;\n        end else begin\n            if (clk_div_cnt == DIVIDER-1) begin\n                clk_div_cnt <= 0;\n                scl_tick    <= 1;\n            end else begin\n                clk_div_cnt <= clk_div_cnt + 1;\n                scl_tick    <= 0;\n            end\n        end\n    end\n\n    // SCL generation (4 phases: low, rising, high, falling)\n    typedef enum logic [1:0] {SCL_LOW, SCL_RISE, SCL_HIGH, SCL_FALL} scl_phase_t;\n    scl_phase_t scl_phase;\n    logic scl_int;\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            scl_phase <= SCL_HIGH;\n            scl_int   <= 1;\n        end else if (scl_tick) begin\n            case (scl_phase)\n                SCL_LOW:  begin scl_phase <= SCL_RISE;  scl_int <= 0; end\n                SCL_RISE: begin scl_phase <= SCL_HIGH;  scl_int <= 1; end\n                SCL_HIGH: begin scl_phase <= SCL_FALL;  scl_int <= 1; end\n                SCL_FALL: begin scl_phase <= SCL_LOW;   scl_int <= 0; end\n            endcase\n        end\n    end\n    assign I2C_SCL = scl_int;\n\n    // I2C FSM States\n    typedef enum logic [3:0] {\n        IDLE,\n        START,\n        ADDR,\n        ADDR_ACK,\n        WRITE,\n        WRITE_ACK,\n        READ,\n        READ_ACK,\n        STOP,\n        DONE\n    } state_t;\n\n    state_t state, next_state;\n\n    // Internal signals\n    logic [3:0] bit_cnt;\n    logic [7:0] shifter;\n    logic       sda_out_en; // 1: drive SDA, 0: release (input)\n    logic       sda_out;    // Value to drive on SDA\n    logic [7:0] rx_data;\n    logic       ack_bit;\n    logic       sda_in_sync;\n    logic       start_latch;\n    logic       busy_int;\n    logic       I2C_En_int;\n\n    // Synchronize SDA input\n    always_ff @(posedge clk) begin\n        sda_in_sync <= I2C_SDA;\n    end\n\n    // Bidirectional SDA control\n    assign I2C_SDA = sda_out_en ? sda_out : 1'bz;\n\n    // FSM\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state      <= IDLE;\n            bit_cnt    <= 0;\n            shifter    <= 0;\n            sda_out_en <= 1;\n            sda_out    <= 1;\n            rx_data    <= 0;\n            ack_bit    <= 0;\n            start_latch<= 0;\n            busy_int   <= 0;\n            I2C_En_int <= 0;\n        end else begin\n            if (I2C_Start && !busy_int)\n                start_latch <= 1;\n            else if (state == START)\n                start_latch <= 0;\n\n            if (scl_tick) begin\n                case (state)\n                    IDLE: begin\n                        sda_out_en <= 1;\n                        sda_out    <= 1;\n                        busy_int   <= 0;\n                        I2C_En_int <= 0;\n                        if (start_latch) begin\n                            state   <= START;\n                            busy_int<= 1;\n                            I2C_En_int <= 1;\n                        end\n                    end\n                    START: begin\n                        // Generate start: SDA goes low while SCL is high\n                        sda_out_en <= 1;\n                        sda_out    <= 0;\n                        state      <= ADDR;\n                        bit_cnt    <= 7;\n                        shifter    <= {slave_addr, RW};\n                    end\n                    ADDR: begin\n                        // Send address + RW bit, MSB first\n                        sda_out_en <= 1;\n                        sda_out    <= shifter[bit_cnt];\n                        if (scl_phase == SCL_FALL) begin\n                            if (bit_cnt == 0)\n                                state <= ADDR_ACK;\n                            else\n                                bit_cnt <= bit_cnt - 1;\n                        end\n                    end\n                    ADDR_ACK: begin\n                        // Release SDA, sample ACK from slave\n                        sda_out_en <= 0;\n                        if (scl_phase == SCL_HIGH) begin\n                            ack_bit <= sda_in_sync;\n                        end\n                        if (scl_phase == SCL_FALL) begin\n                            if (RW)\n                                state <= READ;\n                            else\n                                state <= WRITE;\n                            bit_cnt <= 7;\n                            shifter<= data_in;\n                        end\n                    end\n                    WRITE: begin\n                        // Send data byte, MSB first\n                        sda_out_en <= 1;\n                        sda_out    <= shifter[bit_cnt];\n                        if (scl_phase == SCL_FALL) begin\n                            if (bit_cnt == 0)\n                                state <= WRITE_ACK;\n                            else\n                                bit_cnt <= bit_cnt - 1;\n                        end\n                    end\n                    WRITE_ACK: begin\n                        // Release SDA, sample ACK from slave\n                        sda_out_en <= 0;\n                        if (scl_phase == SCL_HIGH) begin\n                            ack_bit <= sda_in_sync;\n                        end\n                        if (scl_phase == SCL_FALL) begin\n                            state <= STOP;\n                        end\n                    end\n                    READ: begin\n                        // Release SDA, sample data from slave\n                        sda_out_en <= 0;\n                        if (scl_phase == SCL_HIGH) begin\n                            rx_data[bit_cnt] <= sda_in_sync;\n                        end\n                        if (scl_phase == SCL_FALL) begin\n                            if (bit_cnt == 0)\n                                state <= READ_ACK;\n                            else\n                                bit_cnt <= bit_cnt - 1;\n                        end\n                    end\n                    READ_ACK: begin\n                        // Send NACK (1) after last byte\n                        sda_out_en <= 1;\n                        sda_out    <= 1; // NACK\n                        if (scl_phase == SCL_FALL) begin\n                            state <= STOP;\n                        end\n                    end\n                    STOP: begin\n                        // Generate stop: SDA goes high while SCL is high\n                        sda_out_en <= 1;\n                        sda_out    <= 0;\n                        if (scl_phase == SCL_HIGH) begin\n                            sda_out <= 1;\n                            state   <= DONE;\n                        end\n                    end\n                    DONE: begin\n                        sda_out_en <= 1;\n                        sda_out    <= 1;\n                        busy_int   <= 0;\n                        I2C_En_int <= 0;\n                        state      <= IDLE;\n                    end\n                    default: state <= IDLE;\n                endcase\n            end\n        end\n    end\n\n    // Output assignments\n    assign busy     = busy_int;\n    assign I2C_En   = I2C_En_int;\n    assign data_out = rx_data;\n\nendmodule\n```\n**Notes:**\n- The SCL clock is generated with 4 phases per period for proper I2C timing.\n- The FSM covers all protocol steps: start, address, data, ACK/NACK, and stop.\n- SDA is bidirectional, controlled by `sda_out_en`.\n- For simplicity, only single-byte read/write is implemented. For multi-byte, extend the FSM.\n- The module asserts `busy` and `I2C_En` during transactions.\n- Timing and clock divider parameters should be adjusted for your system clock and desired I2C speed.\n- Proper synchronization and timing are handled for SDA sampling and driving.\n",
    "prompt_1": " Write a SystemVerilog module to implement an I2C master controller. The controller should generate proper start and stop conditions, handle data transfers with acknowledgments, and support both write and read operations. The design must include a clock divider to produce the appropriate I2C SCL frequency. The I2C module should have the following interface:\nmodule I2C_driver( input  logic       clk,         // System clock input  logic       rst,         // Asynchronous reset input  logic       I2C_Start,   // Initiate a transaction when high input  logic       RW,          // Read/Write control: 0 for write, 1 for read input  logic [9:0] slave_addr,  // 10-bit I2C slave address input  logic [7:0] data_in,     // Data to be written (for write transactions) inout  logic       I2C_SDA,     // I2C data line (bidirectional) output logic       I2C_SCL,     // I2C clock line output logic [7:0] data_out,    // Data received from slave (for read transactions) output logic       I2C_En,      // Module enable signal (active during transaction) output logic       busy         // Indicates the module is busy with a transaction ); The I2C master controller should operate as follows: Start Condition: When I2C_Start is asserted, generate a start condition on the I2C bus. Addressing: Transmit the 10-bit slave address along with a R/W bit. Data Transfer: For write transactions (RW = 0), send the provided data (data_in) and handle the ACK from the slave. For read transactions (RW = 1), read the data from the slave and output it on data_out while sending the necessary ACK/NACK. Stop Condition: After the data transfer, generate a stop condition on the bus. Clock Generation: Use a clock divider to derive the I2C SCL frequency from the system clock. Control Signals: The module should assert busy during active transactions and deassert it once the transaction is complete. Design your code with clear state machine implementation, proper handling of bidirectional signals (I2C_SDA), and ensure that all I2C protocol timing requirements are met.\n",
    "answer_1": "```systemverilog\nmodule I2C_driver(\n    input  logic        clk,         // System clock\n    input  logic        rst,         // Asynchronous reset\n    input  logic        I2C_Start,   // Initiate a transaction when high\n    input  logic        RW,          // Read/Write control: 0 for write, 1 for read\n    input  logic [9:0]  slave_addr,  // 10-bit I2C slave address\n    input  logic [7:0]  data_in,     // Data to be written (for write transactions)\n    inout  logic        I2C_SDA,     // I2C data line (bidirectional)\n    output logic        I2C_SCL,     // I2C clock line\n    output logic [7:0]  data_out,    // Data received from slave (for read transactions)\n    output logic        I2C_En,      // Module enable signal (active during transaction)\n    output logic        busy         // Indicates the module is busy with a transaction\n);\n\n    // Parameters\n    parameter SYS_CLK_FREQ = 50_000_000; // System clock frequency in Hz\n    parameter I2C_FREQ     = 100_000;    // I2C SCL frequency in Hz\n\n    // Clock Divider\n    localparam integer DIVIDER = SYS_CLK_FREQ / (I2C_FREQ * 4); // 4 phases per SCL\n    logic [$clog2(DIVIDER)-1:0] clk_div_cnt;\n    logic scl_tick; // SCL phase tick\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            clk_div_cnt <= 0;\n            scl_tick    <= 0;\n        end else begin\n            if (clk_div_cnt == DIVIDER-1) begin\n                clk_div_cnt <= 0;\n                scl_tick    <= 1;\n            end else begin\n                clk_div_cnt <= clk_div_cnt + 1;\n                scl_tick    <= 0;\n            end\n        end\n    end\n\n    // I2C SCL generation (4 phases: low, rising, high, falling)\n    typedef enum logic [1:0] {SCL_LOW, SCL_RISE, SCL_HIGH, SCL_FALL} scl_phase_t;\n    scl_phase_t scl_phase;\n    logic scl_int; // Internal SCL\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            scl_phase <= SCL_HIGH;\n            scl_int   <= 1;\n        end else if (scl_tick) begin\n            case (scl_phase)\n                SCL_LOW:  begin scl_phase <= SCL_RISE;  scl_int <= 0; end\n                SCL_RISE: begin scl_phase <= SCL_HIGH;  scl_int <= 1; end\n                SCL_HIGH: begin scl_phase <= SCL_FALL;  scl_int <= 1; end\n                SCL_FALL: begin scl_phase <= SCL_LOW;   scl_int <= 0; end\n            endcase\n        end\n    end\n    assign I2C_SCL = scl_int;\n\n    // I2C FSM States\n    typedef enum logic [3:0] {\n        IDLE,\n        START,\n        ADDR10_H,   // Send 1st address byte (11110XX0)\n        ADDR10_L,   // Send 2nd address byte (8 LSBs)\n        ADDR_ACK1,\n        ADDR_ACK2,\n        DATA_WR,\n        DATA_WR_ACK,\n        DATA_RD,\n        DATA_RD_ACK,\n        STOP,\n        DONE\n    } state_t;\n\n    state_t state, next_state;\n\n    // Internal signals\n    logic [7:0] tx_byte;\n    logic [7:0] rx_byte;\n    logic [3:0] bit_cnt;\n    logic sda_out, sda_oe;\n    logic sda_in;\n    logic ack_bit;\n    logic start_latch;\n    logic [7:0] data_out_reg;\n\n    // Bidirectional SDA handling\n    assign I2C_SDA = sda_oe ? sda_out : 1'bz;\n    assign sda_in  = I2C_SDA;\n\n    // Output assignments\n    assign data_out = data_out_reg;\n    assign I2C_En   = (state != IDLE);\n    assign busy     = (state != IDLE);\n\n    // FSM Sequential\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state        <= IDLE;\n            bit_cnt      <= 0;\n            tx_byte      <= 0;\n            rx_byte      <= 0;\n            sda_out      <= 1;\n            sda_oe       <= 1;\n            ack_bit      <= 0;\n            start_latch  <= 0;\n            data_out_reg <= 0;\n        end else begin\n            if (scl_tick) begin\n                state <= next_state;\n            end\n        end\n    end\n\n    // FSM Combinational\n    always_comb begin\n        // Default values\n        next_state = state;\n        sda_oe     = 1;\n        sda_out    = 1;\n\n        case (state)\n            IDLE: begin\n                sda_out = 1;\n                sda_oe  = 1;\n                if (I2C_Start && !start_latch) begin\n                    next_state = START;\n                end\n            end\n\n            START: begin\n                // Generate start: SDA goes low while SCL is high\n                sda_out = 0;\n                sda_oe  = 1;\n                if (scl_phase == SCL_HIGH) begin\n                    next_state = ADDR10_H;\n                    bit_cnt    = 7;\n                    // 1st address byte: 11110XX0 (10-bit addressing, R/W=0)\n                    tx_byte = {5'b11110, slave_addr[9:8], 1'b0};\n                end\n            end\n\n            ADDR10_H: begin\n                // Send 1st address byte (MSB first)\n                sda_out = tx_byte[bit_cnt];\n                sda_oe  = 1;\n                if (scl_phase == SCL_LOW) begin\n                    if (bit_cnt == 0)\n                        next_state = ADDR_ACK1;\n                    else\n                        bit_cnt = bit_cnt - 1;\n                end\n            end\n\n            ADDR_ACK1: begin\n                // Release SDA for ACK\n                sda_oe = 0;\n                if (scl_phase == SCL_HIGH) begin\n                    ack_bit = sda_in;\n                    next_state = ADDR10_L;\n                    bit_cnt = 7;\n                    // 2nd address byte: 8 LSBs of address\n                    tx_byte = slave_addr[7:0];\n                end\n            end\n\n            ADDR10_L: begin\n                // Send 2nd address byte (MSB first)\n                sda_out = tx_byte[bit_cnt];\n                sda_oe  = 1;\n                if (scl_phase == SCL_LOW) begin\n                    if (bit_cnt == 0)\n                        next_state = ADDR_ACK2;\n                    else\n                        bit_cnt = bit_cnt - 1;\n                end\n            end\n\n            ADDR_ACK2: begin\n                // Release SDA for ACK\n                sda_oe = 0;\n                if (scl_phase == SCL_HIGH) begin\n                    ack_bit = sda_in;\n                    if (RW == 0) begin\n                        // Write operation\n                        next_state = DATA_WR;\n                        bit_cnt = 7;\n                        tx_byte = data_in;\n                    end else begin\n                        // Read operation: repeated start\n                        next_state = START;\n                        // For repeated start, set up 1st address byte with R/W=1\n                        tx_byte = {5'b11110, slave_addr[9:8], 1'b1};\n                        bit_cnt = 7;\n                    end\n                end\n            end\n\n            DATA_WR: begin\n                // Send data byte (MSB first)\n                sda_out = tx_byte[bit_cnt];\n                sda_oe  = 1;\n                if (scl_phase == SCL_LOW) begin\n                    if (bit_cnt == 0)\n                        next_state = DATA_WR_ACK;\n                    else\n                        bit_cnt = bit_cnt - 1;\n                end\n            end\n\n            DATA_WR_ACK: begin\n                // Release SDA for ACK\n                sda_oe = 0;\n                if (scl_phase == SCL_HIGH) begin\n                    ack_bit = sda_in;\n                    next_state = STOP;\n                end\n            end\n\n            DATA_RD: begin\n                // Receive data byte (MSB first)\n                sda_oe = 0;\n                if (scl_phase == SCL_HIGH) begin\n                    rx_byte[bit_cnt] = sda_in;\n                    if (bit_cnt == 0)\n                        next_state = DATA_RD_ACK;\n                    else\n                        bit_cnt = bit_cnt - 1;\n                end\n            end\n\n            DATA_RD_ACK: begin\n                // Send NACK after last byte\n                sda_out = 1; // NACK\n                sda_oe  = 1;\n                if (scl_phase == SCL_LOW) begin\n                    data_out_reg = rx_byte;\n                    next_state = STOP;\n                end\n            end\n\n            STOP: begin\n                // Generate stop: SDA goes high while SCL is high\n                sda_out = 0;\n                sda_oe  = 1;\n                if (scl_phase == SCL_HIGH) begin\n                    sda_out = 1;\n                    sda_oe  = 1;\n                    next_state = DONE;\n                end\n            end\n\n            DONE: begin\n                sda_out = 1;\n                sda_oe  = 1;\n                next_state = IDLE;\n            end\n\n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n\n        // For read operation, after repeated start and address, go to DATA_RD\n        if (state == ADDR_ACK1 && RW == 1 && scl_phase == SCL_HIGH) begin\n            next_state = DATA_RD;\n            bit_cnt = 7;\n        end\n    end\n\n    // Latch start signal\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            start_latch <= 0;\n        else if (I2C_Start)\n            start_latch <= 1;\n        else if (state == IDLE)\n            start_latch <= 0;\n    end\n\nendmodule\n```\n**Notes:**\n- This module supports 10-bit addressing, both read and write, and proper I2C start/stop/acknowledge handling.\n- The SCL clock is generated with a 4-phase divider for correct timing.\n- The bidirectional SDA line is handled with a tri-state buffer (`sda_oe`).\n- The FSM covers all protocol steps, including repeated start for reads.\n- Only a single data byte is transferred per transaction (can be extended for multi-byte).\n- Timing and edge alignment are simplified for clarity; for silicon, further timing checks and clock domain crossing may be needed."
}
