{
    "prompt_0": "a STOP or Repeated START signal. To write data to a slave, store the data to be transmitted in the Transmit Register and set the WR bit. To read data from a slave, set the RD bit. During a transfer the core set the TIP flag, indicating that a Transfer is In Progress. When the transfer is done the TIP flag is reset, the IF flag set and, when enabled, an interrupt generated. The Receive Register contains valid data after the IF flag has been set. The user may issue a new write or read command when the TIP flag is reset. 4.2.4 STOP signal The master can terminate the communication by generating a STOP signal. A STOP signal, usually referred to as the P-bit, is defined as a low-to-high transition of SDA while SCL is at logical \u20181\u2019. OpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 9 of 15 4.3 Arbitration Procedure 4.3.1 Clock Synchronization The I2C bus is a true multimaster bus that allows more than one master to be connected on it. If two or more masters simultaneously try to control the bus, a clock synchronization procedure determines the bus clock. Because of the wired-AND connection of the I 2C signals a high to low transition affects all devices connected to the bus. Therefore a high to low transition on the SCL line causes all concerned devices to count off their low period. Once a device clock has gone low it will hold the SCL line in that state until the clock high state is reached. Due to the wired-AND connection the SCL line will therefore be held low by the device with the longest low period, and held high by the device with the shortest high period. Start counting low period wait stateStart counting high period SCL1 SCL2 SCLMaster1 SCL Master2 SCL wired-AND SCL 4.3.2 Clock Stretching Slave devices can use the clock synchronization mechanism to slow down the transfer bit rate. After the master has driven SCL low, the slave can drive SCL low for the required period and then release it. If the slave\u2019s SCL low period is greater than the master\u2019s SCL low period, the resulting SCL bus signal low period is stretched, thus inserting wait-states. OpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 10 of 15 5 Architecture The I2C core is built around four primary blocks; the Clock Generator, the Byte Command Controller, the Bit Command Controller and the DataIO Shift Register. All other blocks are used for interfacing or for storing temporary values. 5.1 Clock Generator The Clock Generator generates an internal 4*Fscl clock enable signal that triggers all synchronous elements in the Bit Command Controller. It also handles clock stretching needed by some slaves. 5.2 Byte Command Controller The Byte Command Controller handles I2C traffic at the byte level. It takes data from the Command Register and translates it into sequences based on the transmission of a single byte. By setting the START, STOP, and READ bit in the\nbyte has been read the contents are copied into the Receive Register. During a write action, the Transmit Register\u2019s contents are copied into the DataIO Shift Register and are then transmitted onto the SDA line. A B C DOpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 13 of 15 6 Programming examples Example 1 Write 1 byte of data to a slave. Slave address = 0x51 (b\u201d1010001\u201d) Data to write = 0xAC I2C Sequence: 1) generate start command 2) write slave address + write bit 3) receive acknowledge from slave 4) write data 5) receive acknowledge from slave 6) generate stop command Commands: 1) write 0xA2 (address + write bit) to Transmit Register, set STA bit, set WR bit. -- wait for interrupt or TIP flag to negate -- 2) read RxACK bit from Status Register, should be \u20180\u2019. write 0xAC to Transmit register, set STO bit, set WR bit. -- wait for interrupt or TIP flag to negate -- 3) read RxACK bit from Status Register, should be \u20180\u2019. Please note that the time for the Interrupt Service Routine is not shown here. It is assumed that the ISR is much faster then the I2C cycle time, and therefore not visible. Second command sequence First command sequence SDA S Wr ack ack P SCL OpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 14 of 15 Example 2 Read a byte of data from an I2C memory device. Slave address = 0x4E Memory location to read from = 0x20 I2C sequence: 1) generate start signal 2) write slave address + write bit 3) receive acknowledge from slave 4) write memory location 5) receive acknowledge from slave 6) generate repeated start signal 7) write slave address + read bit 8) receive acknowledge from slave 9) read byte from slave 10) write no acknowledge (NACK) to slave, indicating end of transfer 11) generate stop signal Commands: 1) write 0x9C (address + write bit) to Transmit Register, set STA bit, set WR bit. -- wait for interrupt or TIP flag to negate -- 2) read RxACK bit from Status Register, should be \u20180\u2019. write 0x20 to Transmit register, set WR bit. -- wait for interrupt or TIP flag to negate -- 3) read RxACK bit from Status Register, should be \u20180\u2019. write 0x9D (address + read bit) to Transmit Register, set STA bit, set WR bit. -- wait for interrupt or TIP flag to negate -- 4) set RD bit, set ACK to \u20181\u2019 (NACK), set STO bit Please note that the time for the Interrupt Service Routine is not shown here. It is assumed that the ISR is much faster then the I2C cycle time, and therefore not visible. Second command sequence First command sequence SDA S Wr ack ack SCL Fourth command sequence Third command sequence SDA R Rd ack D7 D6 D5 D4 D3 D2 D1 D0 nack P SCL OpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 15 of 15 Appendix A Synthesis results Synthesis tool: Synplify Pro Technology\nCommand Controller, the Bit Command Controller and the DataIO Shift Register. All other blocks are used for interfacing or for storing temporary values. 5.1 Clock Generator The Clock Generator generates an internal 4*Fscl clock enable signal that triggers all synchronous elements in the Bit Command Controller. It also handles clock stretching needed by some slaves. 5.2 Byte Command Controller The Byte Command Controller handles I2C traffic at the byte level. It takes data from the Command Register and translates it into sequences based on the transmission of a single byte. By setting the START, STOP, and READ bit in the Command Register, for example, the Byte Command Controller generates a sequence that results in the SCL SDA Prescale Register clock generator Command Register Status Register Byte Command Controller Bit Command Controller WISHBONE Interface Transmit Register Receive Register DataIO Shift Register Fig. 5.1 Internal structure I2C Master Core OpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 11 of 15 generation of a START signal, the reading of a byte from the slave device, and the generation of a STOP signal. It does this by dividing each byte operation into separate bit-operations, which are then sent to the Bit Command Controller. NoIdle state Read / Write bit set ? Yes START bit set ? Yes START signal state No START generated ? No Yes Read bit set ? Yes READ state Byte Read ? No Yes ACK state WRITE state Byte Written ? No YesNo ACK bit Read Written No YesOpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 12 of 15 5.3 Bit Command Controller The Bit Command Controller handles the actual transmission of data and the generation of the specific levels for START, Repeated START, and STOP signals by controlling the SCL and SDA lines. The Byte Command Controller tells the Bit Command Controller which operation has to be performed. For a single byte read, the Bit Command Controller receives 8 separate read commands. Each bit-operation is divided into 5 pieces (idle and A, B, C, and D), except for a STOP operation which is divided into 4 pieces (idle and A, B, and C). Start SCL SDA Rep Start SCL SDA Stop SCL SDA Write SCL SDA Read SCL SDA 5.4 DataIO Shift Register The DataIO Shift Register contains the data associated with the current transfer. During a read action, data is shifted in from the SDA line. After a byte has been read the contents are copied into the Receive Register. During a write action, the Transmit Register\u2019s contents are copied into the DataIO Shift Register and are then transmitted onto the SDA line. A B C DOpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 13 of 15 6 Programming examples Example 1 Write 1 byte of data to a slave. Slave address = 0x51 (b\u201d1010001\u201d) Data to write = 0xAC I2C Sequence: 1) generate start command 2) write slave address + write bit 3) receive acknowledge from slave 4) write data 5) receive acknowledge from slave 6) generate\n Write a SystemVerilog module to implement an I2C master controller. The controller should generate proper start and stop conditions, handle data transfers with acknowledgments, and support both write and read operations. The design must include a clock divider to produce the appropriate I2C SCL frequency. The I2C module should have the following interface:\nmodule I2C_driver( input  logic       clk,         // System clock input  logic       rst,         // Asynchronous reset input  logic       I2C_Start,   // Initiate a transaction when high input  logic       RW,          // Read/Write control: 0 for write, 1 for read input  logic [6:0] slave_addr,  // 7-bit I2C slave address input  logic [7:0] data_in,     // Data to be written (for write transactions) inout  logic       I2C_SDA,     // I2C data line (bidirectional) output logic       I2C_SCL,     // I2C clock line output logic [7:0] data_out,    // Data received from slave (for read transactions) output logic       I2C_En,      // Module enable signal (active during transaction) output logic       busy         // Indicates the module is busy with a transaction ); The I2C master controller should operate as follows: Start Condition: When I2C_Start is asserted, generate a start condition on the I2C bus. Addressing: Transmit the 7-bit slave address along with a R/W bit. Data Transfer: For write transactions (RW = 0), send the provided data (data_in) and handle the ACK from the slave. For read transactions (RW = 1), read the data from the slave and output it on data_out while sending the necessary ACK/NACK. Stop Condition: After the data transfer, generate a stop condition on the bus. Clock Generation: Use a clock divider to derive the I2C SCL frequency from the system clock. Control Signals: The module should assert busy during active transactions and deassert it once the transaction is complete. Design your code with clear state machine implementation, proper handling of bidirectional signals (I2C_SDA), and ensure that all I2C protocol timing requirements are met.\n",
    "answer_0": "Below is a compact, fully-synthesizable SystemVerilog implementation of the requested single-byte I\u00b2C master.  \nThe design contains  \n\n\u2022 A parameterised clock divider that derives the SCL frequency from the system clock  \n\u2022 A finite-state-machine that generates START/STOP, moves the address & data, and handles ACK/NACK  \n\u2022 Correct open-drain handling of SDA (drive only \u20180\u2019, otherwise release \u2011> pull-up supplies the \u20181\u2019)  \n\u2022 Busy/enable flags that stay asserted for the whole transaction  \n  \nThe module is written for clarity rather than ultimate performance; it can be extended to multi-byte transfers by adding a byte-counter around the \u201cSEND_BYTE / READ_BYTE\u201d states.\n\n```systemverilog\n// ==========================================================\n// Simple single-byte I\u00b2C master (7-bit addressing)\n// ==========================================================\nmodule I2C_driver\n#(\n    // -----------------------------------------------------------------\n    // Change these two parameters to meet any clock / I\u00b2C-speed target\n    // -----------------------------------------------------------------\n    parameter int SYS_CLK_FREQ = 50_000_000,   // Hz \u2013 system clock\n    parameter int I2C_CLK_FREQ = 100_000       // Hz \u2013 SCL frequency\n)\n(\n    input  logic       clk,          // system clock\n    input  logic       rst,          // asynchronous reset (active high)\n\n    // user interface ---------------------------------------------------\n    input  logic       I2C_Start,    // assert for one cycle to launch a Tx\n    input  logic       RW,           // 0 = write, 1 = read\n    input  logic [6:0] slave_addr,   // 7-bit address\n    input  logic [7:0] data_in,      // byte to write\n    inout  tri1        I2C_SDA,      // bidirectional SDA   (tri1 -> pull-up)\n    output logic       I2C_SCL,      // SCL generated here\n    output logic [7:0] data_out,     // byte received (read transactions)\n    output logic       I2C_En,       // \u20181\u2019 while transaction in progress\n    output logic       busy          // same as I2C_En\n);\n\n    // ===============================================================\n    // 1. SCL generator \u2013 square wave, high in the IDLE state\n    // ===============================================================\n    localparam int DIVIDER = SYS_CLK_FREQ / (I2C_CLK_FREQ * 2); // half period\n    logic [$clog2(DIVIDER)-1:0] div_cnt;\n    logic                        scl_int;\n    logic                        scl_half_pulse;\n\n    // divider\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            div_cnt        <= '0;\n            scl_half_pulse <= 1'b0;\n        end else begin\n            if (div_cnt == DIVIDER-1) begin\n                div_cnt        <= '0;\n                scl_half_pulse <= 1'b1;             // one-cycle strobe each half period\n            end else begin\n                div_cnt        <= div_cnt + 1'b1;\n                scl_half_pulse <= 1'b0;\n            end\n        end\n    end\n\n    // toggle SCL only when a transfer is active\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)                scl_int <= 1'b1;           // idle bus = high\n        else if (I2C_En) begin\n            if (scl_half_pulse) scl_int <= ~scl_int;\n        end else                scl_int <= 1'b1;\n    end\n    assign I2C_SCL = scl_int;\n\n    // edge detectors for the FSM\n    logic scl_prev;\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) scl_prev <= 1'b1;\n        else     scl_prev <= scl_int;\n    end\n    wire scl_rise =  scl_int & ~scl_prev;\n    wire scl_fall = ~scl_int &  scl_prev;\n\n    // ===============================================================\n    // 2. Main FSM\n    // ===============================================================\n    typedef enum logic [3:0] {\n        IDLE,          // wait for I2C_Start\n        START_A,       // SDA:1->0 while SCL high\n        START_B,       // first SCL low half-cycle\n        SEND_BYTE,     // shift out 8 bits (addr or data)\n        WAIT_ACK,      // release SDA, sample ACK\n        READ_BYTE,     // shift in 8 bits from slave\n        SEND_NACK,     // drive NACK (=\u20181\u2019) after last read\n        STOP_A,        // SDA low while SCL low\n        STOP_B,        // SDA 0->1 while SCL high\n        DONE           // clean-up, return to IDLE\n    } state_t;\n\n    state_t state, next_state;\n\n    // shift register / counters / flags\n    logic [7:0] shift;\n    logic [2:0] bit_cnt;\n    logic       sending_addr;        // \u20181\u2019 while address byte is being sent\n    logic       sda_drive_low;       // combinational \u2013 drive SDA low?\n\n    // ----------------------------------------------------------------\n    // next-state & output combinational logic\n    // ----------------------------------------------------------------\n    always_comb begin\n        next_state    = state;\n        sda_drive_low = 1'b0;        // default: release SDA\n\n        unique case (state)\n        //------------------------------------------------------------------\n        IDLE : begin\n            if (I2C_Start) next_state = START_A;\n        end\n        //------------------------------------------------------------------\n        START_A : begin\n            sda_drive_low = 1'b1;                 // pull SDA low (START)\n            if (scl_fall) next_state = START_B;\n        end\n        START_B : begin\n            sda_drive_low = 1'b1;                 // keep SDA low\n            if (scl_fall) next_state = SEND_BYTE;\n        end\n        //------------------------------------------------------------------\n        SEND_BYTE : begin                         // drive MSB first\n            sda_drive_low = ~shift[7];            // only 0's are driven\n            if (scl_fall) begin\n                if (bit_cnt == 3'd0) next_state = WAIT_ACK;\n            end\n        end\n        WAIT_ACK : begin                          // sample on SCL rising edge\n            if (scl_rise) begin\n                if (sending_addr & RW)          next_state = READ_BYTE; // start reading\n                else if (sending_addr & ~RW)    next_state = SEND_BYTE; // send data byte\n                else if (~sending_addr & ~RW)   next_state = STOP_A;    // write finished\n                else                            next_state = SEND_NACK; // read finished\n            end\n        end\n        //------------------------------------------------------------------\n        READ_BYTE : begin                         // SDA released, slave drives\n            if (scl_rise) begin\n                if (bit_cnt == 3'd0) next_state = SEND_NACK;\n            end\n        end\n        SEND_NACK : begin                         // master sends NACK (=\u20181\u2019 -> release)\n            // nothing driven \u2192 sda_drive_low stays 0\n            if (scl_fall) next_state = STOP_A;\n        end\n        //------------------------------------------------------------------\n        STOP_A : begin\n            sda_drive_low = 1'b1;                 // SDA low, SCL low\n            if (scl_rise) next_state = STOP_B;\n        end\n        STOP_B : begin\n            // on SCL high drive SDA low \u2192 then release \u2192 STOP\n            if (scl_rise) sda_drive_low = 1'b0;   // release for STOP\n            if (scl_half_pulse) next_state = DONE;\n        end\n        //------------------------------------------------------------------\n        DONE : begin\n            if (!I2C_Start) next_state = IDLE;    // wait until start de-asserted\n        end\n        //------------------------------------------------------------------\n        default : next_state = IDLE;\n        endcase\n    end\n\n    // ----------------------------------------------------------------\n    // sequential part\n    // ----------------------------------------------------------------\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state        <= IDLE;\n            bit_cnt      <= 3'd7;\n            shift        <= '0;\n            sending_addr <= 1'b0;\n        end else begin\n            state <= next_state;\n\n            // ---------- load / shift bookkeeping -------------------\n            // LOAD address right after START_B\n            if (state == START_B && scl_fall) begin\n                shift        <= {slave_addr, RW};\n                bit_cnt      <= 3'd7;\n                sending_addr <= 1'b1;\n            end\n            // SHIFT on every falling edge while sending bits\n            else if (state == SEND_BYTE && scl_fall) begin\n                shift   <= {shift[6:0], 1'b0};\n                bit_cnt <= bit_cnt - 3'd1;\n            end\n            // after ACK of address byte\n            else if (state == WAIT_ACK && sending_addr && scl_rise) begin\n                sending_addr <= 1'b0;\n                if (!RW) begin                       // prepare data byte for write\n                    shift   <= data_in;\n                    bit_cnt <= 3'd7;\n                end\n            end\n            // shift IN while reading\n            else if (state == READ_BYTE && scl_rise) begin\n                shift   <= {shift[6:0], I2C_SDA};\n                bit_cnt <= bit_cnt - 3'd1;\n            end\n        end\n    end\n\n    // ===============================================================\n    // 3. Tri-state drive for SDA\n    // ===============================================================\n    assign I2C_SDA = sda_drive_low ? 1'b0 : 1'bz;  // open-drain behaviour\n\n    // ===============================================================\n    // 4. Outputs\n    // ===============================================================\n    assign data_out = shift;              // valid after DONE (for reads)\n    assign busy     = (state != IDLE) && (state != DONE);\n    assign I2C_En   = busy;               // identical meaning\n\nendmodule\n```\n\nHow it works (quick recap)  \n1. As soon as `I2C_Start` is asserted the FSM pulls SDA low while SCL is still high \u2192 START.  \n2. The address byte (`slave_addr` + `RW`) is shifted MSB-first while the FSM drives only \u20180\u2019s (open-drain). After the 8th bit SDA is released so the slave can ACK.  \n3. \u2022 Write: the data byte is sent, ACK is sampled, then STOP is generated.  \n   \u2022 Read : SDA is released for 8 clock pulses; the slave sends the byte which is captured into `data_out`. The master subsequently generates a NACK (\u20181\u2019), then STOP.  \n4. Lines return high, `busy/I2C_En` de-assert, and the module waits for the next `I2C_Start`.  \n\nThe module respects all basic I\u00b2C timing rules (setup/hold via SCL low/high half-periods) and uses only simple synchronous logic, making it suitable for FPGA or ASIC synthesis.",
    "prompt_1": "a STOP or Repeated START signal. To write data to a slave, store the data to be transmitted in the Transmit Register and set the WR bit. To read data from a slave, set the RD bit. During a transfer the core set the TIP flag, indicating that a Transfer is In Progress. When the transfer is done the TIP flag is reset, the IF flag set and, when enabled, an interrupt generated. The Receive Register contains valid data after the IF flag has been set. The user may issue a new write or read command when the TIP flag is reset. 4.2.4 STOP signal The master can terminate the communication by generating a STOP signal. A STOP signal, usually referred to as the P-bit, is defined as a low-to-high transition of SDA while SCL is at logical \u20181\u2019. OpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 9 of 15 4.3 Arbitration Procedure 4.3.1 Clock Synchronization The I2C bus is a true multimaster bus that allows more than one master to be connected on it. If two or more masters simultaneously try to control the bus, a clock synchronization procedure determines the bus clock. Because of the wired-AND connection of the I 2C signals a high to low transition affects all devices connected to the bus. Therefore a high to low transition on the SCL line causes all concerned devices to count off their low period. Once a device clock has gone low it will hold the SCL line in that state until the clock high state is reached. Due to the wired-AND connection the SCL line will therefore be held low by the device with the longest low period, and held high by the device with the shortest high period. Start counting low period wait stateStart counting high period SCL1 SCL2 SCLMaster1 SCL Master2 SCL wired-AND SCL 4.3.2 Clock Stretching Slave devices can use the clock synchronization mechanism to slow down the transfer bit rate. After the master has driven SCL low, the slave can drive SCL low for the required period and then release it. If the slave\u2019s SCL low period is greater than the master\u2019s SCL low period, the resulting SCL bus signal low period is stretched, thus inserting wait-states. OpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 10 of 15 5 Architecture The I2C core is built around four primary blocks; the Clock Generator, the Byte Command Controller, the Bit Command Controller and the DataIO Shift Register. All other blocks are used for interfacing or for storing temporary values. 5.1 Clock Generator The Clock Generator generates an internal 4*Fscl clock enable signal that triggers all synchronous elements in the Bit Command Controller. It also handles clock stretching needed by some slaves. 5.2 Byte Command Controller The Byte Command Controller handles I2C traffic at the byte level. It takes data from the Command Register and translates it into sequences based on the transmission of a single byte. By setting the START, STOP, and READ bit in the\nbyte has been read the contents are copied into the Receive Register. During a write action, the Transmit Register\u2019s contents are copied into the DataIO Shift Register and are then transmitted onto the SDA line. A B C DOpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 13 of 15 6 Programming examples Example 1 Write 1 byte of data to a slave. Slave address = 0x51 (b\u201d1010001\u201d) Data to write = 0xAC I2C Sequence: 1) generate start command 2) write slave address + write bit 3) receive acknowledge from slave 4) write data 5) receive acknowledge from slave 6) generate stop command Commands: 1) write 0xA2 (address + write bit) to Transmit Register, set STA bit, set WR bit. -- wait for interrupt or TIP flag to negate -- 2) read RxACK bit from Status Register, should be \u20180\u2019. write 0xAC to Transmit register, set STO bit, set WR bit. -- wait for interrupt or TIP flag to negate -- 3) read RxACK bit from Status Register, should be \u20180\u2019. Please note that the time for the Interrupt Service Routine is not shown here. It is assumed that the ISR is much faster then the I2C cycle time, and therefore not visible. Second command sequence First command sequence SDA S Wr ack ack P SCL OpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 14 of 15 Example 2 Read a byte of data from an I2C memory device. Slave address = 0x4E Memory location to read from = 0x20 I2C sequence: 1) generate start signal 2) write slave address + write bit 3) receive acknowledge from slave 4) write memory location 5) receive acknowledge from slave 6) generate repeated start signal 7) write slave address + read bit 8) receive acknowledge from slave 9) read byte from slave 10) write no acknowledge (NACK) to slave, indicating end of transfer 11) generate stop signal Commands: 1) write 0x9C (address + write bit) to Transmit Register, set STA bit, set WR bit. -- wait for interrupt or TIP flag to negate -- 2) read RxACK bit from Status Register, should be \u20180\u2019. write 0x20 to Transmit register, set WR bit. -- wait for interrupt or TIP flag to negate -- 3) read RxACK bit from Status Register, should be \u20180\u2019. write 0x9D (address + read bit) to Transmit Register, set STA bit, set WR bit. -- wait for interrupt or TIP flag to negate -- 4) set RD bit, set ACK to \u20181\u2019 (NACK), set STO bit Please note that the time for the Interrupt Service Routine is not shown here. It is assumed that the ISR is much faster then the I2C cycle time, and therefore not visible. Second command sequence First command sequence SDA S Wr ack ack SCL Fourth command sequence Third command sequence SDA R Rd ack D7 D6 D5 D4 D3 D2 D1 D0 nack P SCL OpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 15 of 15 Appendix A Synthesis results Synthesis tool: Synplify Pro Technology\nCommand Controller, the Bit Command Controller and the DataIO Shift Register. All other blocks are used for interfacing or for storing temporary values. 5.1 Clock Generator The Clock Generator generates an internal 4*Fscl clock enable signal that triggers all synchronous elements in the Bit Command Controller. It also handles clock stretching needed by some slaves. 5.2 Byte Command Controller The Byte Command Controller handles I2C traffic at the byte level. It takes data from the Command Register and translates it into sequences based on the transmission of a single byte. By setting the START, STOP, and READ bit in the Command Register, for example, the Byte Command Controller generates a sequence that results in the SCL SDA Prescale Register clock generator Command Register Status Register Byte Command Controller Bit Command Controller WISHBONE Interface Transmit Register Receive Register DataIO Shift Register Fig. 5.1 Internal structure I2C Master Core OpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 11 of 15 generation of a START signal, the reading of a byte from the slave device, and the generation of a STOP signal. It does this by dividing each byte operation into separate bit-operations, which are then sent to the Bit Command Controller. NoIdle state Read / Write bit set ? Yes START bit set ? Yes START signal state No START generated ? No Yes Read bit set ? Yes READ state Byte Read ? No Yes ACK state WRITE state Byte Written ? No YesNo ACK bit Read Written No YesOpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 12 of 15 5.3 Bit Command Controller The Bit Command Controller handles the actual transmission of data and the generation of the specific levels for START, Repeated START, and STOP signals by controlling the SCL and SDA lines. The Byte Command Controller tells the Bit Command Controller which operation has to be performed. For a single byte read, the Bit Command Controller receives 8 separate read commands. Each bit-operation is divided into 5 pieces (idle and A, B, C, and D), except for a STOP operation which is divided into 4 pieces (idle and A, B, and C). Start SCL SDA Rep Start SCL SDA Stop SCL SDA Write SCL SDA Read SCL SDA 5.4 DataIO Shift Register The DataIO Shift Register contains the data associated with the current transfer. During a read action, data is shifted in from the SDA line. After a byte has been read the contents are copied into the Receive Register. During a write action, the Transmit Register\u2019s contents are copied into the DataIO Shift Register and are then transmitted onto the SDA line. A B C DOpenCores I2C-Master core 7/3/2003 www.opencores.org Rev 0.8 Preliminary 13 of 15 6 Programming examples Example 1 Write 1 byte of data to a slave. Slave address = 0x51 (b\u201d1010001\u201d) Data to write = 0xAC I2C Sequence: 1) generate start command 2) write slave address + write bit 3) receive acknowledge from slave 4) write data 5) receive acknowledge from slave 6) generate\n Write a SystemVerilog module to implement an I2C master controller. The controller should generate proper start and stop conditions, handle data transfers with acknowledgments, and support both write and read operations. The design must include a clock divider to produce the appropriate I2C SCL frequency. The I2C module should have the following interface:\nmodule I2C_driver( input  logic       clk,         // System clock input  logic       rst,         // Asynchronous reset input  logic       I2C_Start,   // Initiate a transaction when high input  logic       RW,          // Read/Write control: 0 for write, 1 for read input  logic [9:0] slave_addr,  // 10-bit I2C slave address input  logic [7:0] data_in,     // Data to be written (for write transactions) inout  logic       I2C_SDA,     // I2C data line (bidirectional) output logic       I2C_SCL,     // I2C clock line output logic [7:0] data_out,    // Data received from slave (for read transactions) output logic       I2C_En,      // Module enable signal (active during transaction) output logic       busy         // Indicates the module is busy with a transaction ); The I2C master controller should operate as follows: Start Condition: When I2C_Start is asserted, generate a start condition on the I2C bus. Addressing: Transmit the 10-bit slave address along with a R/W bit. Data Transfer: For write transactions (RW = 0), send the provided data (data_in) and handle the ACK from the slave. For read transactions (RW = 1), read the data from the slave and output it on data_out while sending the necessary ACK/NACK. Stop Condition: After the data transfer, generate a stop condition on the bus. Clock Generation: Use a clock divider to derive the I2C SCL frequency from the system clock. Control Signals: The module should assert busy during active transactions and deassert it once the transaction is complete. Design your code with clear state machine implementation, proper handling of bidirectional signals (I2C_SDA), and ensure that all I2C protocol timing requirements are met.\n",
    "answer_1": "Below is a compact, self-contained SystemVerilog implementation of the requested single-byte I\u00b2C master.  \n(The code includes extensive comments, permitting quick adaptation or extension \u2013 e.g. to full 10-bit addressing, multibyte transfers, bursts, etc.)\n\n```systemverilog\n// =============================================================================\n// Simple single\u2013byte I\u00b2C-MASTER,   7- or 10-bit addressing, R/W capable.\n// \u2013 Generates START / Re-START / STOP\n// \u2013 One data byte + ACK/NACK\n// \u2013 Open-drain SCL & SDA\n// \u2013 Busy flag and \u201ctransaction enable\u201d flag\n// =============================================================================\nmodule I2C_driver #(\n    // ------------------------------------------------------------\n    // USER-MODIFIABLE PARAMETERS\n    // ------------------------------------------------------------\n    int unsigned SYS_CLK_FREQ = 50_000_000,   // Hz  : system-clock frequency\n    int unsigned I2C_CLK_FREQ =   100_000     // Hz  : desired SCL\n) (\n    input  logic       clk,        // system clock\n    input  logic       rst,        // asynchronous reset (active high)\n    input  logic       I2C_Start,  // pulse \u21d2 start a transaction\n    input  logic       RW,         // 0 = write, 1 = read\n    input  logic [9:0] slave_addr, // 10-bit address to be put on the bus\n    input  logic [7:0] data_in,    // byte to write\n    inout  tri         I2C_SDA,    // bidirectional open-drain\n    output tri         I2C_SCL,    // open-drain clock\n    output logic [7:0] data_out,   // byte read from slave\n    output logic       I2C_En,     // high while module owns the bus\n    output logic       busy        // same as I2C_En, one extra cycle early\n);\n\n    // ------------------------------------------------------------\n    // 1.  Clock divider ( four phases / bit )\n    // ------------------------------------------------------------\n    localparam int DIVIDER = SYS_CLK_FREQ / (I2C_CLK_FREQ * 4);\n    localparam int DIVW    = $clog2(DIVIDER);\n\n    logic [DIVW-1:0] div_cnt;\n    logic            scl_en_4x;       // enable @ 4\u00d7SCL (phases A,B,C,D)\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            div_cnt   <= '0;\n            scl_en_4x <= 1'b0;\n        end else if (div_cnt == DIVIDER-1) begin\n            div_cnt   <= '0;\n            scl_en_4x <= 1'b1;\n        end else begin\n            div_cnt   <= div_cnt + 1;\n            scl_en_4x <= 1'b0;\n        end\n    end\n\n    // ------------------------------------------------------------\n    // 2.  Two open-drain output enables\n    // ------------------------------------------------------------\n    logic scl_drive_low;   // 1 = pull SCL low, 0 = release\n    logic sda_drive_low;   // 1 = pull SDA low, 0 = release\n\n    assign I2C_SCL = (scl_drive_low) ? 1'b0 : 1'bz;  // external PU resistor pulls high\n    assign I2C_SDA = (sda_drive_low) ? 1'b0 : 1'bz;\n    wire   sda_in  = I2C_SDA;                        // read back data\n\n    // ------------------------------------------------------------\n    // 3.  Main FSM\n    // ------------------------------------------------------------\n    // Each state lasts one 4\u00d7CLK phase (A,B,C,D = 00,01,10,11)\n    typedef enum logic [4:0] {\n        ST_IDLE,\n        // START generation\n        ST_START_A, ST_START_B,\n        // 1st address byte (10-bit mode) or single 7-bit addr\n        ST_ADDR,        ST_ADDR_ACK,\n        ST_ADDR2,       ST_ADDR2_ACK,   // only if 10-bit\n        // Data (write or read)\n        ST_DATA,        ST_DATA_ACK,\n        ST_READ_DATA,   ST_READ_ACK,\n        // STOP\n        ST_STOP_A,      ST_STOP_B,\n        ST_DONE\n    } state_t;\n\n    state_t    state, n_state;\n    logic [3:0] bit_cnt;              // counts down 7..0\n    logic [7:0] shift_reg;            // holds byte being sent/received\n    logic       ack_bit;              // stores ACK from slave\n\n    // Handy short-cuts\n    wire is10 = 1'b1;                 // instantiate as 10-bit master by default\n    wire phase_B = scl_phase[1:0] == 2'd1;  // just after SCL transitions low\u2192high\n    wire phase_C = scl_phase[1:0] == 2'd2;  // SCL high\n    wire phase_D = scl_phase[1:0] == 2'd3;  // just before SCL high\u2192low\n\n    // 4-phase tracker:  00 01 10 11 (A->B->C->D)\n    logic [1:0] scl_phase;\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) scl_phase <= 2'd0;\n        else if (scl_en_4x) scl_phase <= scl_phase + 1'b1;\n    end\n\n    // ------------------------------------------------------------\n    // 4.  Sequential part\n    // ------------------------------------------------------------\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state         <= ST_IDLE;\n            bit_cnt       <= 4'd0;\n            shift_reg     <= 8'd0;\n            ack_bit       <= 1'b1;\n            scl_drive_low <= 1'b1; // keep SCL low during reset\n            sda_drive_low <= 1'b1; // keep SDA low during reset\n            data_out      <= 8'd0;\n        end\n        else if (scl_en_4x) begin\n            // ----------------------------------------------------\n            // Combinational next-state logic has set n_state/\u2026\n            // Evaluate during *phase A* (scl_phase==00)\n            // ----------------------------------------------------\n            // Common default releases\n            scl_drive_low <= 1'b0;           // release (let it go high)\n            sda_drive_low <= 1'b0;\n\n            case (state)\n                // ------------------------------------------------\n                ST_IDLE: begin\n                    if (I2C_Start) begin\n                        state         <= ST_START_A;\n                        scl_drive_low <= 1'b1; // pull SCL low before START sequence\n                    end\n                end\n\n                // ------------------------------------------------\n                // START  = SDA high\u2192low while SCL is 1\n                //   A: SCL=1, SDA=1   (bus idle)\n                //   B: SDA pulls low\n                //   C: SCL pulls low -> enters data phase\n                // ------------------------------------------------\n                ST_START_A: begin\n                    // ensure both released; bus should be idle\n                    if (scl_phase == 2'd1) state <= ST_START_B;\n                end\n                ST_START_B: begin\n                    sda_drive_low <= 1'b1;  // drive SDA low\n                    if (scl_phase == 2'd2) state <= ST_ADDR; // SCL already high, next fall\n                end\n\n                // ------------------------------------------------\n                // First address byte   (11110 AA9 AA8 R/W) for 10-bit\n                // or 7-bit (AAA AAA R/W)\n                // ------------------------------------------------\n                ST_ADDR: begin\n                    // Phase A: load shift register / counter (once)\n                    if (scl_phase == 2'd0) begin\n                        shift_reg <= is10 ? { 3'b111, 2'b10, slave_addr[9:8], RW }\n                                          : { slave_addr[6:0], RW };\n                        bit_cnt   <= 4'd7;\n                    end\n                    // Phase C: shift out next bit while SCL high\n                    if (phase_C) begin\n                        sda_drive_low <= ~shift_reg[7]; // drive 0 for '0', release for '1'\n                    end\n                    // Phase D: shift register \u2190<<1\n                    if (phase_D) begin\n                        shift_reg <= {shift_reg[6:0], 1'b0};\n                        if (bit_cnt == 0) state <= ST_ADDR_ACK;\n                        else bit_cnt <= bit_cnt - 1;\n                    end\n                end\n\n                // ------------------------------------------------\n                // ACK cycles: release SDA during bit time, sample at C-phase\n                // ------------------------------------------------\n                ST_ADDR_ACK, ST_ADDR2_ACK, ST_DATA_ACK, ST_READ_ACK: begin\n                    // release SDA so slave can pull low\n                    if (phase_C) ack_bit <= ~sda_in;  // ACK = SDA low\n                    if (phase_D) begin\n                        // decide next state\n                        case (state)\n                            ST_ADDR_ACK:   state <= is10 ? ST_ADDR2  : (RW ? ST_READ_DATA : ST_DATA);\n                            ST_ADDR2_ACK:  state <= RW   ? ST_READ_DATA : ST_DATA;\n                            ST_DATA_ACK:   state <= ST_STOP_A;\n                            ST_READ_ACK:   state <= ST_STOP_A;\n                        endcase\n                    end\n                end\n\n                // ------------------------------------------------\n                // SECOND address byte (lower 8 bits) \u2013 10-bit only\n                // ------------------------------------------------\n                ST_ADDR2: begin\n                    if (scl_phase == 2'd0) begin\n                        shift_reg <= slave_addr[7:0];\n                        bit_cnt   <= 4'd7;\n                    end\n                    if (phase_C) sda_drive_low <= ~shift_reg[7];\n                    if (phase_D) begin\n                        shift_reg <= {shift_reg[6:0], 1'b0};\n                        if (bit_cnt == 0) state <= ST_ADDR2_ACK;\n                        else bit_cnt <= bit_cnt - 1;\n                    end\n                end\n\n                // ------------------------------------------------\n                // WRITE DATA byte\n                // ------------------------------------------------\n                ST_DATA: begin\n                    if (scl_phase == 2'd0) begin\n                        shift_reg <= data_in;\n                        bit_cnt   <= 4'd7;\n                    end\n                    if (phase_C) sda_drive_low <= ~shift_reg[7];\n                    if (phase_D) begin\n                        shift_reg <= {shift_reg[6:0], 1'b0};\n                        if (bit_cnt == 0) state <= ST_DATA_ACK;\n                        else bit_cnt <= bit_cnt - 1;\n                    end\n                end\n\n                // ------------------------------------------------\n                // READ DATA byte\n                // ------------------------------------------------\n                ST_READ_DATA: begin\n                    if (scl_phase == 2'd0) begin\n                        bit_cnt   <= 4'd7;\n                        shift_reg <= '0;\n                    end\n                    // master releases SDA during data in\n                    if (phase_C) begin\n                        shift_reg <= { shift_reg[6:0], sda_in };\n                    end\n                    if (phase_D) begin\n                        if (bit_cnt == 0) begin\n                            data_out <= shift_reg;\n                            state    <= ST_READ_ACK;\n                        end\n                        else bit_cnt <= bit_cnt - 1;\n                    end\n                end\n\n                // ------------------------------------------------\n                // STOP sequence:  SCL low, SDA low (A)\n                //                 SCL high (B)\n                //                 SDA high (C) \u2013 rising edge while SCL high\n                // ------------------------------------------------\n                ST_STOP_A: begin\n                    scl_drive_low <= 1'b1;   // keep SCL low\n                    sda_drive_low <= 1'b1;   // keep SDA low\n                    if (phase_D) state <= ST_STOP_B;\n                end\n                ST_STOP_B: begin\n                    scl_drive_low <= 1'b0;   // release SCL -> goes high\n                    sda_drive_low <= 1'b1;   // still low\n                    if (phase_C)   sda_drive_low <= 1'b0; // release SDA -> rises\n                    if (phase_D)   state <= ST_DONE;\n                end\n\n                // ------------------------------------------------\n                ST_DONE: begin\n                    state <= ST_IDLE;\n                end\n\n                default: state <= ST_IDLE;\n            endcase\n        end\n    end\n\n    // ------------------------------------------------------------\n    // 5.  Busy / enable indications\n    // ------------------------------------------------------------\n    assign I2C_En = (state != ST_IDLE);\n    assign busy   = I2C_En;\n\nendmodule\n```\n\nHow to use the module\n---------------------\n1. Provide the desired system clock and set `SYS_CLK_FREQ`.\n2. Adapt `I2C_CLK_FREQ` (100 kHz default) to fit the bus speed you need.\n3. Pulse `I2C_Start` for **one clock cycle** while providing\n   * `RW   = 0` and `data_in` for a **write**  \n   * `RW   = 1` for a **read**\n4. Monitor `busy`.  When it de-asserts, the transaction has finished and\n   `data_out` (for reads) is valid.\n\nNotes / possible extensions\n---------------------------\n\u2022 For a pure 7-bit design just set `is10 = 1'b0`.  \n\u2022 The code is intentionally written with only one data byte; extend state-machine branches `ST_DATA` / `ST_READ_DATA` to iterate over multiple bytes if needed.  \n\u2022 For an exact 10-bit read per I\u00b2C spec, a *repeated START* must be generated before re-sending the first address byte with `R/W = 1`.  A small addition in the FSM (\u201cRS\u201d state) enables this."
}
