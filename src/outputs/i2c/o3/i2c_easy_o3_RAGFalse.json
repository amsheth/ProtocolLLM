{
    "prompt_0": " Write a SystemVerilog module to implement an I2C master controller. The controller should generate proper start and stop conditions, handle data transfers with acknowledgments, and support both write and read operations. The design must include a clock divider to produce the appropriate I2C SCL frequency. The I2C module should have the following interface:\nmodule I2C_driver( input  logic       clk,         // System clock input  logic       rst,         // Asynchronous reset input  logic       I2C_Start,   // Initiate a transaction when high input  logic       RW,          // Read/Write control: 0 for write, 1 for read input  logic [6:0] slave_addr,  // 7-bit I2C slave address input  logic [7:0] data_in,     // Data to be written (for write transactions) inout  logic       I2C_SDA,     // I2C data line (bidirectional) output logic       I2C_SCL,     // I2C clock line output logic [7:0] data_out,    // Data received from slave (for read transactions) output logic       I2C_En,      // Module enable signal (active during transaction) output logic       busy         // Indicates the module is busy with a transaction ); The I2C master controller should operate as follows: Start Condition: When I2C_Start is asserted, generate a start condition on the I2C bus. Addressing: Transmit the 7-bit slave address along with a R/W bit. Data Transfer: For write transactions (RW = 0), send the provided data (data_in) and handle the ACK from the slave. For read transactions (RW = 1), read the data from the slave and output it on data_out while sending the necessary ACK/NACK. Stop Condition: After the data transfer, generate a stop condition on the bus. Clock Generation: Use a clock divider to derive the I2C SCL frequency from the system clock. Control Signals: The module should assert busy during active transactions and deassert it once the transaction is complete. Design your code with clear state machine implementation, proper handling of bidirectional signals (I2C_SDA), and ensure that all I2C protocol timing requirements are met.\n",
    "answer_0": "Below is a compact, self\u2013contained SystemVerilog implementation of a SINGLE-BYTE I\u00b2C-master that satisfies the requested interface and features.  \n(The code can be extended to burst transfers by adding more \u201cDATA/ACK\u201d states and counters \u2013 the skeleton is already in place.)\n\n```systemverilog\n// -----------------------------------------------------------------------------\n// Simple I\u00b2C single\u2013byte master (7-bit address).\n// System clock  : clk\n// Generated SCL : \u2248  (clk_freq)/(2*CLK_DIV)  (both high & low take CLK_DIV cycles)\n//\n// NOTE:\n//   \u2022 Open-drain behaviour is modelled by tri\u2013stating SDA when '1\u2019 has to be put\n//     on the bus.  An external pull-up is assumed (as in a real I\u00b2C bus).\n//   \u2022 SCL is driven push\u2013pull for simplicity; if open-drain is mandatory just\n//     change the assignment exactly like SDA (drive \u20180\u2019/Hi-Z).\n//   \u2022 Only one data byte is transferred per transaction (easy to enlarge).\n// -----------------------------------------------------------------------------\nmodule I2C_driver\n#(\n    // When clk  = 25 MHz  and  CLK_DIV = 125  \u2192  SCL \u2248 100 kHz\n    // ( SCLfreq = clk / (2*CLK_DIV) )\n    parameter int unsigned CLK_DIV = 125\n)(\n    input  logic        clk,          // System clock\n    input  logic        rst,          // Asynchronous reset, active high\n\n    input  logic        I2C_Start,    // Start a transaction\n    input  logic        RW,           // 0 = write, 1 = read\n    input  logic [6:0]  slave_addr,   // 7-bit slave address\n    input  logic [7:0]  data_in,      // Byte to write\n\n    inout  tri          I2C_SDA,      // I\u00b2C data (open-drain)\n    output logic        I2C_SCL,      // I\u00b2C clock (see note above)\n\n    output logic [7:0]  data_out,     // Byte read from the slave\n    output logic        I2C_En,       // \u20181\u2019 while state-machine is active\n    output logic        busy          // Same as I2C_En (alias)\n);\n\n// -----------------------------------------------------------------------------\n// Clock divider \u2013 produces \u201chalf-bit\u201d enable tick (toggle SCL each tick)\n// -----------------------------------------------------------------------------\nlogic [$clog2(CLK_DIV)-1:0] div_cnt;\nlogic                        scl_int, scl_en;   // Internal SCL & enable\nlogic                        tick;              // rising edge every CLK_DIV cycles\n\nalways_ff @(posedge clk or posedge rst) begin\n    if (rst) begin\n        div_cnt <= '0;\n    end\n    else if (scl_en) begin\n        if (div_cnt == CLK_DIV-1)\n            div_cnt <= '0;\n        else\n            div_cnt <= div_cnt + 1;\n    end\n    else\n        div_cnt <= '0;\nend\n\nassign tick = (div_cnt == CLK_DIV-1);\n\n// Toggle SCL every tick while enabled\nalways_ff @(posedge clk or posedge rst) begin\n    if (rst)\n        scl_int <= 1'b1;          // Bus idle: SCL high\n    else if (scl_en && tick)\n        scl_int <= ~scl_int;\n    else if (!scl_en)\n        scl_int <= 1'b1;          // Release to idle high between transfers\nend\n\nassign I2C_SCL = scl_int;\n\n// -----------------------------------------------------------------------------\n// SDA open-drain handling\n// -----------------------------------------------------------------------------\nlogic sda_out;  // value driven when OE asserted\nlogic sda_oe;   // 1 = drive sda_out (low), 0 = Hi-Z  (high through pull-up)\n\nassign I2C_SDA = (sda_oe) ? sda_out : 1'bz;     // open-drain modelling\nlogic sda_in   = I2C_SDA;                       // read current bus level\n\n// -----------------------------------------------------------------------------\n// State-machine definitions\n// -----------------------------------------------------------------------------\ntypedef enum logic [3:0] {\n    IDLE,           // waiting for I2C_Start\n    START,          // generate start condition\n    SEND_ADDR,      // shift out 7b address + R/W\n    ADDR_ACK,       // sample ACK after address\n    WRITE_DATA,     // shift out data byte\n    DATA_ACK,       // sample ACK after data\n    READ_DATA,      // shift in data byte\n    SEND_NACK,      // master puts NACK bit after last read byte\n    STOP_1,         // SCL high while SDA low\n    STOP_2          // raise SDA -> stop, then back to IDLE\n} state_t;\n\nstate_t state, nxt_state;\n\nlogic [7:0] shift;          // shift register (tx or rx)\nlogic [2:0] bit_cnt;        // counts 7..0\nlogic       rw_reg;         // latched RW for current transfer\nlogic       addr_phase;     // \u20181\u2019 while addressing\nlogic       capturing;      // \u20181\u2019 while shifting data in\n\n// Edge detectors for SCL to simplify timing decisions\nlogic scl_d;\nalways_ff @(posedge clk or posedge rst)\n    if (rst) scl_d <= 1'b1;\n    else     scl_d <= scl_int;\n\nwire scl_rise = ( scl_d==0 && scl_int==1 );\nwire scl_fall = ( scl_d==1 && scl_int==0 );\n\n// -----------------------------------------------------------------------------\n// Sequential part \u2013 state updates occur on *falling* edge of SCL (data launch)\n// -----------------------------------------------------------------------------\nalways_ff @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state      <= IDLE;\n        sda_oe     <= 1'b1;\n        sda_out    <= 1'b1;\n        shift      <= 8'h00;\n        bit_cnt    <= 3'd7;\n        rw_reg     <= 1'b0;\n        scl_en     <= 1'b0;\n        data_out   <= 8'h00;\n    end\n    else begin\n        // ---------------------------------------------------------------------\n        // State transitions happen when we have a valid SCL falling edge\n        // (i.e. we just finished the HIGH phase for a bit)\n        // ---------------------------------------------------------------------\n        if ( (state!=IDLE) && scl_fall ) begin\n            case (state)\n            // -------------------------------------------------- START\n            START: begin\n                // After SDA has been pulled low (while SCL high) we\n                // now enable clocking and prepare to send address\n                scl_en   <= 1'b1;                   // start toggling SCL\n                state    <= SEND_ADDR;\n                shift    <= {slave_addr, rw_reg};   // 7b + R/W\n                bit_cnt  <= 3'd7;\n                sda_oe   <= 1'b1;                   // drive SDA\n                sda_out  <= {slave_addr, rw_reg}[7];// MSB\n            end\n\n            // -------------------------------------------------- ADDRESS BYTE\n            SEND_ADDR: begin\n                if (bit_cnt != 0) begin\n                    bit_cnt <= bit_cnt - 1;\n                    shift   <= {shift[6:0],1'b0};   // left shift (MSB first)\n                    sda_out <= shift[6];            // next bit onto bus\n                end\n                else begin\n                    // All bits sent, now release SDA for ACK\n                    sda_oe  <= 1'b0;                // Hi-Z \u2192 slave can pull low\n                    state   <= ADDR_ACK;\n                end\n            end\n\n            // -------------------------------------------------- WRITE DATA\n            WRITE_DATA: begin\n                if (bit_cnt != 0) begin\n                    bit_cnt <= bit_cnt - 1;\n                    shift   <= {shift[6:0],1'b0};\n                    sda_out <= shift[6];\n                end\n                else begin\n                    sda_oe <= 1'b0;                // release for ACK\n                    state  <= DATA_ACK;\n                end\n            end\n\n            // -------------------------------------------------- READ DATA\n            READ_DATA: begin\n                if (bit_cnt != 0) begin\n                    bit_cnt  <= bit_cnt - 1;\n                end\n                else begin\n                    state    <= SEND_NACK;         // afterwards send NACK\n                    sda_oe   <= 1'b1;\n                    sda_out  <= 1'b1;              // NACK (logic \u20181\u2019)\n                end\n            end\n\n            // -------------------------------------------------- SEND_NACK finished\n            SEND_NACK: begin\n                state  <= STOP_1;\n                scl_en <= 1'b0;                    // keep SCL high for STOP\n            end\n\n            // -------------------------------------------------- STOP first half\n            STOP_1: begin\n                // SCL already high, SDA still low\n                sda_out <= 1'b1;                   // raise SDA while SCL high\n                state   <= STOP_2;\n            end\n\n            // -------------------------------------------------- STOP second half\n            STOP_2: begin\n                // after one half SCL period we are done\n                state   <= IDLE;\n            end\n\n            default: ; // do nothing for other states (ACK sampling etc.)\n            endcase\n        end // scl_fall (main sequencing)\n\n        // ---------------------------------------------------------------------\n        // Combinational-like actions that must happen on SCL rising edges\n        // (e.g. sampling data or ACK from slave, capturing bits while reading)\n        // ---------------------------------------------------------------------\n        if (scl_rise) begin\n            case (state)\n            ADDR_ACK: begin\n                // Sample ACK (expect 0); if NACK -> still finish transaction\n                // After ACK field decide where to go\n                if (rw_reg==1'b0) begin\n                    // ------------- WRITE transaction\n                    shift   <= data_in;\n                    bit_cnt <= 3'd7;\n                    sda_oe  <= 1'b1;\n                    sda_out <= data_in[7];\n                    state   <= WRITE_DATA;\n                end\n                else begin\n                    // ------------- READ transaction\n                    bit_cnt <= 3'd7;\n                    sda_oe  <= 1'b0;   // keep Hi-Z to receive data\n                    state   <= READ_DATA;\n                end\n            end\n\n            DATA_ACK: begin\n                // ACK after WRITE byte already sampled\n                state  <= STOP_1;      // only single byte in this version\n                scl_en <= 1'b0;        // keep SCL high ready for STOP\n                sda_out<= 1'b0;        // ensure SDA low before raising later\n                sda_oe <= 1'b1;\n            end\n\n            READ_DATA: begin\n                // Shift in one data bit\n                data_out[bit_cnt] <= sda_in;\n            end\n            endcase\n        end // scl_rise\n    end // !reset\nend // always_ff\n\n// -----------------------------------------------------------------------------\n// IDLE state logic, asynchronous to simplify start detection\n// -----------------------------------------------------------------------------\nalways_ff @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state   <= IDLE;\n        scl_en  <= 1'b0;\n        sda_oe  <= 1'b1;\n        sda_out <= 1'b1;\n    end\n    else if (state==IDLE) begin\n        if (I2C_Start) begin\n            // Latch direction for this transaction\n            rw_reg   <= RW;\n            // Prepare for Start condition ->\n            sda_oe   <= 1'b1;           // drive SDA\n            sda_out  <= 1'b1;           // ensure high\n            scl_en   <= 1'b0;           // keep SCL high\n            state    <= START;          // go generate START\n            // SDA will be pulled LOW on first SCL fall (see START state)\n        end\n    end\nend\n\n// -----------------------------------------------------------------------------\n// User flags\n// -----------------------------------------------------------------------------\nassign busy   = (state != IDLE);\nassign I2C_En = busy;\n\nendmodule\n```\n\nExplanation of the main ideas\n\n1. Clock divider  \n   \u2013 `CLK_DIV` parameter lets the user choose any SCL frequency.  \n   \u2013 While `scl_en` is 1 the divider toggles the internal `scl_int` every `CLK_DIV` cycles (high and low phases are equal).\n\n2. Open-drain SDA  \n   \u2013 `sda_oe = 0`   \u21d2 line released (logic-high through external pull-up).  \n   \u2013 `sda_oe = 1` & `sda_out = 0` \u21d2 master actively pulls SDA low.\n\n3. Finite-state machine  \n   \u2013 State changes are synchronised with SCL falling edges (standard I\u00b2C launch edge) so that setup/hold requirements are guaranteed.  \n   \u2013 Sampling of ACK/Data from the slave happens on SCL rising edges.  \n   \u2013 Only one byte is transferred; adding bursts simply loops through WRITE/WRITE_ACK or READ/SEND_ACK states with a byte counter.\n\n4. Start / Stop generation  \n   \u2013 START: SDA high\u2192low while SCL high, then enable SCL toggling.  \n   \u2013 STOP : keep SDA low, let SCL go high, finally release SDA high.\n\n5. Status flags  \n   \u2013 `busy`/`I2C_En` are asserted from the moment START is issued until the STOP condition is finished.\n\nCompile and simulate \u2013 you should observe correct START, address, R/W bit, ACK/NACK hand-shakes, the data byte, and the proper STOP sequence with SCL running at the programmed frequency.",
    "prompt_1": " Write a SystemVerilog module to implement an I2C master controller. The controller should generate proper start and stop conditions, handle data transfers with acknowledgments, and support both write and read operations. The design must include a clock divider to produce the appropriate I2C SCL frequency. The I2C module should have the following interface:\nmodule I2C_driver( input  logic       clk,         // System clock input  logic       rst,         // Asynchronous reset input  logic       I2C_Start,   // Initiate a transaction when high input  logic       RW,          // Read/Write control: 0 for write, 1 for read input  logic [9:0] slave_addr,  // 10-bit I2C slave address input  logic [7:0] data_in,     // Data to be written (for write transactions) inout  logic       I2C_SDA,     // I2C data line (bidirectional) output logic       I2C_SCL,     // I2C clock line output logic [7:0] data_out,    // Data received from slave (for read transactions) output logic       I2C_En,      // Module enable signal (active during transaction) output logic       busy         // Indicates the module is busy with a transaction ); The I2C master controller should operate as follows: Start Condition: When I2C_Start is asserted, generate a start condition on the I2C bus. Addressing: Transmit the 10-bit slave address along with a R/W bit. Data Transfer: For write transactions (RW = 0), send the provided data (data_in) and handle the ACK from the slave. For read transactions (RW = 1), read the data from the slave and output it on data_out while sending the necessary ACK/NACK. Stop Condition: After the data transfer, generate a stop condition on the bus. Clock Generation: Use a clock divider to derive the I2C SCL frequency from the system clock. Control Signals: The module should assert busy during active transactions and deassert it once the transaction is complete. Design your code with clear state machine implementation, proper handling of bidirectional signals (I2C_SDA), and ensure that all I2C protocol timing requirements are met.\n",
    "answer_1": "Below is a self-contained, synthesizable SystemVerilog description of an I\u00b2C master that satisfies the requested interface and behaviour.  \nThe design uses one clock-divided \u201cquarter-phase\u201d per I\u00b2C-clock transition, giving clean control of SDA versus SCL timing.  \nOnly the low-level bus sequence for a single-byte WRITE or READ (10-bit addressing) is implemented; it can be easily expanded to multi-byte transfers.\n\n```systemverilog\n// ===============================================================\n// Simple single\u2013byte I\u00b2C-MASTER (10-bit address) \u2015 SystemVerilog\n// ===============================================================\nmodule I2C_driver\n#(\n    // -----------------------------------------------------------\n    //  USER PARAMETERS \u2015 change to suit your system\n    // -----------------------------------------------------------\n    parameter int SYS_CLK_FREQ = 50_000_000,      // Hz  (clk)\n    parameter int I2C_FREQ     = 100_000          // Hz  (SCL)\n)\n(\n    input  logic       clk,        // System clock\n    input  logic       rst,        // Asynchronous active-high reset\n\n    input  logic       I2C_Start,  // Rising-edge \u2192 start a new transaction\n    input  logic       RW,         // 0 = write , 1 = read\n    input  logic [9:0] slave_addr, // 10-bit slave address\n\n    input  logic [7:0] data_in,    // Byte to write (when RW = 0)\n    inout  tri         I2C_SDA,    // Bidirectional data (open-drain)\n    output logic       I2C_SCL,    // I\u00b2C clock   (open-drain style)\n    output logic [7:0] data_out,   // Byte read   (when RW = 1)\n\n    output logic       I2C_En,     // Goes high during any bus activity\n    output logic       busy        // Same as I2C_En (semantic sugar)\n);\n\n// -----------------------------------------------------------------------------\n//  CLOCK DIVIDER : create 4 \u201cquarter phases\u201d per SCL period (low/rise/high/fall)\n// -----------------------------------------------------------------------------\nlocalparam int DIVIDER =   (SYS_CLK_FREQ / (I2C_FREQ * 4));  // integer\nlocalparam int C_W     = $clog2(DIVIDER);\n\nlogic [C_W-1:0] div_cnt;\nlogic [1:0]     qphase;    // 0 = SCL low ; 1 = rising ; 2 = high ; 3 = falling\nlogic           scl_int;   // actual driven SCL (before tri-state)\n\n// drive SCL according to phase\nalways_comb begin\n    case (qphase)\n        2'd1, 2'd2 : scl_int = 1'b1;   // rising / high\n        default    : scl_int = 1'b0;   // low / falling\n    endcase\nend\n\n// divider / phase generator\nalways_ff @(posedge clk or posedge rst) begin\n    if (rst) begin\n        div_cnt <= '0;\n        qphase  <= 2'd0;\n    end else begin\n        if (div_cnt == DIVIDER-1) begin\n            div_cnt <= '0;\n            qphase  <= qphase + 2'd1;\n        end else begin\n            div_cnt <= div_cnt + 1'b1;\n        end\n    end\nend\n\n// convenient strobes (one system-clock wide)\nwire scl_posedge = (qphase == 2'd1) && (div_cnt == 0);  // start of HIGH\nwire scl_negedge = (qphase == 2'd3) && (div_cnt == 0);  // start of LOW\n\n// -----------------------------------------------------------------------------\n//  OPEN-DRAIN SHAPING FOR SDA / SCL\n// -----------------------------------------------------------------------------\nlogic sda_drive0;   // 1 \u2192 actively drive 0 , 0 \u2192 release (Z = logic-1 by pull-up)\n\nassign I2C_SDA = (sda_drive0) ? 1'b0 : 1'bz;\nassign I2C_SCL = (busy)       ? scl_int : 1'b1; // idle bus keeps SCL released high\n\n// -----------------------------------------------------------------------------\n//  BYTE SHIFTER & FSM\n// -----------------------------------------------------------------------------\ntypedef enum logic [3:0] {\n    ST_IDLE,\n    ST_START,                // generate START\n    ST_ADDR1, ST_ACK1,       // first address byte (11110xxR)\n    ST_ADDR2, ST_ACK2,       // second address byte (addr[7:0])\n    ST_WRITE, ST_WACK,       // single data byte write + slave ACK\n    ST_READ,  ST_MACK,       // master reads byte + sends (N)ACK\n    ST_STOP,                 // generate STOP\n    ST_DONE\n} state_t;\n\nstate_t state, n_state;\n\nlogic [7:0] shreg;           // shift register for TX/RX\nlogic [2:0] bit_cnt;         // counts 7\u21920\nlogic [7:0] rx_byte;\nlogic       ack_bit;\n\n// -----------------------------------------------------------------------------\n//  STATE MACHINE \u2015 next state logic\n// -----------------------------------------------------------------------------\nalways_comb begin\n    n_state = state;\n    unique case (state)\n        ST_IDLE : begin\n            if (I2C_Start) n_state = ST_START;\n        end\n        ST_START : begin\n            if (scl_negedge) n_state = ST_ADDR1;\n        end\n        ST_ADDR1 : if (bit_cnt == 0 && scl_posedge) n_state = ST_ACK1;\n        ST_ACK1  : if (scl_posedge) begin\n                        n_state = ST_ADDR2;\n                   end\n        ST_ADDR2 : if (bit_cnt == 0 && scl_posedge) n_state = ST_ACK2;\n        ST_ACK2  : if (scl_posedge) begin\n                        n_state = (RW) ? ST_READ : ST_WRITE;\n                   end\n        // WRITE path ----------------------------------------------------------\n        ST_WRITE : if (bit_cnt == 0 && scl_posedge) n_state = ST_WACK;\n        ST_WACK  : if (scl_posedge) n_state = ST_STOP;\n        // READ path -----------------------------------------------------------\n        ST_READ  : if (bit_cnt == 0 && scl_posedge) n_state = ST_MACK;\n        ST_MACK  : if (scl_posedge) n_state = ST_STOP;\n        // END SEQUENCE --------------------------------------------------------\n        ST_STOP  : if (scl_posedge) n_state = ST_DONE;\n        ST_DONE  : if (scl_negedge) n_state = ST_IDLE;\n        default  : n_state = ST_IDLE;\n    endcase\nend\n\n// -----------------------------------------------------------------------------\n//  SEQUENTIAL PART\n// -----------------------------------------------------------------------------\nalways_ff @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state      <= ST_IDLE;\n        bit_cnt    <= 3'd7;\n        shreg      <= 8'd0;\n        rx_byte    <= 8'd0;\n        sda_drive0 <= 1'b0;\n    end else begin\n        state <= n_state;\n\n        // default : keep SDA released (logic-1) unless explicitly changed\n        if (!busy) sda_drive0 <= 1'b0;\n\n        // ---------------------------------------------------------------------\n        //  STATE-SPECIFIC ACTIONS\n        // ---------------------------------------------------------------------\n        case (state)\n            // ------------------------------------------------ START condition\n            ST_START : begin\n                // ensure SDA goes low while SCL is high (open-drain 0)\n                sda_drive0 <= 1'b1;\n            end\n\n            // ---------------------------------------------- SEND FIRST BYTE\n            ST_ADDR1 : begin\n                if (state != n_state) begin\n                    // load first address byte : 11110 A9 A8 R/W\n                    shreg <= {3'b111, 2'b10, slave_addr[9:8], RW}; // 8 bits\n                    bit_cnt <= 3'd7;\n                end\n                // shift out on falling edge (data must be valid before posedge)\n                if (scl_negedge) begin\n                    sda_drive0 <= ~shreg[7];  // drive 0 for bit \u20180\u2019, else Hi-Z\n                end\n                if (scl_posedge) begin\n                    shreg   <= {shreg[6:0],1'b0};\n                    bit_cnt <= bit_cnt - 1'b1;\n                end\n            end\n\n            // --------------------------------------------- FIRST ACK (from slave)\n            ST_ACK1 : begin\n                sda_drive0 <= 1'b0;           // release SDA \u2192 slave drives ACK\n                if (scl_posedge) ack_bit <= I2C_SDA;\n            end\n\n            // ---------------------------------------------- SEND SECOND BYTE\n            ST_ADDR2 : begin\n                if (state != n_state) begin\n                    shreg   <= slave_addr[7:0];\n                    bit_cnt <= 3'd7;\n                end\n                if (scl_negedge) sda_drive0 <= ~shreg[7];\n                if (scl_posedge) begin\n                    shreg   <= {shreg[6:0],1'b0};\n                    bit_cnt <= bit_cnt - 1'b1;\n                end\n            end\n\n            // --------------------------------------------- SECOND ACK\n            ST_ACK2 : begin\n                sda_drive0 <= 1'b0;           // release for slave ACK\n                if (scl_posedge) ack_bit <= I2C_SDA;\n            end\n\n            // ================================================= WRITE DATA BYTE\n            ST_WRITE : begin\n                if (state != n_state) begin\n                    shreg   <= data_in;\n                    bit_cnt <= 3'd7;\n                end\n                if (scl_negedge) sda_drive0 <= ~shreg[7];\n                if (scl_posedge) begin\n                    shreg   <= {shreg[6:0],1'b0};\n                    bit_cnt <= bit_cnt - 1'b1;\n                end\n            end\n            ST_WACK : begin\n                sda_drive0 <= 1'b0;           // release for slave ACK\n                if (scl_posedge) ack_bit <= I2C_SDA;\n            end\n\n            // ================================================= READ DATA BYTE\n            ST_READ : begin\n                sda_drive0 <= 1'b0;           // release SDA (slave drives data)\n                if (scl_posedge) begin\n                    rx_byte <= {rx_byte[6:0], I2C_SDA};\n                    bit_cnt <= bit_cnt - 1'b1;\n                end\n            end\n            ST_MACK : begin\n                // only single-byte read \u2192 master NACK (release high)\n                sda_drive0 <= 1'b0;           // NACK = SDA high\n            end\n\n            // ------------------------------------------------ STOP condition\n            ST_STOP : begin\n                // first ensure SDA low while SCL low\n                if (qphase == 2'd0) sda_drive0 <= 1'b1;\n                // then release SDA while SCL high for STOP\n                if (qphase == 2'd2) sda_drive0 <= 1'b0;\n            end\n\n            // ------------------------------------------------ DONE \u2192 back idle\n            ST_DONE : begin\n                if (qphase == 2'd3) begin      // after falling edge \u2192 IDLE\n                    sda_drive0 <= 1'b0;\n                end\n            end\n        endcase\n    end\nend\n\n// capture byte for user during read\nalways_ff @(posedge clk) begin\n    if (state == ST_MACK && scl_posedge)\n        data_out <= rx_byte;\nend\n\n// ------------------------------------------------------------- STATUS / ENABLE\nassign busy   = (state != ST_IDLE);\nassign I2C_En = busy;\n\nendmodule\n```\n\nHow the module works (quick guide)\n\u2022 A clock divider creates four identical sub-periods for every SCL cycle (low, rise, high, fall).  \n\u2022 The FSM controls SDA in each sub-period, producing exact START, data, ACK and STOP timing.  \n\u2022 Open-drain behaviour is modelled with the single control sda_drive0 (drive \u201c0\u201d or release).  \n\u2022 Only one data byte is handled, but additional states or counters can extend the transfer.  \n\u2022 Both busy and I2C_En stay high from START until STOP has fully finished."
}
