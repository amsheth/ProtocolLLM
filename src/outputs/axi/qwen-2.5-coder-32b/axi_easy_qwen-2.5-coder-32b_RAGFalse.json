{
    "prompt_0": " Write a SystemVerilog module to implement an AXI4-Lite Master Interface. The module should handle read and write transactions, generate appropriate AXI signals, and ensure proper handshaking with the AXI slave. The design should follow the AXI4-Lite protocol and include the following interface:\n\nmodule AXI4_Lite_Master( input  logic        clk,          // System clock input  logic        rst,          // Asynchronous reset input  logic        AXI_Start,    // Start a new AXI transaction input  logic        AXI_WriteEn,  // 1 for write, 0 for read input  logic [31:0] AXI_Addr,     // Address for transaction input  logic [31:0] AXI_WData,    // Data to write output logic [31:0] AXI_RData,    // Data read from slave output logic        AXI_Done,     // Transaction complete\n// AXI4-Lite signals output logic [31:0] M_AXI_AWADDR, output logic        M_AXI_AWVALID, input  logic        M_AXI_AWREADY,\noutput logic [31:0] M_AXI_WDATA, output logic [3:0]  M_AXI_WSTRB, output logic        M_AXI_WVALID, input  logic        M_AXI_WREADY,\ninput  logic [1:0]  M_AXI_BRESP, input  logic        M_AXI_BVALID, output logic        M_AXI_BREADY,\noutput logic [31:0] M_AXI_ARADDR, output logic        M_AXI_ARVALID, input  logic        M_AXI_ARREADY,\ninput  logic [31:0] M_AXI_RDATA, input  logic [1:0]  M_AXI_RRESP, input  logic        M_AXI_RVALID, output logic        M_AXI_RREADY ); ",
    "answer_0": "```systemverilog\nmodule AXI4_Lite_Master(\n    input  logic        clk,          // System clock input\n    input  logic        rst,          // Asynchronous reset input\n    input  logic        AXI_Start,    // Start a new AXI transaction\n    input  logic        AXI_WriteEn,  // 1 for write, 0 for read\n    input  logic [31:0] AXI_Addr,     // Address for transaction\n    input  logic [31:0] AXI_WData,    // Data to write\n    output logic [31:0] AXI_RData,    // Data read from slave\n    output logic        AXI_Done,     // Transaction complete\n\n    // AXI4-Lite signals\n    output logic [31:0] M_AXI_AWADDR, \n    output logic        M_AXI_AWVALID,\n    input  logic        M_AXI_AWREADY,\n\n    output logic [31:0] M_AXI_WDATA, \n    output logic [3:0]  M_AXI_WSTRB, \n    output logic        M_AXI_WVALID, \n    input  logic        M_AXI_WREADY,\n\n    input  logic [1:0]  M_AXI_BRESP, \n    input  logic        M_AXI_BVALID, \n    output logic        M_AXI_BREADY,\n\n    output logic [31:0] M_AXI_ARADDR, \n    output logic        M_AXI_ARVALID, \n    input  logic        M_AXI_ARREADY,\n\n    input  logic [31:0] M_AXI_RDATA, \n    input  logic [1:0]  M_AXI_RRESP, \n    input  logic        M_AXI_RVALID, \n    output logic        M_AXI_RREADY\n);\n\n    typedef enum logic [2:0] {\n        IDLE,\n        WRITE_ADDR,\n        WRITE_DATA,\n        WRITE_RESP,\n        READ_ADDR,\n        READ_DATA\n    } state_t;\n\n    state_t state, next_state;\n\n    // Internal signals\n    logic [31:0] rdata_reg;\n    logic        done_reg;\n\n    // State machine\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            done_reg <= 0;\n        end else begin\n            state <= next_state;\n            done_reg <= 0;\n        end\n    end\n\n    // Next state logic\n    always_comb begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (AXI_Start) begin\n                    if (AXI_WriteEn)\n                        next_state = WRITE_ADDR;\n                    else\n                        next_state = READ_ADDR;\n                end\n            end\n            WRITE_ADDR: begin\n                if (M_AXI_AWREADY)\n                    next_state = WRITE_DATA;\n            end\n            WRITE_DATA: begin\n                if (M_AXI_WREADY)\n                    next_state = WRITE_RESP;\n            end\n            WRITE_RESP: begin\n                if (M_AXI_BVALID)\n                    next_state = IDLE;\n            end\n            READ_ADDR: begin\n                if (M_AXI_ARREADY)\n                    next_state = READ_DATA;\n            end\n            READ_DATA: begin\n                if (M_AXI_RVALID)\n                    next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Output logic\n    always_comb begin\n        // Default assignments\n        M_AXI_AWADDR  = '0;\n        M_AXI_AWVALID = 0;\n        M_AXI_WDATA   = '0;\n        M_AXI_WSTRB   = '0;\n        M_AXI_WVALID  = 0;\n        M_AXI_BREADY  = 0;\n        M_AXI_ARADDR  = '0;\n        M_AXI_ARVALID = 0;\n        M_AXI_RREADY  = 0;\n        AXI_RData     = '0;\n        AXI_Done      = done_reg;\n\n        case (state)\n            IDLE: begin\n                if (AXI_Start) begin\n                    if (AXI_WriteEn) begin\n                        M_AXI_AWADDR  = AXI_Addr;\n                        M_AXI_AWVALID = 1;\n                    end else begin\n                        M_AXI_ARADDR  = AXI_Addr;\n                        M_AXI_ARVALID = 1;\n                    end\n                end\n            end\n            WRITE_ADDR: begin\n                if (M_AXI_AWREADY) begin\n                    M_AXI_WDATA   = AXI_WData;\n                    M_AXI_WSTRB   = 4'b1111; // Assuming full word write\n                    M_AXI_WVALID  = 1;\n                end\n            end\n            WRITE_DATA: begin\n                if (M_AXI_WREADY) begin\n                    M_AXI_BREADY  = 1;\n                end\n            end\n            WRITE_RESP: begin\n                if (M_AXI_BVALID) begin\n                    done_reg = 1;\n                end\n            end\n            READ_ADDR: begin\n                if (M_AXI_ARREADY) begin\n                    M_AXI_RREADY  = 1;\n                end\n            end\n            READ_DATA: begin\n                if (M_AXI_RVALID) begin\n                    AXI_RData = M_AXI_RDATA;\n                    done_reg = 1;\n                end\n            end\n        endcase\n    end\n\nendmodule\n```\n\nThis SystemVerilog module implements a simple AXI4-Lite master interface that can perform read and write transactions. It uses a state machine to manage the different phases of the AXI4-Lite protocol. The module handles the handshaking signals (VALID and READY) to ensure proper communication with the AXI slave. The `AXI_Done` signal is asserted when a transaction is complete."
}
