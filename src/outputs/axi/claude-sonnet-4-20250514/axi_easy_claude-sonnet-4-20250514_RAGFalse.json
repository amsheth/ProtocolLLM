{
    "prompt_0": " Write a SystemVerilog module to implement an AXI4-Lite Master Interface. The module should handle read and write transactions, generate appropriate AXI signals, and ensure proper handshaking with the AXI slave. The design should follow the AXI4-Lite protocol and include the following interface:\n\nmodule AXI4_Lite_Master( input  logic        clk,          // System clock input  logic        rst,          // Asynchronous reset input  logic        AXI_Start,    // Start a new AXI transaction input  logic        AXI_WriteEn,  // 1 for write, 0 for read input  logic [31:0] AXI_Addr,     // Address for transaction input  logic [31:0] AXI_WData,    // Data to write output logic [31:0] AXI_RData,    // Data read from slave output logic        AXI_Done,     // Transaction complete\n// AXI4-Lite signals output logic [31:0] M_AXI_AWADDR, output logic        M_AXI_AWVALID, input  logic        M_AXI_AWREADY,\noutput logic [31:0] M_AXI_WDATA, output logic [3:0]  M_AXI_WSTRB, output logic        M_AXI_WVALID, input  logic        M_AXI_WREADY,\ninput  logic [1:0]  M_AXI_BRESP, input  logic        M_AXI_BVALID, output logic        M_AXI_BREADY,\noutput logic [31:0] M_AXI_ARADDR, output logic        M_AXI_ARVALID, input  logic        M_AXI_ARREADY,\ninput  logic [31:0] M_AXI_RDATA, input  logic [1:0]  M_AXI_RRESP, input  logic        M_AXI_RVALID, output logic        M_AXI_RREADY ); ",
    "answer_0": "Here's a complete SystemVerilog implementation of an AXI4-Lite Master Interface:\n\n```systemverilog\nmodule AXI4_Lite_Master(\n    input  logic        clk,          // System clock\n    input  logic        rst,          // Asynchronous reset\n    input  logic        AXI_Start,    // Start a new AXI transaction\n    input  logic        AXI_WriteEn,  // 1 for write, 0 for read\n    input  logic [31:0] AXI_Addr,     // Address for transaction\n    input  logic [31:0] AXI_WData,    // Data to write\n    output logic [31:0] AXI_RData,    // Data read from slave\n    output logic        AXI_Done,     // Transaction complete\n    \n    // AXI4-Lite Write Address Channel\n    output logic [31:0] M_AXI_AWADDR,\n    output logic        M_AXI_AWVALID,\n    input  logic        M_AXI_AWREADY,\n    \n    // AXI4-Lite Write Data Channel\n    output logic [31:0] M_AXI_WDATA,\n    output logic [3:0]  M_AXI_WSTRB,\n    output logic        M_AXI_WVALID,\n    input  logic        M_AXI_WREADY,\n    \n    // AXI4-Lite Write Response Channel\n    input  logic [1:0]  M_AXI_BRESP,\n    input  logic        M_AXI_BVALID,\n    output logic        M_AXI_BREADY,\n    \n    // AXI4-Lite Read Address Channel\n    output logic [31:0] M_AXI_ARADDR,\n    output logic        M_AXI_ARVALID,\n    input  logic        M_AXI_ARREADY,\n    \n    // AXI4-Lite Read Data Channel\n    input  logic [31:0] M_AXI_RDATA,\n    input  logic [1:0]  M_AXI_RRESP,\n    input  logic        M_AXI_RVALID,\n    output logic        M_AXI_RREADY\n);\n\n    // State machine definitions\n    typedef enum logic [3:0] {\n        IDLE        = 4'b0000,\n        WRITE_ADDR  = 4'b0001,\n        WRITE_DATA  = 4'b0010,\n        WRITE_RESP  = 4'b0011,\n        READ_ADDR   = 4'b0100,\n        READ_DATA   = 4'b0101,\n        DONE        = 4'b0110\n    } state_t;\n    \n    state_t current_state, next_state;\n    \n    // Internal registers\n    logic [31:0] addr_reg;\n    logic [31:0] wdata_reg;\n    logic [31:0] rdata_reg;\n    logic        write_en_reg;\n    \n    // AXI4-Lite response codes\n    localparam [1:0] OKAY   = 2'b00;\n    localparam [1:0] EXOKAY = 2'b01;\n    localparam [1:0] SLVERR = 2'b10;\n    localparam [1:0] DECERR = 2'b11;\n    \n    // Sequential logic for state machine\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n    \n    // Input register capture\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            addr_reg     <= 32'h0;\n            wdata_reg    <= 32'h0;\n            write_en_reg <= 1'b0;\n        end else if (current_state == IDLE && AXI_Start) begin\n            addr_reg     <= AXI_Addr;\n            wdata_reg    <= AXI_WData;\n            write_en_reg <= AXI_WriteEn;\n        end\n    end\n    \n    // Read data capture\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rdata_reg <= 32'h0;\n        end else if (current_state == READ_DATA && M_AXI_RVALID && M_AXI_RREADY) begin\n            rdata_reg <= M_AXI_RDATA;\n        end\n    end\n    \n    // Combinational logic for state transitions\n    always_comb begin\n        next_state = current_state;\n        \n        case (current_state)\n            IDLE: begin\n                if (AXI_Start) begin\n                    if (AXI_WriteEn) begin\n                        next_state = WRITE_ADDR;\n                    end else begin\n                        next_state = READ_ADDR;\n                    end\n                end\n            end\n            \n            WRITE_ADDR: begin\n                if (M_AXI_AWVALID && M_AXI_AWREADY) begin\n                    next_state = WRITE_DATA;\n                end\n            end\n            \n            WRITE_DATA: begin\n                if (M_AXI_WVALID && M_AXI_WREADY) begin\n                    next_state = WRITE_RESP;\n                end\n            end\n            \n            WRITE_RESP: begin\n                if (M_AXI_BVALID && M_AXI_BREADY) begin\n                    next_state = DONE;\n                end\n            end\n            \n            READ_ADDR: begin\n                if (M_AXI_ARVALID && M_AXI_ARREADY) begin\n                    next_state = READ_DATA;\n                end\n            end\n            \n            READ_DATA: begin\n                if (M_AXI_RVALID && M_AXI_RREADY) begin\n                    next_state = DONE;\n                end\n            end\n            \n            DONE: begin\n                next_state = IDLE;\n            end\n            \n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n    \n    // AXI4-Lite Write Address Channel\n    always_comb begin\n        M_AXI_AWADDR  = addr_reg;\n        M_AXI_AWVALID = (current_state == WRITE_ADDR);\n    end\n    \n    // AXI4-Lite Write Data Channel\n    always_comb begin\n        M_AXI_WDATA  = wdata_reg;\n        M_AXI_WSTRB  = 4'hF;  // All bytes valid for 32-bit transactions\n        M_AXI_WVALID = (current_state == WRITE_DATA);\n    end\n    \n    // AXI4-Lite Write Response Channel\n    always_comb begin\n        M_AXI_BREADY = (current_state == WRITE_RESP);\n    end\n    \n    // AXI4-Lite Read Address Channel\n    always_comb begin\n        M_AXI_ARADDR  = addr_reg;\n        M_AXI_ARVALID = (current_state == READ_ADDR);\n    end\n    \n    // AXI4-Lite Read Data Channel\n    always_comb begin\n        M_AXI_RREADY = (current_state == READ_DATA);\n    end\n    \n    // Output assignments\n    always_comb begin\n        AXI_RData = rdata_reg;\n        AXI_Done  = (current_state == DONE);\n    end\n    \n    // Optional: Error handling and response checking\n    // This can be extended based on specific requirements\n    logic error_flag;\n    \n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            error_flag <= 1'b0;\n        end else begin\n            // Check for error responses\n            if ((current_state == WRITE_RESP && M_AXI_BVALID && M_AXI_BREADY) ||\n                (current_state == READ_DATA && M_AXI_RVALID && M_AXI_RREADY)) begin\n                if (write_en_reg) begin\n                    error_flag <= (M_AXI_BRESP != OKAY);\n                end else begin\n                    error_flag <= (M_AXI_RRESP != OKAY);\n                end\n            end else if (current_state == IDLE) begin\n                error_flag <= 1'b0;\n            end\n        end\n    end\n    \n    // Optional: Timeout counter to prevent hanging\n    logic [15:0] timeout_counter;\n    localparam TIMEOUT_LIMIT = 16'hFFFF;\n    \n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            timeout_counter <= 16'h0;\n        end else if (current_state == IDLE) begin\n            timeout_counter <= 16'h0;\n        end else if (current_state != DONE) begin\n            timeout_counter <= timeout_counter + 1'b1;\n        end\n    end\n    \n    // Timeout error detection\n    logic timeout_error;\n    assign timeout_error = (timeout_counter >= TIMEOUT_LIMIT);\n\nendmodule\n```\n\n## Key Features of this AXI4-Lite Master:\n\n1. **State Machine**: Implements a clean state machine with separate states for each phase of read/write transactions.\n\n2. **Proper Handshaking**: Ensures correct AXI4-Lite handshaking with VALID/READY signals.\n\n3. **Write Transaction Flow**:\n   - WRITE_ADDR: Send address and wait for AWREADY\n   - WRITE_DATA: Send data and wait for WREADY\n   - WRITE_RESP: Wait for write response (BVALID)\n\n4. **Read Transaction Flow**:\n   - READ_ADDR: Send address and wait for ARREADY\n   - READ_DATA: Wait for read data (RVALID)\n\n5. **Input Capture**: Registers input signals when transaction starts to maintain stability.\n\n6. **Error Handling**: Includes error flag for response checking and timeout detection.\n\n7. **Full AXI4-Lite Compliance**: Implements all required AXI4-Lite channels with proper signal assignments.\n\n## Usage Example:\n\n```systemverilog\n// To perform a write transaction:\nAXI_Start = 1'b1;\nAXI_WriteEn = 1'b1;\nAXI_Addr = 32'h1000_0004;\nAXI_WData = 32'hDEAD_BEEF;\n// Wait for AXI_Done to go high\n\n// To perform a read transaction:\nAXI_Start = 1'b1;\nAXI_WriteEn = 1'b0;\nAXI_Addr = 32'h1000_0008;\n// Wait for AXI_Done, then read AXI_RData\n```\n\nThis implementation provides a robust, reusable AXI4-Lite master interface that can be integrated into larger SoC designs."
}
