{
    "prompt_0": " Write a SystemVerilog module to implement an AXI4-Lite Master Interface. The module should handle read and write transactions, generate appropriate AXI signals, and ensure proper handshaking with the AXI slave. The design should follow the AXI4-Lite protocol and include the following interface:\n\nmodule AXI4_Lite_Master( input  logic        clk,          // System clock input  logic        rst,          // Asynchronous reset input  logic        AXI_Start,    // Start a new AXI transaction input  logic        AXI_WriteEn,  // 1 for write, 0 for read input  logic [31:0] AXI_Addr,     // Address for transaction input  logic [31:0] AXI_WData,    // Data to write output logic [31:0] AXI_RData,    // Data read from slave output logic        AXI_Done,     // Transaction complete\n// AXI4-Lite signals output logic [31:0] M_AXI_AWADDR, output logic        M_AXI_AWVALID, input  logic        M_AXI_AWREADY,\noutput logic [31:0] M_AXI_WDATA, output logic [3:0]  M_AXI_WSTRB, output logic        M_AXI_WVALID, input  logic        M_AXI_WREADY,\ninput  logic [1:0]  M_AXI_BRESP, input  logic        M_AXI_BVALID, output logic        M_AXI_BREADY,\noutput logic [31:0] M_AXI_ARADDR, output logic        M_AXI_ARVALID, input  logic        M_AXI_ARREADY,\ninput  logic [31:0] M_AXI_RDATA, input  logic [1:0]  M_AXI_RRESP, input  logic        M_AXI_RVALID, output logic        M_AXI_RREADY ); ",
    "answer_0": "```systemverilog\n//--------------------------------------------------------------------\n// Simple single-beat AXI4-Lite Master\n//--------------------------------------------------------------------\nmodule AXI4_Lite_Master\n#(\n    parameter ADDR_WIDTH = 32 ,\n    parameter DATA_WIDTH = 32\n)\n(\n    input  logic                       clk,           // system clock\n    input  logic                       rst,           // asynchronous, active-high reset\n\n    // User side\n    input  logic                       AXI_Start,     // pulse => start new transaction\n    input  logic                       AXI_WriteEn,   // 1 = write, 0 = read\n    input  logic  [ADDR_WIDTH-1:0]     AXI_Addr,      // target address\n    input  logic  [DATA_WIDTH-1:0]     AXI_WData,     // write data\n    output logic  [DATA_WIDTH-1:0]     AXI_RData,     // read data\n    output logic                       AXI_Done,      // pulse => transaction complete\n\n    // AXI4-Lite (master) interface\n    output logic [ADDR_WIDTH-1:0]      M_AXI_AWADDR,\n    output logic                       M_AXI_AWVALID,\n    input  logic                       M_AXI_AWREADY,\n\n    output logic [DATA_WIDTH-1:0]      M_AXI_WDATA,\n    output logic [3:0]                 M_AXI_WSTRB,\n    output logic                       M_AXI_WVALID,\n    input  logic                       M_AXI_WREADY,\n\n    input  logic [1:0]                 M_AXI_BRESP,\n    input  logic                       M_AXI_BVALID,\n    output logic                       M_AXI_BREADY,\n\n    output logic [ADDR_WIDTH-1:0]      M_AXI_ARADDR,\n    output logic                       M_AXI_ARVALID,\n    input  logic                       M_AXI_ARREADY,\n\n    input  logic [DATA_WIDTH-1:0]      M_AXI_RDATA,\n    input  logic [1:0]                 M_AXI_RRESP,\n    input  logic                       M_AXI_RVALID,\n    output logic                       M_AXI_RREADY\n);\n\n//====================================================================\n// Local signals / registers\n//====================================================================\ntypedef enum logic [2:0] {\n    ST_IDLE        = 3'd0,\n    ST_WR_ADDRDATA = 3'd1,\n    ST_WR_RESP     = 3'd2,\n    ST_RD_ADDR     = 3'd3,\n    ST_RD_DATA     = 3'd4\n} state_t;\n\nstate_t                state , nxt_state;\nlogic [ADDR_WIDTH-1:0] addr_reg;\nlogic [DATA_WIDTH-1:0] wdata_reg;\nlogic                  write_en_reg;\n\n//--------------------------------------------------------------------\n// Sequential part\n//--------------------------------------------------------------------\nalways_ff @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state        <= ST_IDLE;\n        addr_reg     <= '0;\n        wdata_reg    <= '0;\n        write_en_reg <= 1'b0;\n    end\n    else begin\n        state <= nxt_state;\n\n        // latch command at start\n        if (state == ST_IDLE && AXI_Start) begin\n            addr_reg     <= AXI_Addr;\n            wdata_reg    <= AXI_WData;\n            write_en_reg <= AXI_WriteEn;\n        end\n    end\nend\n\n//--------------------------------------------------------------------\n// Next-state logic\n//--------------------------------------------------------------------\nalways_comb begin\n    nxt_state = state;\n\n    unique case (state)\n        ST_IDLE : begin\n            if (AXI_Start) begin\n                if (AXI_WriteEn) nxt_state = ST_WR_ADDRDATA;\n                else             nxt_state = ST_RD_ADDR;\n            end\n        end\n\n        // -------------- WRITE TRANSACTION --------------------------\n        ST_WR_ADDRDATA : begin\n            if (M_AXI_AWREADY && M_AXI_WREADY)       // address & data both accepted\n                nxt_state = ST_WR_RESP;\n        end\n        ST_WR_RESP : begin\n            if (M_AXI_BVALID)                        // response received\n                nxt_state = ST_IDLE;\n        end\n\n        // -------------- READ TRANSACTION ---------------------------\n        ST_RD_ADDR : begin\n            if (M_AXI_ARREADY)                       // address accepted\n                nxt_state = ST_RD_DATA;\n        end\n        ST_RD_DATA : begin\n            if (M_AXI_RVALID)                        // data received\n                nxt_state = ST_IDLE;\n        end\n\n        default : nxt_state = ST_IDLE;\n    endcase\nend\n\n//--------------------------------------------------------------------\n// AXI channel controls\n//--------------------------------------------------------------------\n\n// ---------- default assignments ----------\nassign M_AXI_WSTRB = 4'hF;           // always writing full 32-bit word\n\n// Write address channel\nassign M_AXI_AWADDR  = addr_reg;\nassign M_AXI_AWVALID = (state == ST_WR_ADDRDATA);\n\n// Write data channel\nassign M_AXI_WDATA   = wdata_reg;\nassign M_AXI_WVALID  = (state == ST_WR_ADDRDATA);\n\n// Write response channel\nassign M_AXI_BREADY  = (state == ST_WR_RESP);  // assert while waiting\n\n// Read address channel\nassign M_AXI_ARADDR  = addr_reg;\nassign M_AXI_ARVALID = (state == ST_RD_ADDR);\n\n// Read data channel\nassign M_AXI_RREADY  = (state == ST_RD_DATA);\n\n//--------------------------------------------------------------------\n// Output data / done flag\n//--------------------------------------------------------------------\nalways_ff @(posedge clk or posedge rst) begin\n    if (rst)\n        AXI_RData <= '0;\n    else if (state == ST_RD_DATA && M_AXI_RVALID && M_AXI_RREADY)\n        AXI_RData <= M_AXI_RDATA;\nend\n\n// Done pulse: one clock when transaction finishes\nlogic done_reg;\nalways_ff @(posedge clk or posedge rst) begin\n    if (rst)\n        done_reg <= 1'b0;\n    else\n        done_reg <= ( (state == ST_WR_RESP && M_AXI_BVALID) ||\n                      (state == ST_RD_DATA && M_AXI_RVALID) );\nend\nassign AXI_Done = done_reg;\n\nendmodule\n```"
}
