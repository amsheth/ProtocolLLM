{
    "prompt_0": " Write a SystemVerilog module to implement an AXI4-Lite Master Interface. The module should handle read and write transactions, generate appropriate AXI signals, and ensure proper handshaking with the AXI slave. The design should follow the AXI4-Lite protocol and include the following interface:\n\nmodule AXI4_Lite_Master( input  logic        clk,          // System clock input  logic        rst,          // Asynchronous reset input  logic        AXI_Start,    // Start a new AXI transaction input  logic        AXI_WriteEn,  // 1 for write, 0 for read input  logic [31:0] AXI_Addr,     // Address for transaction input  logic [31:0] AXI_WData,    // Data to write output logic [31:0] AXI_RData,    // Data read from slave output logic        AXI_Done,     // Transaction complete\n// AXI4-Lite signals output logic [31:0] M_AXI_AWADDR, output logic        M_AXI_AWVALID, input  logic        M_AXI_AWREADY,\noutput logic [31:0] M_AXI_WDATA, output logic [3:0]  M_AXI_WSTRB, output logic        M_AXI_WVALID, input  logic        M_AXI_WREADY,\ninput  logic [1:0]  M_AXI_BRESP, input  logic        M_AXI_BVALID, output logic        M_AXI_BREADY,\noutput logic [31:0] M_AXI_ARADDR, output logic        M_AXI_ARVALID, input  logic        M_AXI_ARREADY,\ninput  logic [31:0] M_AXI_RDATA, input  logic [1:0]  M_AXI_RRESP, input  logic        M_AXI_RVALID, output logic        M_AXI_RREADY ); ",
    "answer_0": "```systemverilog\nmodule AXI4_Lite_Master(\n    input  logic        clk,          // System clock\n    input  logic        rst,          // Asynchronous reset\n    input  logic        AXI_Start,    // Start a new AXI transaction\n    input  logic        AXI_WriteEn,  // 1 for write, 0 for read\n    input  logic [31:0] AXI_Addr,     // Address for transaction\n    input  logic [31:0] AXI_WData,    // Data to write\n    output logic [31:0] AXI_RData,    // Data read from slave\n    output logic        AXI_Done,     // Transaction complete\n\n    // AXI4-Lite signals\n    output logic [31:0] M_AXI_AWADDR,\n    output logic        M_AXI_AWVALID,\n    input  logic        M_AXI_AWREADY,\n    output logic [31:0] M_AXI_WDATA,\n    output logic [3:0]  M_AXI_WSTRB,\n    output logic        M_AXI_WVALID,\n    input  logic        M_AXI_WREADY,\n    input  logic [1:0]  M_AXI_BRESP,\n    input  logic        M_AXI_BVALID,\n    output logic        M_AXI_BREADY,\n    output logic [31:0] M_AXI_ARADDR,\n    output logic        M_AXI_ARVALID,\n    input  logic        M_AXI_ARREADY,\n    input  logic [31:0] M_AXI_RDATA,\n    input  logic [1:0]  M_AXI_RRESP,\n    input  logic        M_AXI_RVALID,\n    output logic        M_AXI_RREADY\n);\n\n    // State definitions\n    typedef enum logic [1:0] {IDLE, AW, W, B, AR, R} state_t;\n    state_t state, next_state;\n\n    // Internal signals\n    logic [31:0] awaddr_reg;\n    logic [31:0] awdata_reg;\n    logic [3:0]  awstrb_reg;\n    logic        awvalid_reg;\n    logic        wvalid_reg;\n    logic        bready_reg;\n    logic        arvalid_reg;\n    logic        rready_reg;\n    logic        done_reg;\n\n    // State transition logic\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // State machine logic\n    always_comb begin\n        next_state = state;\n        awaddr_reg = awaddr_reg;\n        awdata_reg = awdata_reg;\n        awstrb_reg = awstrb_reg;\n        awvalid_reg = awvalid_reg;\n        wvalid_reg = wvalid_reg;\n        bready_reg = bready_reg;\n        arvalid_reg = arvalid_reg;\n        rready_reg = rready_reg;\n        done_reg = done_reg;\n\n        case (state)\n            IDLE: begin\n                if (AXI_Start) begin\n                    if (AXI_WriteEn) begin\n                        next_state = AW;\n                        awaddr_reg = AXI_Addr;\n                        awdata_reg = AXI_WData;\n                        awstrb_reg = 4'b1111;\n                        awvalid_reg = 1'b1;\n                    end else begin\n                        next_state = AR;\n                        awaddr_reg = AXI_Addr;\n                        arvalid_reg = 1'b1;\n                    end\n                end\n            end\n            AW: begin\n                if (M_AXI_AWREADY) begin\n                    next_state = W;\n                    awvalid_reg = 1'b0;\n                end\n            end\n            W: begin\n                if (M_AXI_WREADY) begin\n                    next_state = B;\n                    wvalid_reg = 1'b0;\n                end\n            end\n            B: begin\n                if (M_AXI_BVALID) begin\n                    next_state = IDLE;\n                    bready_reg = 1'b1;\n                    done_reg = 1'b1;\n                end\n            end\n            AR: begin\n                if (M_AXI_ARREADY) begin\n                    next_state = R;\n                    arvalid_reg = 1'b0;\n                end\n            end\n            R: begin\n                if (M_AXI_RVALID) begin\n                    next_state = IDLE;\n                    rready_reg = 1'b1;\n                    AXI_RData = M_AXI_RDATA;\n                    done_reg = 1'b1;\n                end\n            end\n        endcase\n    end\n\n    // Output logic\n    assign M_AXI_AWADDR = awaddr_reg;\n    assign M_AXI_AWVALID = awvalid_reg;\n    assign M_AXI_WDATA = awdata_reg;\n    assign M_AXI_WSTRB = awstrb_reg;\n    assign M_AXI_WVALID = wvalid_reg;\n    assign M_AXI_BREADY = bready_reg;\n    assign M_AXI_ARADDR = awaddr_reg;\n    assign M_AXI_ARVALID = arvalid_reg;\n    assign M_AXI_RREADY = rready_reg;\n\n    // Done signal\n    assign AXI_Done = done_reg;\n\nendmodule\n```\n\nThis SystemVerilog module implements an AXI4-Lite Master Interface. It handles read and write transactions, generates appropriate AXI signals, and ensures proper handshaking with the AXI slave. The design follows the AXI4-Lite protocol and includes the specified interface. The state machine manages the transaction states, and the output logic drives the AXI signals based on the current state and inputs."
}
