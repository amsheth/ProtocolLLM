{
    "prompt_0": " Write a SystemVerilog module to implement an AXI4-Lite Master Interface. The module should handle read and write transactions, generate appropriate AXI signals, and ensure proper handshaking with the AXI slave. The design should follow the AXI4-Lite protocol and include the following interface:\n\nmodule AXI4_Lite_Master( input  logic        clk,          // System clock input  logic        rst,          // Asynchronous reset input  logic        AXI_Start,    // Start a new AXI transaction input  logic        AXI_WriteEn,  // 1 for write, 0 for read input  logic [31:0] AXI_Addr,     // Address for transaction input  logic [31:0] AXI_WData,    // Data to write output logic [31:0] AXI_RData,    // Data read from slave output logic        AXI_Done,     // Transaction complete\n// AXI4-Lite signals output logic [31:0] M_AXI_AWADDR, output logic        M_AXI_AWVALID, input  logic        M_AXI_AWREADY,\noutput logic [31:0] M_AXI_WDATA, output logic [3:0]  M_AXI_WSTRB, output logic        M_AXI_WVALID, input  logic        M_AXI_WREADY,\ninput  logic [1:0]  M_AXI_BRESP, input  logic        M_AXI_BVALID, output logic        M_AXI_BREADY,\noutput logic [31:0] M_AXI_ARADDR, output logic        M_AXI_ARVALID, input  logic        M_AXI_ARREADY,\ninput  logic [31:0] M_AXI_RDATA, input  logic [1:0]  M_AXI_RRESP, input  logic        M_AXI_RVALID, output logic        M_AXI_RREADY ); ",
    "answer_0": "```systemverilog\nmodule AXI4_Lite_Master(\n    input  logic         clk,          \n    input  logic         rst,          \n    input  logic         AXI_Start,    \n    input  logic         AXI_WriteEn,  \n    input  logic [31:0]  AXI_Addr,     \n    input  logic [31:0]  AXI_WData,    \n    output logic [31:0]  AXI_RData,    \n    output logic         AXI_Done,    \n\n    // AXI4-Lite signals\n    output logic [31:0]  M_AXI_AWADDR,\n    output logic         M_AXI_AWVALID,\n    input  logic         M_AXI_AWREADY,\n\n    output logic [31:0]  M_AXI_WDATA,\n    output logic [3:0]   M_AXI_WSTRB,\n    output logic         M_AXI_WVALID,\n    input  logic         M_AXI_WREADY,\n\n    input  logic [1:0]   M_AXI_BRESP,\n    input  logic         M_AXI_BVALID,\n    output logic         M_AXI_BREADY,\n\n    output logic [31:0]  M_AXI_ARADDR,\n    output logic         M_AXI_ARVALID,\n    input  logic         M_AXI_ARREADY,\n\n    input  logic [31:0]  M_AXI_RDATA,\n    input  logic [1:0]   M_AXI_RRESP,\n    input  logic         M_AXI_RVALID,\n    output logic         M_AXI_RREADY\n);\n\n    typedef enum logic [2:0] {\n        IDLE,\n        WRITE_ADDR,\n        WRITE_DATA,\n        WRITE_RESP,\n        READ_ADDR,\n        READ_DATA\n    } state_t;\n\n    state_t state, next_state;\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always_comb begin\n        // Default values\n        M_AXI_AWADDR  = 32'd0;\n        M_AXI_AWVALID = 1'b0;\n        M_AXI_WDATA   = 32'd0;\n        M_AXI_WSTRB   = 4'b0000;\n        M_AXI_WVALID  = 1'b0;\n        M_AXI_BREADY  = 1'b0;\n        M_AXI_ARADDR  = 32'd0;\n        M_AXI_ARVALID = 1'b0;\n        M_AXI_RREADY  = 1'b0;\n        AXI_RData     = 32'd0;\n        AXI_Done      = 1'b0;\n        \n        next_state = state;\n        \n        case (state)\n            IDLE: begin\n                if (AXI_Start) begin\n                    if (AXI_WriteEn) begin\n                        next_state = WRITE_ADDR;\n                    end else begin\n                        next_state = READ_ADDR;\n                    end\n                end\n            end\n\n            WRITE_ADDR: begin\n                M_AXI_AWADDR  = AXI_Addr;\n                M_AXI_AWVALID = 1'b1;\n                if (M_AXI_AWREADY) begin\n                    next_state = WRITE_DATA;\n                end\n            end\n\n            WRITE_DATA: begin\n                M_AXI_WDATA  = AXI_WData;\n                M_AXI_WSTRB  = 4'b1111;\n                M_AXI_WVALID = 1'b1;\n                if (M_AXI_WREADY) begin\n                    next_state = WRITE_RESP;\n                end\n            end\n\n            WRITE_RESP: begin\n                M_AXI_BREADY = 1'b1;\n                if (M_AXI_BVALID) begin\n                    AXI_Done = 1'b1;\n                    next_state = IDLE;\n                end\n            end\n\n            READ_ADDR: begin\n                M_AXI_ARADDR  = AXI_Addr;\n                M_AXI_ARVALID = 1'b1;\n                if (M_AXI_ARREADY) begin\n                    next_state = READ_DATA;\n                end\n            end\n\n            READ_DATA: begin\n                M_AXI_RREADY = 1'b1;\n                if (M_AXI_RVALID) begin\n                    AXI_RData = M_AXI_RDATA;\n                    AXI_Done  = 1'b1;\n                    next_state = IDLE;\n                end\n            end\n            \n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\nendmodule\n```"
}
