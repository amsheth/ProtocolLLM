{
    "prompt_0": " Write a SystemVerilog module to implement an AXI4-Lite Master Interface. The module should handle read and write transactions, generate appropriate AXI signals, and ensure proper handshaking with the AXI slave. The design should follow the AXI4-Lite protocol and include the following interface:\n\nmodule AXI4_Lite_Master( input  logic        clk,          // System clock input  logic        rst,          // Asynchronous reset input  logic        AXI_Start,    // Start a new AXI transaction input  logic        AXI_WriteEn,  // 1 for write, 0 for read input  logic [31:0] AXI_Addr,     // Address for transaction input  logic [31:0] AXI_WData,    // Data to write output logic [31:0] AXI_RData,    // Data read from slave output logic        AXI_Done,     // Transaction complete\n// AXI4-Lite signals output logic [31:0] M_AXI_AWADDR, output logic        M_AXI_AWVALID, input  logic        M_AXI_AWREADY,\noutput logic [31:0] M_AXI_WDATA, output logic [3:0]  M_AXI_WSTRB, output logic        M_AXI_WVALID, input  logic        M_AXI_WREADY,\ninput  logic [1:0]  M_AXI_BRESP, input  logic        M_AXI_BVALID, output logic        M_AXI_BREADY,\noutput logic [31:0] M_AXI_ARADDR, output logic        M_AXI_ARVALID, input  logic        M_AXI_ARREADY,\ninput  logic [31:0] M_AXI_RDATA, input  logic [1:0]  M_AXI_RRESP, input  logic        M_AXI_RVALID, output logic        M_AXI_RREADY ); ",
    "answer_0": "Here's a SystemVerilog module implementing an AXI4-Lite Master Interface. This design uses a state machine to manage the AXI4-Lite read and write transactions, ensuring proper handshaking and signal generation.\n\nThe module follows a common FSM design pattern:\n1.  **State Register (`current_state`):** Updated on the positive edge of the clock or asynchronous reset.\n2.  **Next State Logic (`next_state`):** Combinational logic determining the next state based on the current state and inputs.\n3.  **Output Registers:** All AXI output signals and user-facing outputs (`AXI_RData`, `AXI_Done`) are registered.\n4.  **Next Output Logic:** Combinational logic determining the next values for the output registers based on the current state and inputs.\n\n\n```systemverilog\nmodule AXI4_Lite_Master(\n    input  logic        clk,          // System clock\n    input  logic        rst,          // Asynchronous reset (active high)\n    input  logic        AXI_Start,    // Start a new AXI transaction (pulse high for one cycle)\n    input  logic        AXI_WriteEn,  // 1 for write, 0 for read\n    input  logic [31:0] AXI_Addr,     // Address for transaction\n    input  logic [31:0] AXI_WData,    // Data to write\n    output logic [31:0] AXI_RData,    // Data read from slave\n    output logic        AXI_Done,     // Transaction complete (pulsed high for one cycle)\n\n    // AXI4-Lite signals (Master outputs, Slave inputs)\n    output logic [31:0] M_AXI_AWADDR,  // Write address\n    output logic        M_AXI_AWVALID, // Write address valid\n    input  logic        M_AXI_AWREADY, // Write address ready\n\n    output logic [31:0] M_AXI_WDATA,   // Write data\n    output logic [3:0]  M_AXI_WSTRB,   // Write strobe (byte enables)\n    output logic        M_AXI_WVALID,  // Write data valid\n    input  logic        M_AXI_WREADY,  // Write data ready\n\n    input  logic [1:0]  M_AXI_BRESP,   // Write response\n    input  logic        M_AXI_BVALID,  // Write response valid\n    output logic        M_AXI_BREADY,  // Write response ready\n\n    output logic [31:0] M_AXI_ARADDR,  // Read address\n    output logic        M_AXI_ARVALID, // Read address valid\n    input  logic        M_AXI_ARREADY, // Read address ready\n\n    input  logic [31:0] M_AXI_RDATA,   // Read data\n    input  logic [1:0]  M_AXI_RRESP,   // Read response\n    input  logic        M_AXI_RVALID,  // Read data valid\n    output logic        M_AXI_RREADY   // Read data ready\n);\n\n    // State machine definition\n    typedef enum logic [2:0] {\n        IDLE,        // Waiting for a new transaction request\n        AW_PHASE,    // Sending write address\n        W_PHASE,     // Sending write data\n        B_PHASE,     // Waiting for write response\n        AR_PHASE,    // Sending read address\n        R_PHASE,     // Waiting for read data\n        DONE_PHASE   // Transaction completed, assert AXI_Done\n    } master_state_e;\n\n    master_state_e current_state, next_state;\n\n    // Internal signals for the next values of registered outputs\n    // These are calculated in the always_comb block and assigned to registers in always_ff\n    logic [31:0] M_AXI_AWADDR_next;\n    logic        M_AXI_AWVALID_next;\n    logic [31:0] M_AXI_WDATA_next;\n    logic [3:0]  M_AXI_WSTRB_next;\n    logic        M_AXI_WVALID_next;\n    logic        M_AXI_BREADY_next;\n    logic [31:0] M_AXI_ARADDR_next;\n    logic        M_AXI_ARVALID_next;\n    logic        M_AXI_RREADY_next;\n    logic [31:0] AXI_RData_next;\n    logic        AXI_Done_next;\n\n    // State and Output Registers\n    // All outputs are registered to ensure stable signals and meet timing requirements.\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_state <= IDLE;\n            M_AXI_AWADDR  <= 32'b0;\n            M_AXI_AWVALID <= 1'b0;\n            M_AXI_WDATA   <= 32'b0;\n            M_AXI_WSTRB   <= 4'b0;\n            M_AXI_WVALID  <= 1'b0;\n            M_AXI_BREADY  <= 1'b0;\n            M_AXI_ARADDR  <= 32'b0;\n            M_AXI_ARVALID <= 1'b0;\n            M_AXI_RREADY  <= 1'b0;\n            AXI_RData     <= 32'b0;\n            AXI_Done      <= 1'b0;\n        end else begin\n            current_state <= next_state;\n            M_AXI_AWADDR  <= M_AXI_AWADDR_next;\n            M_AXI_AWVALID <= M_AXI_AWVALID_next;\n            M_AXI_WDATA   <= M_AXI_WDATA_next;\n            M_AXI_WSTRB   <= M_AXI_WSTRB_next;\n            M_AXI_WVALID  <= M_AXI_WVALID_next;\n            M_AXI_BREADY  <= M_AXI_BREADY_next;\n            M_AXI_ARADDR  <= M_AXI_ARADDR_next;\n            M_AXI_ARVALID <= M_AXI_ARVALID_next;\n            M_AXI_RREADY  <= M_AXI_RREADY_next;\n            AXI_RData     <= AXI_RData_next;\n            AXI_Done      <= AXI_Done_next;\n        end\n    end\n\n    // Combinational logic for next_state and next values of outputs\n    always_comb begin\n        // Default assignments for next cycle (most signals are de-asserted or hold their value)\n        next_state = current_state;\n\n        M_AXI_AWADDR_next  = M_AXI_AWADDR;  // Hold current address unless updated\n        M_AXI_AWVALID_next = 1'b0;          // Default to de-asserted\n        M_AXI_WDATA_next   = M_AXI_WDATA;   // Hold current data unless updated\n        M_AXI_WSTRB_next   = M_AXI_WSTRB;   // Hold current strobe unless updated\n        M_AXI_WVALID_next  = 1'b0;          // Default to de-asserted\n        M_AXI_BREADY_next  = 1'b0;          // Default to de-asserted\n        M_AXI_ARADDR_next  = M_AXI_ARADDR;  // Hold current address unless updated\n        M_AXI_ARVALID_next = 1'b0;          // Default to de-asserted\n        M_AXI_RREADY_next  = 1'b0;          // Default to de-asserted\n        AXI_RData_next     = AXI_RData;     // Hold last read data\n        AXI_Done_next      = 1'b0;          // Pulsed signal, default to 0\n\n        case (current_state)\n            IDLE: begin\n                if (AXI_Start) begin\n                    if (AXI_WriteEn) begin\n                        next_state = AW_PHASE;\n                        M_AXI_AWADDR_next = AXI_Addr;\n                        M_AXI_WDATA_next  = AXI_WData;\n                        M_AXI_WSTRB_next  = 4'hF; // Full 32-bit write\n                    end else begin\n                        next_state = AR_PHASE;\n                        M_AXI_ARADDR_next = AXI_Addr;\n                    end\n                end\n            end\n\n            AW_PHASE: begin\n                M_AXI_AWVALID_next = 1'b1; // Assert AWVALID\n                // AWADDR, WDATA, WSTRB are already set from IDLE, keep them stable\n                // M_AXI_AWADDR_next = AXI_Addr; // Redundant, but harmless if AXI_Addr is stable\n                // M_AXI_WDATA_next  = AXI_WData;\n                // M_AXI_WSTRB_next  = 4'hF;\n\n                if (M_AXI_AWREADY) begin // Handshake complete\n                    next_state = W_PHASE;\n                    M_AXI_AWVALID_next = 1'b0; // De-assert AWVALID for next cycle\n                end\n            end\n\n            W_PHASE: begin\n                M_AXI_WVALID_next = 1'b1; // Assert WVALID\n                // WDATA, WSTRB are already set, keep them stable\n                // M_AXI_WDATA_next  = AXI_WData;\n                // M_AXI_WSTRB_next  = 4'hF;\n\n                if (M_AXI_WREADY) begin // Handshake complete\n                    next_state = B_PHASE;\n                    M_AXI_WVALID_next = 1'b0; // De-assert WVALID for next cycle\n                end\n            end\n\n            B_PHASE: begin\n                M_AXI_BREADY_next = 1'b1; // Assert BREADY\n                if (M_AXI_BVALID) begin // Handshake complete\n                    next_state = DONE_PHASE;\n                    M_AXI_BREADY_next = 1'b0; // De-assert BREADY for next cycle\n                end\n            end\n\n            AR_PHASE: begin\n                M_AXI_ARVALID_next = 1'b1; // Assert ARVALID\n                // ARADDR is already set from IDLE, keep it stable\n                // M_AXI_ARADDR_next = AXI_Addr; // Redundant\n\n                if (M_AXI_ARREADY) begin // Handshake complete\n                    next_state = R_PHASE;\n                    M_AXI_ARVALID_next = 1'b0; // De-assert ARVALID for next cycle\n                end\n            end\n\n            R_PHASE: begin\n                M_AXI_RREADY_next = 1'b1; // Assert RREADY\n                if (M_AXI_RVALID) begin // Handshake complete\n                    next_state = DONE_PHASE;\n                    AXI_RData_next = M_AXI_RDATA; // Capture read data\n                    M_AXI_RREADY_next = 1'b0; // De-assert RREADY for next cycle\n                end\n            end\n\n            DONE_PHASE: begin\n                AXI_Done_next = 1'b1; // Assert AXI_Done for one cycle\n                next_state = IDLE;\n            end\n        endcase\n    end\n\nendmodule\n```"
}
