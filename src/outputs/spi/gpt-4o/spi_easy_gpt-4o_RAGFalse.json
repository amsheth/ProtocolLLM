{
    "prompt_0": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=1 and CPHA=1. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out );\n",
    "answer_0": "```systemverilog\nmodule SPI_driver(\n    input logic clk,\n    input logic rst,\n    input logic [7:0] data_in,\n    input logic SPI_MISO,\n    input logic SPI_start,\n    output logic SPI_MOSI,\n    output logic SPI_CLK,\n    output logic SPI_EN,\n    output logic [7:0] data_out\n);\n\n    // State encoding\n    typedef enum logic [1:0] {\n        IDLE    = 2'b00,\n        START   = 2'b01,\n        TRANSFER= 2'b10,\n        DONE    = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Register to hold data and counter\n    logic [7:0] shift_register;\n    logic [2:0] bit_counter;\n\n    // Generate SPI clock\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            SPI_CLK <= 1'b1; // CPOL = 1; Base level high\n        end else if (current_state == TRANSFER) begin\n            SPI_CLK <= ~SPI_CLK; // Toggle clock for each cycle\n        end else begin\n            SPI_CLK <= 1'b1;\n        end\n    end\n\n    // State machine\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always_comb begin\n        next_state = current_state;\n        case (current_state)\n            IDLE: begin\n                if (SPI_start) begin\n                    next_state = START;\n                end\n            end\n            START: begin\n                next_state = TRANSFER;\n            end\n            TRANSFER: begin\n                if (bit_counter == 3'b111) begin\n                    next_state = DONE;\n                end\n            end\n            DONE: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Output and counter logic\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            SPI_MOSI <= 1'b0;\n            SPI_EN <= 1'b0;\n            bit_counter <= 3'b0;\n            shift_register <= 8'b0;\n            data_out <= 8'b0;\n        end else begin\n            case (current_state)\n                IDLE: begin\n                    SPI_EN <= 1'b0;\n                end\n                START: begin\n                    SPI_EN <= 1'b1;\n                    shift_register <= data_in;\n                    bit_counter <= 3'b0;\n                end\n                TRANSFER: begin\n                    if (SPI_CLK == 1'b1) begin\n                        SPI_MOSI <= shift_register[7];\n                    end else begin\n                        shift_register <= {shift_register[6:0], SPI_MISO};\n                        bit_counter <= bit_counter + 1'b1;\n                    end\n                end\n                DONE: begin\n                    SPI_EN <= 1'b0;\n                    data_out <= shift_register;\n                end\n            endcase\n        end\n    end\n\nendmodule\n```",
    "prompt_1": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=1 and CPHA=0. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out );\n",
    "answer_1": "```systemverilog\nmodule SPI_driver(\n    input logic clk,\n    input logic rst,\n    input logic [7:0] data_in,\n    input logic SPI_MISO,\n    input logic SPI_start,\n    output logic SPI_MOSI,\n    output logic SPI_CLK,\n    output logic SPI_EN,\n    output logic [7:0] data_out\n);\n\n    typedef enum logic [1:0] {\n        IDLE = 2'b00,\n        SHIFT = 2'b01,\n        DONE = 2'b10\n    } state_t;\n\n    state_t current_state, next_state;\n    logic [7:0] shift_reg;\n    logic [2:0] bit_counter;\n\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_state <= IDLE;\n            SPI_CLK <= CPOL; // CPOL=1\n            SPI_EN <= 1'b0; // SPI_EN low, chip not selected\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    always_ff @(posedge clk) begin\n        // Generate SPI clock with CPHA=0 manner\n        if (!rst && current_state == SHIFT) begin\n            SPI_CLK <= ~SPI_CLK;\n        end\n    end\n\n    always_ff @(posedge clk) begin\n        if (rst) begin\n            SPI_MOSI <= 1'b0;\n            shift_reg <= 8'b0;\n            bit_counter <= 3'b0;\n            data_out <= 8'b0;\n        end else begin\n            case (current_state)\n                IDLE: begin\n                    if (SPI_start) begin\n                        shift_reg <= data_in;\n                        SPI_EN <= 1'b1; // Activate chip select\n                        bit_counter <= 3'd7;\n                        SPI_MOSI <= data_in[7];\n                    end\n                end\n                \n                SHIFT: begin\n                    if (SPI_CLK == ~CPOL) begin\n                        SPI_MOSI <= shift_reg[bit_counter];\n                        shift_reg <= {shift_reg[6:0], SPI_MISO};  // Shift in MISO bit\n                        if (bit_counter == 3'd0) begin\n                            data_out <= {shift_reg[6:0], SPI_MISO};\n                        end\n                    end\n                    bit_counter <= bit_counter - 1;\n                end\n\n                DONE: begin\n                    SPI_EN <= 1'b0; // Deactivate chip select\n                    SPI_CLK <= CPOL;\n                end\n\n                default: begin\n                    SPI_EN <= 1'b0; // Deactivate chip select\n                    SPI_CLK <= CPOL;\n                end\n            endcase\n        end\n    end\n\n    always_comb begin\n        next_state = current_state;\n        case (current_state)\n            IDLE: if (SPI_start) next_state = SHIFT;\n            SHIFT: if (bit_counter == 3'd0 && SPI_CLK == ~CPOL) next_state = DONE;\n            DONE: next_state = IDLE;\n        endcase\n    end\n\nendmodule\n```\n",
    "prompt_2": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=0 and CPHA=1. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out );\n",
    "answer_2": "```systemverilog\nmodule SPI_driver(\n    input logic clk,\n    input logic rst,\n    input logic [7:0] data_in,\n    input logic SPI_MISO,\n    input logic SPI_start,\n    output logic SPI_MOSI,\n    output logic SPI_CLK,\n    output logic SPI_EN,\n    output logic [7:0] data_out\n);\n    // Define parameters for SPI configuration\n    parameter CPOL = 0;\n    parameter CPHA = 1;\n    localparam IDLE = 0, TRANSFER = 1;\n    \n    // Internal registers and variables\n    logic [7:0] shift_reg;\n    logic [2:0] bit_counter;\n    logic state;\n\n    // Generate SPI clock with CPOL=0 and CPHA=1 configuration\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            SPI_CLK <= CPOL;\n        end else if (state == TRANSFER) begin\n            SPI_CLK <= ~SPI_CLK;\n        end else begin\n            SPI_CLK <= CPOL;\n        end\n    end\n\n    // State machine for SPI master driver\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            SPI_EN <= 1'b0;\n            bit_counter <= 3'd0;\n            shift_reg <= 8'b0;\n            data_out <= 8'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    SPI_EN <= 1'b0;\n                    if (SPI_start) begin\n                        state <= TRANSFER;\n                        SPI_EN <= 1'b1;\n                        shift_reg <= data_in;\n                        bit_counter <= 3'd7;\n                    end\n                end\n                \n                TRANSFER: begin\n                    if (SPI_CLK == CPHA) begin\n                        SPI_MOSI <= shift_reg[bit_counter];\n                        shift_reg <= {shift_reg[6:0], SPI_MISO};\n                        if (bit_counter == 0) begin\n                            state <= IDLE;\n                            SPI_EN <= 1'b0;\n                            data_out <= shift_reg;\n                        end else begin\n                            bit_counter <= bit_counter - 1;\n                        end\n                    end\n                end\n                \n                default: state <= IDLE;\n            endcase\n        end\n    end\n    \nendmodule\n```",
    "prompt_3": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=0 and CPHA=0. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out );\n",
    "answer_3": "```systemverilog\nmodule SPI_driver(\n    input logic clk,\n    input logic rst,\n    input logic [7:0] data_in,\n    input logic SPI_MISO,\n    input logic SPI_start,\n    output logic SPI_MOSI,\n    output logic SPI_CLK,\n    output logic SPI_EN,\n    output logic [7:0] data_out\n);\n    // Parameters for SPI Mode 0: CPOL=0, CPHA=0\n    parameter int CPOL = 0;\n    parameter int CPHA = 0;\n\n    // State Machine States\n    typedef enum logic [1:0] {\n        IDLE,\n        START,\n        TRANSFER,\n        DONE\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Data registers\n    logic [7:0] shift_reg;\n    logic [2:0] bit_counter; // Counter for 8 bits\n\n    // Clock generation for SPI (CPOL=0)\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            SPI_CLK <= CPOL;\n        end\n        else if (current_state == TRANSFER) begin\n            SPI_CLK <= ~SPI_CLK;\n        end\n        else begin\n            SPI_CLK <= CPOL;\n        end\n    end\n\n    // State Machine\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_state <= IDLE;\n        end\n        else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next State Logic\n    always_comb begin\n        next_state = current_state; // Default state remains the same\n        case (current_state)\n            IDLE: begin\n                SPI_EN = 1'b0;\n                if (SPI_start) begin\n                    next_state = START;\n                end\n            end\n            START: begin\n                SPI_EN = 1'b1;\n                next_state = TRANSFER;\n            end\n            TRANSFER: begin\n                SPI_EN = 1'b1;\n                if (bit_counter == 3'd7 && SPI_CLK == !CPOL) begin\n                    next_state = DONE;\n                end\n            end\n            DONE: begin\n                SPI_EN = 1'b0;\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Data handling and bit counter\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            shift_reg <= 8'b0;\n            bit_counter <= 3'd0;\n            SPI_MOSI <= 1'b0;\n            data_out <= 8'b0;\n        end\n        else begin\n            case (current_state)\n                IDLE: begin\n                    if (SPI_start) begin\n                        shift_reg <= data_in;\n                        bit_counter <= 3'd0;\n                    end\n                end\n                TRANSFER: begin\n                    if (SPI_CLK == !CPOL) begin\n                        SPI_MOSI <= shift_reg[7];\n                        shift_reg <= {shift_reg[6:0], SPI_MISO};\n                        bit_counter <= bit_counter + 3'd1;\n                    end\n                end\n                DONE: begin\n                    data_out <= shift_reg;\n                end\n            endcase\n        end\n    end\n\nendmodule\n```\n"
}
