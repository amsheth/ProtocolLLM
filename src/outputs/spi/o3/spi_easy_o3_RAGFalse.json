{
    "prompt_0": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=1 and CPHA=1. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out );\n",
    "answer_0": "```systemverilog\n//------------------------------------------------------------\n// SPI Master  \u2013  CPOL = 1, CPHA = 1  (MODE-3)\n// Simple, 8-bit, single-word transaction\n//------------------------------------------------------------\nmodule SPI_driver\n(\n    input  logic        clk,        // System clock\n    input  logic        rst,        // Active-high synchronous reset\n    input  logic [7:0]  data_in,    // Parallel byte to transmit\n    input  logic        SPI_MISO,   // Serial data from slave\n    input  logic        SPI_start,  // Pulse = start a transaction\n\n    output logic        SPI_MOSI,   // Serial data to slave\n    output logic        SPI_CLK,    // SPI clock  (idle = 1)\n    output logic        SPI_EN,     // Active-low chip-select\n    output logic [7:0]  data_out    // Parallel byte received\n);\n\n    // ---------------------------------------------------------\n    // User adjustable clock divider (system_clk -> spi_clk)\n    // spi_freq = system_freq / (2*CLK_DIV)\n    // ---------------------------------------------------------\n    parameter int CLK_DIV = 4;            // must be \u22652 and even\n\n    // ---------------------------------------------------------\n    // Registers / wires\n    // ---------------------------------------------------------\n    logic [15:0] div_cnt;                 // generic large enough\n    logic        spi_clk_int;             // internal SPI clock\n    logic        spi_clk_prev;            // edge detector\n    logic [2:0]  bit_cnt;\n    logic [7:0]  shifter_tx;\n    logic [7:0]  shifter_rx;\n    logic        busy;\n\n    //----------------------------------------------------------\n    // Defaults\n    //----------------------------------------------------------\n    assign SPI_CLK = spi_clk_int;\n    assign SPI_EN  = ~busy;               // active-low CS\n\n    //----------------------------------------------------------\n    // Clock-divider : generates MODE-3 clock (idle = 1)\n    //----------------------------------------------------------\n    always_ff @(posedge clk) begin\n        if (rst) begin\n            div_cnt     <= '0;\n            spi_clk_int <= 1'b1;          // CPOL = 1  (idle high)\n        end\n        else if (busy) begin\n            if (div_cnt == (CLK_DIV-1)) begin\n                div_cnt     <= '0;\n                spi_clk_int <= ~spi_clk_int;  // toggle\n            end\n            else\n                div_cnt <= div_cnt + 1;\n        end\n        else begin\n            div_cnt     <= '0;\n            spi_clk_int <= 1'b1;          // keep idle high\n        end\n    end\n\n    //----------------------------------------------------------\n    // Transaction control & data shift\n    //----------------------------------------------------------\n    always_ff @(posedge clk) begin\n        spi_clk_prev <= spi_clk_int;      // store previous for edge detect\n\n        if (rst) begin\n            busy       <= 1'b0;\n            SPI_MOSI   <= 1'b0;\n            data_out   <= 8'h00;\n            bit_cnt    <= 3'd0;\n            shifter_tx <= 8'h00;\n            shifter_rx <= 8'h00;\n        end\n        else begin\n            //--------------------------------------------------\n            // Start new transaction\n            //--------------------------------------------------\n            if (SPI_start && !busy) begin\n                busy       <= 1'b1;\n                shifter_tx <= data_in;\n                shifter_rx <= 8'h00;\n                bit_cnt    <= 3'd7;       // 8 bits -> 7 down to 0\n            end\n\n            //--------------------------------------------------\n            // Active transaction  (MODE-3 timing)\n            // \u2022 Falling edge : update MOSI, shift out next bit\n            // \u2022 Rising  edge : sample MISO, shift into RX\n            //--------------------------------------------------\n            if (busy) begin\n                // Detect falling edge (1 -> 0)\n                if ( spi_clk_prev && !spi_clk_int ) begin\n                    SPI_MOSI   <= shifter_tx[7];              // present next bit\n                    shifter_tx <= {shifter_tx[6:0], 1'b0};    // shift left\n                end\n\n                // Detect rising edge (0 -> 1)\n                if ( !spi_clk_prev && spi_clk_int ) begin\n                    shifter_rx <= {shifter_rx[6:0], SPI_MISO}; // sample\n                    if (bit_cnt == 0) begin\n                        busy     <= 1'b0;                     // done\n                        data_out <= {shifter_rx[6:0], SPI_MISO};\n                    end\n                    else\n                        bit_cnt <= bit_cnt - 1;\n                end\n            end\n        end\n    end\n\nendmodule\n//------------------------------------------------------------\n```",
    "prompt_1": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=1 and CPHA=0. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out );\n",
    "answer_1": "```systemverilog\nmodule SPI_driver(\n    input  logic        clk,\n    input  logic        rst,\n    input  logic [7:0]  data_in,\n    input  logic        SPI_MISO,\n    input  logic        SPI_start,\n    output logic        SPI_MOSI,\n    output logic        SPI_CLK,\n    output logic        SPI_EN,      // Active\u2013low chip-select\n    output logic [7:0]  data_out\n);\n\n    // ------------------------------------------------------------\n    // Parameters for CPOL/CPHA = 1/0  (SPI mode-2) and clock prescale\n    // ------------------------------------------------------------\n    localparam bit CPOL      = 1'b1;           // Clock idle high\n    localparam bit CPHA      = 1'b0;           // Sample on leading edge\n    parameter     int DIVIDE = 4;              // System-clk cycles per half-SCLK\n\n    // ------------------------------------------------------------\n    // State machine\n    // ------------------------------------------------------------\n    typedef enum logic [1:0] {IDLE, LOAD, XFER, DONE} state_t;\n    state_t state, next_state;\n\n    // ------------------------------------------------------------\n    // Registers\n    // ------------------------------------------------------------\n    logic [$clog2(DIVIDE)-1:0] div_cnt;\n    logic                      sclk_int;       // Internal SCLK\n    logic [7:0]                shft_tx, shft_rx;\n    logic [3:0]                bit_cnt;        // Counts 8 transfers\n\n    // ------------------------------------------------------------\n    // Sequential state register\n    // ------------------------------------------------------------\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    // ------------------------------------------------------------\n    // Next-state logic\n    // ------------------------------------------------------------\n    always_comb begin\n        next_state = state;\n        case (state)\n            IDLE : if (SPI_start)          next_state = LOAD;\n            LOAD :                         next_state = XFER;\n            XFER: if (bit_cnt == 0 && sclk_int == CPOL)\n                                             next_state = DONE;\n            DONE :                         next_state = IDLE;\n        endcase\n    end\n\n    // ------------------------------------------------------------\n    // Clock divider & SCLK generation (idle high)\n    // ------------------------------------------------------------\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            div_cnt  <= '0;\n            sclk_int <= CPOL;\n        end\n        else begin\n            if (state == XFER) begin\n                if (div_cnt == DIVIDE-1) begin\n                    div_cnt  <= '0;\n                    sclk_int <= ~sclk_int;          // Toggle SCLK\n                end\n                else\n                    div_cnt <= div_cnt + 1;\n            end\n            else begin\n                div_cnt  <= '0;\n                sclk_int <= CPOL;                   // Hold idle\n            end\n        end\n    end\n\n    // ------------------------------------------------------------\n    // Shift logic (CPOL=1, CPHA=0 : sample on falling, change on rising)\n    // ------------------------------------------------------------\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            shft_tx  <= 8'h00;\n            shft_rx  <= 8'h00;\n            bit_cnt  <= 4'd0;\n            SPI_MOSI <= 1'b0;\n        end\n        else begin\n            case (state)\n                LOAD: begin\n                    shft_tx  <= data_in;\n                    bit_cnt  <= 4'd8;\n                    SPI_MOSI <= data_in[7];         // Present first bit\n                end\n\n                XFER: if (div_cnt == DIVIDE-1) begin\n                    if (sclk_int == CPOL) begin     // Falling edge (leading)\n                        shft_rx <= {shft_rx[6:0], SPI_MISO};\n                    end\n                    else begin                      // Rising edge (trailing)\n                        shft_tx <= {shft_tx[6:0], 1'b0};\n                        SPI_MOSI <= shft_tx[6];\n                        bit_cnt  <= bit_cnt - 1;\n                    end\n                end\n\n                default: ;\n            endcase\n        end\n    end\n\n    // ------------------------------------------------------------\n    // Capture received byte\n    // ------------------------------------------------------------\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            data_out <= 8'h00;\n        else if (state == DONE)\n            data_out <= shft_rx;\n    end\n\n    // ------------------------------------------------------------\n    // Outputs\n    // ------------------------------------------------------------\n    assign SPI_CLK = sclk_int;\n    assign SPI_EN  = (state == XFER) ? 1'b0 : 1'b1; // Active-low\nendmodule\n```",
    "prompt_2": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=0 and CPHA=1. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out );\n",
    "answer_2": "```systemverilog\n// -----------------------------------------------------------------------------\n// Simple SPI-Master Driver\n//  \u2022 Fixed mode  : CPOL = 0, CPHA = 1  (Mode-1)\n//  \u2022 8-bit frame, MSB first\n//  \u2022 \u201cSPI_EN\u201d (chip\u2013select) is active-low\n//  \u2022 \u201cCLK_DIV\u201d determines the generated SCK frequency\n// -----------------------------------------------------------------------------\nmodule SPI_driver\n(\n    input  logic       clk,        // system clock\n    input  logic       rst,        // asynchronous reset, active-high\n    input  logic [7:0] data_in,    // byte to transmit\n    input  logic       SPI_MISO,   // data from slave\n    input  logic       SPI_start,  // start pulse (one clk cycle)\n    output logic       SPI_MOSI,   // data to slave\n    output logic       SPI_CLK,    // generated SCK\n    output logic       SPI_EN,     // chip\u2013select (active-low)\n    output logic [7:0] data_out    // byte received\n);\n\n    //---------------------------------------------------------------------\n    // USER PARAMETER:  divide system clock to obtain SCK\n    //  (SPI_CLK  =  clk / (2*CLK_DIV)  ;  CLK_DIV must be \u22652 and even)\n    //---------------------------------------------------------------------\n    parameter int unsigned CLK_DIV = 4;\n\n    //---------------------------------------------------------------------\n    // Internal signals / registers\n    //---------------------------------------------------------------------\n    typedef enum logic [1:0] {IDLE, LOAD, TRANSFER, DONE} state_t;\n\n    state_t                state, next_state;\n\n    logic [$clog2(CLK_DIV)-1:0] div_cnt;   // clock-divider counter\n    logic                        sclk;     // generated SPI clock (CPOL=0)\n    logic                        sclk_prev; // for edge detection\n\n    logic [7:0] tx_shift;   // shift-register for MOSI\n    logic [7:0] rx_shift;   // shift-register for MISO\n    logic [2:0] bit_cnt;    // counts 7 \u2026 0 (MSB first)\n\n    //---------------------------------------------------------------------\n    // Output assignments\n    //---------------------------------------------------------------------\n    assign SPI_CLK = (state == TRANSFER) ? sclk : 1'b0;          // CPOL = 0\n    assign SPI_EN  = (state == TRANSFER || state == LOAD) ? 1'b0 // active-low\n                                                          : 1'b1;\n    assign SPI_MOSI = tx_shift[7];  // always drive MSB of TX shift-register\n    assign data_out = rx_shift;     // valid after DONE state\n\n    //---------------------------------------------------------------------\n    // Clock-divider : generates \u201csclk\u201d while in TRANSFER state\n    //---------------------------------------------------------------------\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            div_cnt <= '0;\n            sclk    <= 1'b0;\n        end\n        else if (state == TRANSFER) begin\n            if (div_cnt == CLK_DIV-1) begin\n                div_cnt <= '0;\n                sclk    <= ~sclk;         // toggle SCK\n            end\n            else begin\n                div_cnt <= div_cnt + 1'b1;\n            end\n        end\n        else begin                       // keep SCK low when idle\n            div_cnt <= '0;\n            sclk    <= 1'b0;\n        end\n    end\n\n    //---------------------------------------------------------------------\n    // Main state-machine + shift logic  (Mode-1 : CPOL=0, CPHA=1)\n    //\n    //   \u2022 MOSI changes on leading edge  (rising, since CPOL=0)\n    //   \u2022 MISO is sampled on trailing edge (falling)\n    //---------------------------------------------------------------------\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state     <= IDLE;\n            tx_shift  <= '0;\n            rx_shift  <= '0;\n            bit_cnt   <= '0;\n            sclk_prev <= 1'b0;\n        end\n        else begin\n            sclk_prev <= sclk;        // store previous SCK for edge detection\n            state     <= next_state;  // update state\n\n            //-----------------------------------------------------------------\n            // Actions inside TRANSFER state (edge-dependent)\n            //-----------------------------------------------------------------\n            if (state == TRANSFER) begin\n\n                // Leading edge (rising) : place next data bit on MOSI\n                if (!sclk_prev &&  sclk) begin          // rising edge\n                    if (bit_cnt != 3'd0)\n                        tx_shift <= {tx_shift[6:0], 1'b0}; // left-shift\n                end\n\n                // Trailing edge (falling) : sample MISO\n                if ( sclk_prev && !sclk) begin          // falling edge\n                    rx_shift[bit_cnt] <= SPI_MISO;       // store in correct bit\n                    if (bit_cnt == 3'd0)\n                        bit_cnt <= bit_cnt;              // stay at 0 (done)\n                    else\n                        bit_cnt <= bit_cnt - 1'b1;\n                end\n            end\n        end\n    end\n\n    //---------------------------------------------------------------------\n    // Next-state logic (combinational)\n    //---------------------------------------------------------------------\n    always_comb begin\n        next_state = state;\n        case (state)\n            IDLE : if (SPI_start)      next_state = LOAD;\n            LOAD :                     next_state = TRANSFER;\n            TRANSFER : if (sclk_prev && !sclk && bit_cnt == 3'd0)\n                                         next_state = DONE;  // after last sample\n            DONE :                     next_state = IDLE;\n            default:                   next_state = IDLE;\n        endcase\n    end\n\n    //---------------------------------------------------------------------\n    // State-entry actions that need one exact cycle\n    //---------------------------------------------------------------------\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // nothing extra\n        end\n        else begin\n            if (state == LOAD && next_state == TRANSFER) begin\n                tx_shift <= data_in;   // load byte to transmit\n                bit_cnt  <= 3'd7;      // MSB first\n            end\n        end\n    end\n\nendmodule\n```\n",
    "prompt_3": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=0 and CPHA=0. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out );\n",
    "answer_3": "```systemverilog\n//------------------------------------------------------------\n// Simple SPI master driver\n// Mode : CPOL = 0 , CPHA = 0      (SPI-Mode-0)\n// Word : 8-bit, MSB first\n// Note : SPI_EN is active LOW\n//------------------------------------------------------------\nmodule SPI_driver\n#(\n    // System-clock-to-SPI-clock divider (must be even, \u22652)\n    parameter int CLK_DIV = 4\n)(\n    input  logic       clk,        // system clock\n    input  logic       rst,        // asynchronous reset, active high\n    input  logic [7:0] data_in,    // byte to transmit\n    input  logic       SPI_MISO,   // data from slave\n    input  logic       SPI_start,  // pulse to start a transfer\n\n    output logic       SPI_MOSI,   // data to slave\n    output logic       SPI_CLK,    // generated SPI clock\n    output logic       SPI_EN,     // chip-select  (active low)\n    output logic [7:0] data_out    // byte received\n);\n\n    //--------------------------------------------------------\n    // Local parameters / FSM states\n    //--------------------------------------------------------\n    localparam  IDLE     = 2'b00,\n                XFER     = 2'b01,\n                DONE     = 2'b10;\n\n    //--------------------------------------------------------\n    // Registers / wires\n    //--------------------------------------------------------\n    logic [1:0]                     state, next_state;\n\n    // clock divider\n    logic [$clog2(CLK_DIV)-1:0]     clk_cnt;\n    logic                           sclk, sclk_prev;\n    logic                           sclk_rise, sclk_fall;\n\n    // shift registers\n    logic [7:0]                     tx_reg;\n    logic [7:0]                     rx_reg;\n    logic [2:0]                     bit_cnt;       // counts remaining bits\n\n    //--------------------------------------------------------\n    // State machine\n    //--------------------------------------------------------\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    always_comb begin\n        next_state = state;\n        case (state)\n            IDLE  : if (SPI_start)                       next_state = XFER;\n            XFER  : if (sclk_rise && (bit_cnt == 3'd0)) next_state = DONE;\n            DONE  :                                        next_state = IDLE;\n            default:                                      next_state = IDLE;\n        endcase\n    end\n\n    //--------------------------------------------------------\n    // SPI clock generation  (CPOL = 0  \u2192 idle low)\n    //--------------------------------------------------------\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            clk_cnt <= '0;\n            sclk    <= 1'b0;\n        end\n        else begin\n            if (state == XFER) begin\n                if (clk_cnt == CLK_DIV-1) begin\n                    clk_cnt <= '0;\n                    sclk    <= ~sclk;            // toggle SPI clock\n                end else begin\n                    clk_cnt <= clk_cnt + 1'b1;\n                end\n            end\n            else begin\n                clk_cnt <= '0;\n                sclk    <= 1'b0;                 // idle level\n            end\n        end\n    end\n\n    //--------------------------------------------------------\n    // Detect rises / falls of the generated SPI clock\n    //--------------------------------------------------------\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            sclk_prev <= 1'b0;\n        else\n            sclk_prev <= sclk;\n    end\n\n    assign sclk_rise =  ( sclk & ~sclk_prev);    // 0 \u2192 1\n    assign sclk_fall =  (~sclk &  sclk_prev);    // 1 \u2192 0\n\n    //--------------------------------------------------------\n    // Shift registers & bit counter\n    //  CPHA = 0  \u2192  shift out on falling edge, sample on rising edge\n    //--------------------------------------------------------\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tx_reg   <= '0;\n            rx_reg   <= '0;\n            bit_cnt  <= 3'd7;\n            SPI_MOSI<= 1'b0;\n            data_out<= '0;\n        end else begin\n            case (state)\n                IDLE : begin\n                    if (SPI_start) begin\n                        tx_reg   <= data_in;     // load byte to transmit\n                        rx_reg   <= '0;\n                        bit_cnt  <= 3'd7;\n                        SPI_MOSI <= data_in[7];  // present first (MSB) before 1st rising edge\n                    end\n                end\n\n                XFER : begin\n                    // Shift out next bit (prepare MOSI) on SPI clock falling edge\n                    if (sclk_fall) begin\n                        tx_reg   <= {tx_reg[6:0], 1'b0};\n                        SPI_MOSI <= tx_reg[6];\n                    end\n\n                    // Sample MISO on SPI clock rising edge\n                    if (sclk_rise) begin\n                        rx_reg   <= {rx_reg[6:0], SPI_MISO};\n                        if (bit_cnt != 3'd0)\n                            bit_cnt <= bit_cnt - 1'b1;\n                    end\n                end\n\n                DONE : begin\n                    data_out <= rx_reg;          // make received byte available\n                end\n            endcase\n        end\n    end\n\n    //--------------------------------------------------------\n    // Outputs\n    //--------------------------------------------------------\n    assign SPI_CLK = sclk;                       // CPOL = 0\n    assign SPI_EN  = (state == XFER) ? 1'b0 : 1'b1;   // active low\n\nendmodule\n```"
}
