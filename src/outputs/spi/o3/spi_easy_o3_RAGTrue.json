{
    "prompt_0": "The SPI Master core consists of three parts shown in the following figure: Serial Interface spi_shift.v Clock generator spi_clgen.v sclk_pad_o OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 9 of 9 Appendix A Core configuration To meet specific system requirements and size constraints on behalf of the core functionality, the SPI Master core can be configuredby setting the appropriate define directives in the spi_defines.v source file. The directives are as follows: SPI_DIVIDER_BIT_NB This parameter defines the maximum number of bits needed for the divider. Set this parameter accordingly to the maximum system frequency and lowest serial clock frequency: \uf8fa \uf8fb\uf8f9 \uf8ef \uf8f0\uf8ee\u2212\u2217= 12log R_BIT_NB SPI_DIVIDE minmax 2 sclksys ff Default value is 16. SPI_MAX_CHAR This parameter defines the maximum number of bits that can be received/transmitted in one transfer. The default value is 32. SPI_SS_NB This parameter defines the number of slave select lines. The default value is 8.\nTable 8: Slave Select register Reset Value: 0x00000000 SS Writing 1 to any bit location of this field sets the proper ss_pad_o line to an active state. OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 6 of 9 4 Operation This core is an SPI and Microwire/Plus compliant synchronous serial controller. At the host side, it is controlled via registers accessible through a WISHBONE rev. B1 interface. 4.1 WISHBONE interface The SPI core has four 32-bit registers through the WISHBONE rev. B1 compatible interface. All accesses to SPI registers must be 32-bit (wb_sel[3:0] = 0xf). Please refer to the WISHBONE specification at http://www.opencores.org/wishbone/specs/wbspec_b1.pdf 4.2 Serial interface The serial interface consists of slave select lines, serial clock lines, as well as input and output data lines. All transfers are full duplex transfers of a programmable number of bits per transfer (up to 32 bits). Compared to the SPI/Microwire protocol, this core has some additional functionality. It can drive data to the output data line in respect to the falling (SPI/Microwire compliant) or rising edge of the serial clock, and it can latch data on an input data line on the rising (SPI/Microwire compliant) or falling edge of a serial clock line. It also can transmit (receive) the MSB first (SPI/Microwire compliant) or the LSB first. It is important to know that the Rx and Tx registers share the same flip-flops, which means that what is received from the input data line in one transfer will be transmitted on the output data line in the next transfer if no write access to the Tx register is executed between the transfers. /ss_pad_o[0] /ss_pad_o[1] /ss_pad_o[2] MASTER sclk_pad_o mosi_pad_o miso pad i MISO MOSI SCLK /SS SLAVE 0 MISO MOSI SCLK / SS SLAVE 1 MISO MOSI SCLK /SS SLAVE 2 WISHBONE MISO MOSI SCLK/SS SLAVE 0 MISO MOSI SCLK/SS SLAVE 1 MISO MOSI SCLK/SS SLAVE 2 WISHBON E /ss_pad_o[0]/ss_pad_o[1]/ss_pad_o[2] MASTER sclk_pad_o mosi_pad_o miso _pad_iOpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 7 of 9 ss_pad_o mosi_pad_o miso_pad_i CTRL[LSB] = 0, CTRL[CHAR_LEN] = 0x08, CTRL[TX_NEG] = 1, CTRL[RX_NEG] = 0 LSB (Tx[0])ss_pad_o mosi_pad_o miso_pad_i CTRL[LSB] = 1, CTRL[CHAR_LEN] = 0x0a, CTRL[TX_NEG] = 0, CTRL[RX_NEG] = 1 MSB (Tx[9]) MSB (Tx[7]) MSB (Rx[7])LSB (Tx[0]) LSB (Rx[0]) LSB (Rx[0])MSB (Rx[9]) sclk_pad_o sclk_pad_o OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 8 of 9 WHISHBONE SOC Bus WHISHBONE Interface spi_top.v ss_pad_o mosi_pad_o miso_pad_i 5 Architecture The SPI Master core consists of three parts shown in the following figure: Serial Interface spi_shift.v Clock generator spi_clgen.v sclk_pad_o OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 9 of 9 Appendix A Core configuration To meet specific system requirements and size constraints on behalf of the core functionality, the SPI Master core can be configuredby setting the appropriate define directives in the spi_defines.v source file. The directives are as follows: SPI_DIVIDER_BIT_NB This parameter defines the maximum number of bits needed for the divider. Set this parameter accordingly to the maximum system frequency and lowest serial clock frequency: \uf8fa\nSPI Master Core Specification Author: Simon Srot simons@opencores.org Rev. 0.2 July 12, 2002 OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.1 i Revision History Rev. Date Author Description 0.1 June 13, 2002 Simon Srot First Draft 0.2 July 12, 2002 Simon Srot Document is lectured. OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.1 ii Contents CONTENTS.......................................................................................................... II INTRODUCTION................................................................................................. 1 IO PORTS.............................................................................................................. 2 2.1 WISHBONE INTERFACE SIGNALS ................................................................. 2 2.2 SPI EXTERNAL CONNECTIONS ........................................................................ 2 REGISTERS.......................................................................................................... 3 3.1 C ORE REGISTERS LIST .................................................................................... 3 3.2 D ATA RECEIVE REGISTER [RX]....................................................................... 3 3.3 D ATA TRANSMIT REGISTER [TX] .................................................................... 3 3.4 C ONTROL AND STATUS REGISTER [CTRL] ..................................................... 4 3.5 D IVIDER REGISTER [DIVIDER] ..................................................................... 5 3.6 S LAVE SELECT REGISTER [SS]........................................................................ 5 OPERATION......................................................................................................... 6 4.1 WISHBONE INTERFACE ............................................................................... 6 4.2 S ERIAL INTERFACE ......................................................................................... 6 ARCHITECTURE ................................................................................................ 8 CORE CONFIGURATION ................................................................................. 9 OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 1 of 9 1 Introduction This document provides specifications for the SPI (Serial Peripheral Interface) Master core. Synchronous serial interfaces are widely used to provide economical board-level interfaces between different devices such as microcontrollers, DACs, ADCs and other. Although there is no single standard for a synchronous serial bus, there are industry-wide accepted guidelines based on two most popular implementations: \u2022 SPI (a trademark of Motorola Semiconductor) \u2022 Microwire/Plus (a trademark of National Semiconductor) Many IC manufacturers produce components that are compatible with SPI and Microwire/Plus. The SPI Master core is compatible with both above-mentioned protocols as master with some additional functionality. At the hosts side, the core acts like a WISHBONE compliant slave device. Features: \u2022 Full duplex synchronous serial data transfer \u2022 Variable length of transfer word up to 32 bits \u2022 MSB or LSB first data transfer \u2022 Rx and Tx on both rising or falling edge of serial clock independently \u2022 8 slave select lines \u2022 Fully static synchronous design with one clock domain \u2022 Technology independent Verilog \u2022 Fully synthesizable OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 2 of 9 2 IO ports 2.1 WISHBONE interface signals Port Width Direction Description wb_clk_i 1 Input Master clock wb_rst_i 1 Input Synchronous reset, active high wb_adr_i 5 Input Lower address bits wb_dat_i 32 Input Data towards the core wb_dat_o 32 Output Data from the core wb_sel_i 4 Input Byte select signals wb_we_i 1 Input Write enable input wb_stb_i 1 Input Strobe signal/Core select input wb_cyc_i 1 Input Valid bus cycle input wb_ack_o 1 Output Bus cycle acknowledge output wb_err_o 1 Output Bus cycle error output wb_int_o 1 Output Interrupt signal output Table 1: Wishbone interface signals All output WISHBONE signals are registered and driven on the rising edge of wb_clk_i. All input WISHBONE signals are latched on the rising edge of wb_clk_i. 2.2 SPI external connections Port Width Direction Description /ss_pad_o 8 Output Slave select output signals sclk_pad_o 1 Output Serial clock output mosi_pad_o 1 Output Master out slave in data signal output miso_pad_i 1 Input Master in slave out data signal input\nGenerate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=1 and CPHA=1. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out );\n",
    "answer_0": "```systemverilog\n//-----------------------------------------------------------\n//  Simple SPI MASTER (MODE-3 : CPOL = 1 , CPHA = 1)\n//-----------------------------------------------------------\n//  \u2022 Full-duplex, 8-bit transfer\n//  \u2022 Generates the SPI clock from system clock (clk)\n//  \u2022 Active-low chip\u2013select  (SPI_EN)\n//  \u2022 Data are driven on the falling edge and sampled on the\n//    rising edge of SPI_CLK (MODE-3 requirements)\n//-----------------------------------------------------------\nmodule SPI_driver #(\n    // Number of system-clock cycles that make \u00bd period of SPI_CLK\n    //   SPI_CLK = clk / (2*DIVIDER)\n    parameter int unsigned DIVIDER = 4        // even, \u22652\n)(\n    input  logic        clk ,       // system clock\n    input  logic        rst ,       // synchronous reset (active high)\n\n    // User interface\n    input  logic  [7:0] data_in ,   // byte to send\n    input  logic        SPI_start , // pulse => start new transfer\n    output logic [7:0]  data_out ,  // byte just received\n    // SPI lines\n    input  logic        SPI_MISO ,  // Master-In  Slave-Out\n    output logic        SPI_MOSI ,  // Master-Out Slave-In\n    output logic        SPI_CLK ,   // Serial clock  (idle = \u20181\u2019)\n    output logic        SPI_EN      // Active-low chip select\n);\n\n   //--------------------------------------------------------\n   //  Internal signals / registers\n   //--------------------------------------------------------\n   typedef enum logic [1:0] {IDLE, TRANSFER} state_t;\n   state_t              state , state_n;\n\n   logic [$clog2(DIVIDER)-1:0] div_cnt;     // clock divider counter\n   logic                       sclk_reg;    // generated serial clock\n   logic                       sclk_next;\n   logic                       sclk_fall;   // 1 clk-tick wide\n   logic                       sclk_rise;   // 1 clk-tick wide\n\n   logic [7:0] tx_shift, rx_shift;\n   logic [3:0] bit_cnt;                     // counts remaining bits\n\n   //--------------------------------------------------------\n   //  Clock divider / SCLK generator\n   //--------------------------------------------------------\n   always_ff @(posedge clk) begin\n      if (rst) begin\n         div_cnt  <= '0;\n         sclk_reg <= 1'b1;                  // CPOL = 1  (idle high)\n      end\n      else begin\n         if (state == TRANSFER) begin\n            if (div_cnt == DIVIDER-1) begin\n               div_cnt  <= '0;\n               sclk_reg <= ~sclk_reg;       // toggle SCLK\n            end else\n               div_cnt <= div_cnt + 1;\n         end\n         else begin                         // IDLE\n            div_cnt  <= '0;\n            sclk_reg <= 1'b1;               // keep high while idle\n         end\n      end\n   end\n\n   // Edge detectors (one-cycle pulses in clk domain)\n   logic sclk_reg_d;\n   always_ff @(posedge clk) sclk_reg_d <= sclk_reg;\n   assign sclk_rise = ( sclk_reg & ~sclk_reg_d);  // 0\u21921 in MODE-3\n   assign sclk_fall = (~sclk_reg &  sclk_reg_d);  // 1\u21920\n\n   //--------------------------------------------------------\n   //  Main control FSM\n   //--------------------------------------------------------\n   always_ff @(posedge clk) begin\n      if (rst) begin\n         state   <= IDLE;\n         bit_cnt <= '0;\n         tx_shift<= '0;\n         rx_shift<= '0;\n      end\n      else begin\n         state <= state_n;\n\n         //------- ACTIONS IN TRANSFER STATE ----------------\n         if (state == TRANSFER) begin\n            // Drive next bit on falling edge\n            if (sclk_fall) begin\n               {tx_shift, SPI_MOSI} <= {tx_shift[6:0], 1'b0}; // shift left\n               bit_cnt <= bit_cnt - 1;\n            end\n\n            // Sample MISO on rising edge\n            if (sclk_rise) begin\n               rx_shift <= {rx_shift[6:0], SPI_MISO};\n            end\n         end\n      end\n   end\n\n   // Next-state logic\n   always_comb begin\n      state_n = state;\n      case (state)\n         IDLE : begin\n            if (SPI_start) begin\n               state_n  = TRANSFER;\n            end\n         end\n\n         TRANSFER : begin\n            if ((bit_cnt == 4'd0) && sclk_rise) begin\n               state_n = IDLE;              // finished after last sample\n            end\n         end\n      endcase\n   end\n\n   //--------------------------------------------------------\n   //  Outputs and miscellaneous synchronous assignments\n   //--------------------------------------------------------\n   always_ff @(posedge clk) begin\n      if (rst) begin\n         SPI_MOSI <= 1'b0;\n         SPI_EN   <= 1'b1;                  // inactive (chip not selected)\n         data_out <= 8'h00;\n      end\n      else begin\n         // Load registers at start of a transfer\n         if (state == IDLE && state_n == TRANSFER) begin\n            tx_shift <= data_in;\n            SPI_MOSI<= data_in[7];          // first bit put on MOSI after CS\n            rx_shift<= '0;\n            bit_cnt <= 4'd8;\n            SPI_EN  <= 1'b0;                // assert CS (active-low)\n         end\n         // De-assert CS at the very end of the transfer\n         else if (state == TRANSFER && state_n == IDLE) begin\n            SPI_EN   <= 1'b1;\n            data_out <= rx_shift;           // make received byte available\n         end\n      end\n   end\n\n   // Assign generated clock\n   assign SPI_CLK = sclk_reg;\n\nendmodule\n```\n\nHow it works (short description)\n\u2022 The module starts a transfer when `SPI_start` is pulsed while in the IDLE state.  \n\u2022 `DIVIDER` sets the SPI baud rate: `f_SPI = f_clk / (2*DIVIDER)`.  \n\u2022 While IDLE, `SPI_CLK` is held high (CPOL=1) and `SPI_EN` is de-asserted (high).  \n\u2022 Entering TRANSFER:\n  \u2013 `SPI_EN` goes low.  \n  \u2013 The first falling edge of `SPI_CLK` drives the MSB of `data_in` on `SPI_MOSI`.  \n  \u2013 Each subsequent falling edge drives the next bit, satisfying the CPHA=1 requirement that data change on leading (falling) edge.  \n  \u2013 Each rising edge samples `SPI_MISO`, building `data_out`.  \n\u2022 After eight bits, the FSM returns to IDLE, `SPI_EN` goes high, and `data_out` holds the received byte.",
    "prompt_1": "The SPI Master core consists of three parts shown in the following figure: Serial Interface spi_shift.v Clock generator spi_clgen.v sclk_pad_o OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 9 of 9 Appendix A Core configuration To meet specific system requirements and size constraints on behalf of the core functionality, the SPI Master core can be configuredby setting the appropriate define directives in the spi_defines.v source file. The directives are as follows: SPI_DIVIDER_BIT_NB This parameter defines the maximum number of bits needed for the divider. Set this parameter accordingly to the maximum system frequency and lowest serial clock frequency: \uf8fa \uf8fb\uf8f9 \uf8ef \uf8f0\uf8ee\u2212\u2217= 12log R_BIT_NB SPI_DIVIDE minmax 2 sclksys ff Default value is 16. SPI_MAX_CHAR This parameter defines the maximum number of bits that can be received/transmitted in one transfer. The default value is 32. SPI_SS_NB This parameter defines the number of slave select lines. The default value is 8.\nTable 8: Slave Select register Reset Value: 0x00000000 SS Writing 1 to any bit location of this field sets the proper ss_pad_o line to an active state. OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 6 of 9 4 Operation This core is an SPI and Microwire/Plus compliant synchronous serial controller. At the host side, it is controlled via registers accessible through a WISHBONE rev. B1 interface. 4.1 WISHBONE interface The SPI core has four 32-bit registers through the WISHBONE rev. B1 compatible interface. All accesses to SPI registers must be 32-bit (wb_sel[3:0] = 0xf). Please refer to the WISHBONE specification at http://www.opencores.org/wishbone/specs/wbspec_b1.pdf 4.2 Serial interface The serial interface consists of slave select lines, serial clock lines, as well as input and output data lines. All transfers are full duplex transfers of a programmable number of bits per transfer (up to 32 bits). Compared to the SPI/Microwire protocol, this core has some additional functionality. It can drive data to the output data line in respect to the falling (SPI/Microwire compliant) or rising edge of the serial clock, and it can latch data on an input data line on the rising (SPI/Microwire compliant) or falling edge of a serial clock line. It also can transmit (receive) the MSB first (SPI/Microwire compliant) or the LSB first. It is important to know that the Rx and Tx registers share the same flip-flops, which means that what is received from the input data line in one transfer will be transmitted on the output data line in the next transfer if no write access to the Tx register is executed between the transfers. /ss_pad_o[0] /ss_pad_o[1] /ss_pad_o[2] MASTER sclk_pad_o mosi_pad_o miso pad i MISO MOSI SCLK /SS SLAVE 0 MISO MOSI SCLK / SS SLAVE 1 MISO MOSI SCLK /SS SLAVE 2 WISHBONE MISO MOSI SCLK/SS SLAVE 0 MISO MOSI SCLK/SS SLAVE 1 MISO MOSI SCLK/SS SLAVE 2 WISHBON E /ss_pad_o[0]/ss_pad_o[1]/ss_pad_o[2] MASTER sclk_pad_o mosi_pad_o miso _pad_iOpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 7 of 9 ss_pad_o mosi_pad_o miso_pad_i CTRL[LSB] = 0, CTRL[CHAR_LEN] = 0x08, CTRL[TX_NEG] = 1, CTRL[RX_NEG] = 0 LSB (Tx[0])ss_pad_o mosi_pad_o miso_pad_i CTRL[LSB] = 1, CTRL[CHAR_LEN] = 0x0a, CTRL[TX_NEG] = 0, CTRL[RX_NEG] = 1 MSB (Tx[9]) MSB (Tx[7]) MSB (Rx[7])LSB (Tx[0]) LSB (Rx[0]) LSB (Rx[0])MSB (Rx[9]) sclk_pad_o sclk_pad_o OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 8 of 9 WHISHBONE SOC Bus WHISHBONE Interface spi_top.v ss_pad_o mosi_pad_o miso_pad_i 5 Architecture The SPI Master core consists of three parts shown in the following figure: Serial Interface spi_shift.v Clock generator spi_clgen.v sclk_pad_o OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 9 of 9 Appendix A Core configuration To meet specific system requirements and size constraints on behalf of the core functionality, the SPI Master core can be configuredby setting the appropriate define directives in the spi_defines.v source file. The directives are as follows: SPI_DIVIDER_BIT_NB This parameter defines the maximum number of bits needed for the divider. Set this parameter accordingly to the maximum system frequency and lowest serial clock frequency: \uf8fa\nSPI Master Core Specification Author: Simon Srot simons@opencores.org Rev. 0.2 July 12, 2002 OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.1 i Revision History Rev. Date Author Description 0.1 June 13, 2002 Simon Srot First Draft 0.2 July 12, 2002 Simon Srot Document is lectured. OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.1 ii Contents CONTENTS.......................................................................................................... II INTRODUCTION................................................................................................. 1 IO PORTS.............................................................................................................. 2 2.1 WISHBONE INTERFACE SIGNALS ................................................................. 2 2.2 SPI EXTERNAL CONNECTIONS ........................................................................ 2 REGISTERS.......................................................................................................... 3 3.1 C ORE REGISTERS LIST .................................................................................... 3 3.2 D ATA RECEIVE REGISTER [RX]....................................................................... 3 3.3 D ATA TRANSMIT REGISTER [TX] .................................................................... 3 3.4 C ONTROL AND STATUS REGISTER [CTRL] ..................................................... 4 3.5 D IVIDER REGISTER [DIVIDER] ..................................................................... 5 3.6 S LAVE SELECT REGISTER [SS]........................................................................ 5 OPERATION......................................................................................................... 6 4.1 WISHBONE INTERFACE ............................................................................... 6 4.2 S ERIAL INTERFACE ......................................................................................... 6 ARCHITECTURE ................................................................................................ 8 CORE CONFIGURATION ................................................................................. 9 OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 1 of 9 1 Introduction This document provides specifications for the SPI (Serial Peripheral Interface) Master core. Synchronous serial interfaces are widely used to provide economical board-level interfaces between different devices such as microcontrollers, DACs, ADCs and other. Although there is no single standard for a synchronous serial bus, there are industry-wide accepted guidelines based on two most popular implementations: \u2022 SPI (a trademark of Motorola Semiconductor) \u2022 Microwire/Plus (a trademark of National Semiconductor) Many IC manufacturers produce components that are compatible with SPI and Microwire/Plus. The SPI Master core is compatible with both above-mentioned protocols as master with some additional functionality. At the hosts side, the core acts like a WISHBONE compliant slave device. Features: \u2022 Full duplex synchronous serial data transfer \u2022 Variable length of transfer word up to 32 bits \u2022 MSB or LSB first data transfer \u2022 Rx and Tx on both rising or falling edge of serial clock independently \u2022 8 slave select lines \u2022 Fully static synchronous design with one clock domain \u2022 Technology independent Verilog \u2022 Fully synthesizable OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 2 of 9 2 IO ports 2.1 WISHBONE interface signals Port Width Direction Description wb_clk_i 1 Input Master clock wb_rst_i 1 Input Synchronous reset, active high wb_adr_i 5 Input Lower address bits wb_dat_i 32 Input Data towards the core wb_dat_o 32 Output Data from the core wb_sel_i 4 Input Byte select signals wb_we_i 1 Input Write enable input wb_stb_i 1 Input Strobe signal/Core select input wb_cyc_i 1 Input Valid bus cycle input wb_ack_o 1 Output Bus cycle acknowledge output wb_err_o 1 Output Bus cycle error output wb_int_o 1 Output Interrupt signal output Table 1: Wishbone interface signals All output WISHBONE signals are registered and driven on the rising edge of wb_clk_i. All input WISHBONE signals are latched on the rising edge of wb_clk_i. 2.2 SPI external connections Port Width Direction Description /ss_pad_o 8 Output Slave select output signals sclk_pad_o 1 Output Serial clock output mosi_pad_o 1 Output Master out slave in data signal output miso_pad_i 1 Input Master in slave out data signal input\nGenerate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=1 and CPHA=0. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out );\n",
    "answer_1": "```systemverilog\n// -----------------------------------------------------------------------------\n// Simple 8-bit SPI Master (Mode-2 : CPOL = 1, CPHA = 0)\n// \u2011 CPOL = 1 : SCLK is HIGH when bus is idle\n// \u2011 CPHA = 0 : Data is driven valid before the first (falling) edge;\n//              data is captured on the first (falling) edge.\n//\n// Generic, single-byte transaction started with SPI_start.\n// Clock is generated by dividing the system clock (clk) by parameter CLK_DIV*2.\n// -----------------------------------------------------------------------------\nmodule SPI_driver #(\n    parameter int unsigned CLK_DIV = 4   // sys_clk ticks per half SCLK period\n)(\n    input  logic        clk,        // system clock\n    input  logic        rst,        // synchronous, active high reset\n    input  logic [7:0]  data_in,    // byte to be transmitted\n    input  logic        SPI_MISO,   // slave -> master data\n    input  logic        SPI_start,  // assert for one clk to start transfer\n    output logic        SPI_MOSI,   // master -> slave data\n    output logic        SPI_CLK,    // serial clock (CPOL = 1)\n    output logic        SPI_EN,     // chip-select (active low)\n    output logic [7:0]  data_out    // byte just received\n);\n\n    // ---------------------------------------------------------\n    // Local registers / signals\n    // ---------------------------------------------------------\n    typedef enum logic [1:0] {IDLE, ASSERT_CS, TRANSFER, DEASSERT_CS} state_t;\n    state_t          state, nxt_state;\n\n    logic [$clog2(CLK_DIV)-1:0] clk_cnt;   // clock divider counter\n    logic                        sclk_int; // internal clock (pre-CPOL ORed)\n    logic [7:0]                  shreg;    // shift register (Tx/Rx)\n    logic [2:0]                  bit_cnt;  // tracks 0->7\n    logic                        sclk_fall;// single-cycle pulse \u2013 SCLK falling\n    logic                        sclk_rise;// single-cycle pulse \u2013 SCLK rising\n\n    // ---------------------------------------------------------\n    // Clock divider \u2013 produces sclk_int toggles\n    // ---------------------------------------------------------\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            clk_cnt  <= '0;\n            sclk_int <= 1'b0;\n        end\n        else if (state == TRANSFER) begin\n            if (clk_cnt == CLK_DIV-1) begin\n                clk_cnt  <= '0;\n                sclk_int <= ~sclk_int;\n            end\n            else begin\n                clk_cnt <= clk_cnt + 1'b1;\n            end\n        end\n        else begin\n            clk_cnt  <= '0;\n            sclk_int <= 1'b0;   // ensure defined after IDLE\n        end\n    end\n\n    // Create single-cycle edge indicators\n    logic sclk_int_d;\n    always_ff @(posedge clk) sclk_int_d <= sclk_int;\n    assign sclk_rise =  sclk_int & ~sclk_int_d;\n    assign sclk_fall = ~sclk_int &  sclk_int_d;\n\n    // ---------------------------------------------------------\n    // Main FSM\n    // ---------------------------------------------------------\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) state <= IDLE;\n        else     state <= nxt_state;\n    end\n\n    always_comb begin\n        nxt_state = state;\n        case (state)\n            IDLE        : if (SPI_start)      nxt_state = ASSERT_CS;\n            ASSERT_CS   :                    nxt_state = TRANSFER;\n            TRANSFER    : if (bit_cnt == 3'd7 && sclk_rise)\n                                               nxt_state = DEASSERT_CS;\n            DEASSERT_CS :                    nxt_state = IDLE;\n        endcase\n    end\n\n    // ---------------------------------------------------------\n    // Bit counter\n    // ---------------------------------------------------------\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) bit_cnt <= 3'd0;\n        else if (state == ASSERT_CS)  bit_cnt <= 3'd0;\n        else if (state == TRANSFER && sclk_rise)\n            bit_cnt <= bit_cnt + 1'b1;\n    end\n\n    // ---------------------------------------------------------\n    // Shift register \u2013 CPOL=1, CPHA=0 protocol handling\n    //  \u2022 MOSI must be valid before the falling edge.\n    //  \u2022 MISO is sampled on the falling edge.\n    // ---------------------------------------------------------\n    // Load on ASSERT_CS\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            shreg <= 8'h00;\n        end\n        else begin\n            case (state)\n                ASSERT_CS : shreg <= data_in;         // load Tx data\n                TRANSFER  : begin\n                    // Falling edge : sample MISO into LSB\n                    if (sclk_fall)\n                        shreg <= {shreg[6:0], SPI_MISO};\n                    // Rising edge  : shift for next bit\n                    if (sclk_rise)\n                        shreg <= {shreg[6:0], 1'b0};\n                end\n            endcase\n        end\n    end\n\n    // ---------------------------------------------------------\n    // Outputs\n    // ---------------------------------------------------------\n    // SCLK : CPOL=1 -> idle HIGH\n    assign SPI_CLK = (state == TRANSFER) ? ~sclk_int : 1'b1; // invert to get falling first edge\n\n    // MOSI is always the current MSB (bit 7) of shift register\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)            SPI_MOSI <= 1'b0;\n        // update before next falling edge (i.e. after rising edge shift)\n        else if (state == ASSERT_CS)        SPI_MOSI <= shreg[7];\n        else if (state == TRANSFER && sclk_rise)\n                                SPI_MOSI <= shreg[7];\n    end\n\n    // Chip-select (active low)\n    assign SPI_EN = (state == TRANSFER || state == ASSERT_CS) ? 1'b0 : 1'b1;\n\n    // Present captured byte once transfer is complete\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)                   data_out <= 8'h00;\n        else if (state == DEASSERT_CS) data_out <= shreg;\n    end\n\nendmodule\n```\n",
    "prompt_2": "The SPI Master core consists of three parts shown in the following figure: Serial Interface spi_shift.v Clock generator spi_clgen.v sclk_pad_o OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 9 of 9 Appendix A Core configuration To meet specific system requirements and size constraints on behalf of the core functionality, the SPI Master core can be configuredby setting the appropriate define directives in the spi_defines.v source file. The directives are as follows: SPI_DIVIDER_BIT_NB This parameter defines the maximum number of bits needed for the divider. Set this parameter accordingly to the maximum system frequency and lowest serial clock frequency: \uf8fa \uf8fb\uf8f9 \uf8ef \uf8f0\uf8ee\u2212\u2217= 12log R_BIT_NB SPI_DIVIDE minmax 2 sclksys ff Default value is 16. SPI_MAX_CHAR This parameter defines the maximum number of bits that can be received/transmitted in one transfer. The default value is 32. SPI_SS_NB This parameter defines the number of slave select lines. The default value is 8.\nTable 8: Slave Select register Reset Value: 0x00000000 SS Writing 1 to any bit location of this field sets the proper ss_pad_o line to an active state. OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 6 of 9 4 Operation This core is an SPI and Microwire/Plus compliant synchronous serial controller. At the host side, it is controlled via registers accessible through a WISHBONE rev. B1 interface. 4.1 WISHBONE interface The SPI core has four 32-bit registers through the WISHBONE rev. B1 compatible interface. All accesses to SPI registers must be 32-bit (wb_sel[3:0] = 0xf). Please refer to the WISHBONE specification at http://www.opencores.org/wishbone/specs/wbspec_b1.pdf 4.2 Serial interface The serial interface consists of slave select lines, serial clock lines, as well as input and output data lines. All transfers are full duplex transfers of a programmable number of bits per transfer (up to 32 bits). Compared to the SPI/Microwire protocol, this core has some additional functionality. It can drive data to the output data line in respect to the falling (SPI/Microwire compliant) or rising edge of the serial clock, and it can latch data on an input data line on the rising (SPI/Microwire compliant) or falling edge of a serial clock line. It also can transmit (receive) the MSB first (SPI/Microwire compliant) or the LSB first. It is important to know that the Rx and Tx registers share the same flip-flops, which means that what is received from the input data line in one transfer will be transmitted on the output data line in the next transfer if no write access to the Tx register is executed between the transfers. /ss_pad_o[0] /ss_pad_o[1] /ss_pad_o[2] MASTER sclk_pad_o mosi_pad_o miso pad i MISO MOSI SCLK /SS SLAVE 0 MISO MOSI SCLK / SS SLAVE 1 MISO MOSI SCLK /SS SLAVE 2 WISHBONE MISO MOSI SCLK/SS SLAVE 0 MISO MOSI SCLK/SS SLAVE 1 MISO MOSI SCLK/SS SLAVE 2 WISHBON E /ss_pad_o[0]/ss_pad_o[1]/ss_pad_o[2] MASTER sclk_pad_o mosi_pad_o miso _pad_iOpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 7 of 9 ss_pad_o mosi_pad_o miso_pad_i CTRL[LSB] = 0, CTRL[CHAR_LEN] = 0x08, CTRL[TX_NEG] = 1, CTRL[RX_NEG] = 0 LSB (Tx[0])ss_pad_o mosi_pad_o miso_pad_i CTRL[LSB] = 1, CTRL[CHAR_LEN] = 0x0a, CTRL[TX_NEG] = 0, CTRL[RX_NEG] = 1 MSB (Tx[9]) MSB (Tx[7]) MSB (Rx[7])LSB (Tx[0]) LSB (Rx[0]) LSB (Rx[0])MSB (Rx[9]) sclk_pad_o sclk_pad_o OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 8 of 9 WHISHBONE SOC Bus WHISHBONE Interface spi_top.v ss_pad_o mosi_pad_o miso_pad_i 5 Architecture The SPI Master core consists of three parts shown in the following figure: Serial Interface spi_shift.v Clock generator spi_clgen.v sclk_pad_o OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 9 of 9 Appendix A Core configuration To meet specific system requirements and size constraints on behalf of the core functionality, the SPI Master core can be configuredby setting the appropriate define directives in the spi_defines.v source file. The directives are as follows: SPI_DIVIDER_BIT_NB This parameter defines the maximum number of bits needed for the divider. Set this parameter accordingly to the maximum system frequency and lowest serial clock frequency: \uf8fa\nSPI Master Core Specification Author: Simon Srot simons@opencores.org Rev. 0.2 July 12, 2002 OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.1 i Revision History Rev. Date Author Description 0.1 June 13, 2002 Simon Srot First Draft 0.2 July 12, 2002 Simon Srot Document is lectured. OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.1 ii Contents CONTENTS.......................................................................................................... II INTRODUCTION................................................................................................. 1 IO PORTS.............................................................................................................. 2 2.1 WISHBONE INTERFACE SIGNALS ................................................................. 2 2.2 SPI EXTERNAL CONNECTIONS ........................................................................ 2 REGISTERS.......................................................................................................... 3 3.1 C ORE REGISTERS LIST .................................................................................... 3 3.2 D ATA RECEIVE REGISTER [RX]....................................................................... 3 3.3 D ATA TRANSMIT REGISTER [TX] .................................................................... 3 3.4 C ONTROL AND STATUS REGISTER [CTRL] ..................................................... 4 3.5 D IVIDER REGISTER [DIVIDER] ..................................................................... 5 3.6 S LAVE SELECT REGISTER [SS]........................................................................ 5 OPERATION......................................................................................................... 6 4.1 WISHBONE INTERFACE ............................................................................... 6 4.2 S ERIAL INTERFACE ......................................................................................... 6 ARCHITECTURE ................................................................................................ 8 CORE CONFIGURATION ................................................................................. 9 OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 1 of 9 1 Introduction This document provides specifications for the SPI (Serial Peripheral Interface) Master core. Synchronous serial interfaces are widely used to provide economical board-level interfaces between different devices such as microcontrollers, DACs, ADCs and other. Although there is no single standard for a synchronous serial bus, there are industry-wide accepted guidelines based on two most popular implementations: \u2022 SPI (a trademark of Motorola Semiconductor) \u2022 Microwire/Plus (a trademark of National Semiconductor) Many IC manufacturers produce components that are compatible with SPI and Microwire/Plus. The SPI Master core is compatible with both above-mentioned protocols as master with some additional functionality. At the hosts side, the core acts like a WISHBONE compliant slave device. Features: \u2022 Full duplex synchronous serial data transfer \u2022 Variable length of transfer word up to 32 bits \u2022 MSB or LSB first data transfer \u2022 Rx and Tx on both rising or falling edge of serial clock independently \u2022 8 slave select lines \u2022 Fully static synchronous design with one clock domain \u2022 Technology independent Verilog \u2022 Fully synthesizable OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 2 of 9 2 IO ports 2.1 WISHBONE interface signals Port Width Direction Description wb_clk_i 1 Input Master clock wb_rst_i 1 Input Synchronous reset, active high wb_adr_i 5 Input Lower address bits wb_dat_i 32 Input Data towards the core wb_dat_o 32 Output Data from the core wb_sel_i 4 Input Byte select signals wb_we_i 1 Input Write enable input wb_stb_i 1 Input Strobe signal/Core select input wb_cyc_i 1 Input Valid bus cycle input wb_ack_o 1 Output Bus cycle acknowledge output wb_err_o 1 Output Bus cycle error output wb_int_o 1 Output Interrupt signal output Table 1: Wishbone interface signals All output WISHBONE signals are registered and driven on the rising edge of wb_clk_i. All input WISHBONE signals are latched on the rising edge of wb_clk_i. 2.2 SPI external connections Port Width Direction Description /ss_pad_o 8 Output Slave select output signals sclk_pad_o 1 Output Serial clock output mosi_pad_o 1 Output Master out slave in data signal output miso_pad_i 1 Input Master in slave out data signal input\nGenerate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=0 and CPHA=1. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out );\n",
    "answer_2": "```systemverilog\n// -----------------------------------------------------------------------------\n// Simple SPI MASTER driver (Mode-1 : CPOL = 0 , CPHA = 1)\n//    \u2011 Idle value of SCLK  : \u20180\u2019\n//    \u2011 First edge (after EN asserted) is a rising edge\n//    \u2011 MOSI is changed on every rising edge\n//    \u2011 MISO is sampled   on every falling edge\n//\n// NOTES\n//   \u2022 Parameter CLK_DIV lets you generate a slower serial clock:\n//         f_SPI = f_clk / (2*CLK_DIV)\n//   \u2022 SPI_EN is driven active-low while a transfer is in progress.\n// -----------------------------------------------------------------------------\nmodule SPI_driver #(\n    parameter integer CLK_DIV = 4                // \u22652, even division of clk\n)(\n    input  logic        clk,                     // system clock\n    input  logic        rst,                     // synchronous reset, active-high\n    input  logic [7:0]  data_in,                 // byte to transmit\n    input  logic        SPI_MISO,                // serial data from the slave\n    input  logic        SPI_start,               // 1-clk-wide start pulse\n    output logic        SPI_MOSI,                // serial data to the slave\n    output logic        SPI_CLK,                 // serial clock (CPOL=0)\n    output logic        SPI_EN,                  // active-low slave-select\n    output logic [7:0]  data_out                 // byte just received\n);\n\n    // ---------------------------------------------------------\n    // Local registers / wires\n    // ---------------------------------------------------------\n    typedef enum logic [1:0] {IDLE, ASSERT_SS, TRANSFER, DONE} state_t;\n    state_t          state, next_state;\n\n    logic [$clog2(CLK_DIV)-1:0] clk_cnt;         // clock divider counter\n    logic                        clk_edge;       // 1-clk-wide tick every half SPI period\n    logic  [7:0]                 tx_shift;       // transmit shift-register\n    logic  [7:0]                 rx_shift;       // receive  shift-register\n    logic  [2:0]                 bit_cnt;        // counts 0->7 bits transferred\n    logic                        sclk_int;       // internal SCLK signal\n\n    // ---------------------------------------------------------\n    // Clock Divider : generates `clk_edge`\n    // ---------------------------------------------------------\n    always_ff @(posedge clk) begin\n        if (rst) begin\n            clk_cnt  <= '0;\n            clk_edge <= 1'b0;\n        end\n        else begin\n            if (state == TRANSFER) begin\n                if (clk_cnt == (CLK_DIV-1)) begin        // reached half period\n                    clk_cnt  <= '0;\n                    clk_edge <= 1'b1;\n                end else begin\n                    clk_cnt  <= clk_cnt + 1'b1;\n                    clk_edge <= 1'b0;\n                end\n            end\n            else begin\n                clk_cnt  <= '0;\n                clk_edge <= 1'b0;\n            end\n        end\n    end\n\n    // ---------------------------------------------------------\n    // FSM : controls the whole transaction\n    // ---------------------------------------------------------\n    always_ff @(posedge clk) begin\n        if (rst)\n            state <= IDLE;\n        else\n            state <= next_state;\n    end\n\n    always_comb begin\n        next_state = state;\n        unique case (state)\n            IDLE :       if (SPI_start)            next_state = ASSERT_SS;\n            ASSERT_SS:   next_state = TRANSFER;     // one half-period of SCLK still low\n            TRANSFER:    if ((bit_cnt == 3'd7) &&  // last bit done after two edges\n                           (clk_edge && (sclk_int==1'b0)))\n                           next_state = DONE;\n            DONE:        next_state = IDLE;\n            default:     next_state = IDLE;\n        endcase\n    end\n\n    // ---------------------------------------------------------\n    // Shift registers & counters\n    // ---------------------------------------------------------\n    always_ff @(posedge clk) begin\n        if (rst) begin\n            tx_shift <= 8'h00;\n            rx_shift <= 8'h00;\n            bit_cnt  <= 3'd0;\n        end\n        else begin\n            case (state)\n                IDLE : begin\n                    bit_cnt  <= 3'd0;\n                    if (SPI_start)\n                        tx_shift <= data_in;       // preload tx data\n                end\n\n                ASSERT_SS : begin\n                    // keep counters cleared, wait for first rising edge\n                    bit_cnt <= 3'd0;\n                end\n\n                TRANSFER : begin\n                    if (clk_edge) begin\n                        // Rising edge : drive next MOSI bit\n                        if (sclk_int == 1'b0) begin   // just rose to '1'\n                            SPI_MOSI <= tx_shift[7];\n                            tx_shift  <= {tx_shift[6:0],1'b0};\n                        end\n                        // Falling edge : sample MISO, count bit\n                        else begin\n                            rx_shift <= {rx_shift[6:0], SPI_MISO};\n                            bit_cnt  <= bit_cnt + 1'b1;\n                        end\n                    end\n                end\n\n                default : ;   // DONE / others\n            endcase\n        end\n    end\n\n    // ---------------------------------------------------------\n    // SCLK generation : toggles on every `clk_edge` in TRANSFER\n    // ---------------------------------------------------------\n    always_ff @(posedge clk) begin\n        if (rst)\n            sclk_int <= 1'b0;          // CPOL = 0 -> idle low\n        else if (state == TRANSFER && clk_edge)\n            sclk_int <= ~sclk_int;\n        else if (state == IDLE)\n            sclk_int <= 1'b0;\n    end\n\n    // ---------------------------------------------------------\n    // Outputs\n    // ---------------------------------------------------------\n    assign SPI_CLK = sclk_int;\n    assign SPI_EN  = (state == IDLE) ? 1'b1 : 1'b0;  // active-low\n    assign data_out = (state == DONE) ? rx_shift : data_out;\n\nendmodule\n```",
    "prompt_3": "The SPI Master core consists of three parts shown in the following figure: Serial Interface spi_shift.v Clock generator spi_clgen.v sclk_pad_o OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 9 of 9 Appendix A Core configuration To meet specific system requirements and size constraints on behalf of the core functionality, the SPI Master core can be configuredby setting the appropriate define directives in the spi_defines.v source file. The directives are as follows: SPI_DIVIDER_BIT_NB This parameter defines the maximum number of bits needed for the divider. Set this parameter accordingly to the maximum system frequency and lowest serial clock frequency: \uf8fa \uf8fb\uf8f9 \uf8ef \uf8f0\uf8ee\u2212\u2217= 12log R_BIT_NB SPI_DIVIDE minmax 2 sclksys ff Default value is 16. SPI_MAX_CHAR This parameter defines the maximum number of bits that can be received/transmitted in one transfer. The default value is 32. SPI_SS_NB This parameter defines the number of slave select lines. The default value is 8.\nTable 8: Slave Select register Reset Value: 0x00000000 SS Writing 1 to any bit location of this field sets the proper ss_pad_o line to an active state. OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 6 of 9 4 Operation This core is an SPI and Microwire/Plus compliant synchronous serial controller. At the host side, it is controlled via registers accessible through a WISHBONE rev. B1 interface. 4.1 WISHBONE interface The SPI core has four 32-bit registers through the WISHBONE rev. B1 compatible interface. All accesses to SPI registers must be 32-bit (wb_sel[3:0] = 0xf). Please refer to the WISHBONE specification at http://www.opencores.org/wishbone/specs/wbspec_b1.pdf 4.2 Serial interface The serial interface consists of slave select lines, serial clock lines, as well as input and output data lines. All transfers are full duplex transfers of a programmable number of bits per transfer (up to 32 bits). Compared to the SPI/Microwire protocol, this core has some additional functionality. It can drive data to the output data line in respect to the falling (SPI/Microwire compliant) or rising edge of the serial clock, and it can latch data on an input data line on the rising (SPI/Microwire compliant) or falling edge of a serial clock line. It also can transmit (receive) the MSB first (SPI/Microwire compliant) or the LSB first. It is important to know that the Rx and Tx registers share the same flip-flops, which means that what is received from the input data line in one transfer will be transmitted on the output data line in the next transfer if no write access to the Tx register is executed between the transfers. /ss_pad_o[0] /ss_pad_o[1] /ss_pad_o[2] MASTER sclk_pad_o mosi_pad_o miso pad i MISO MOSI SCLK /SS SLAVE 0 MISO MOSI SCLK / SS SLAVE 1 MISO MOSI SCLK /SS SLAVE 2 WISHBONE MISO MOSI SCLK/SS SLAVE 0 MISO MOSI SCLK/SS SLAVE 1 MISO MOSI SCLK/SS SLAVE 2 WISHBON E /ss_pad_o[0]/ss_pad_o[1]/ss_pad_o[2] MASTER sclk_pad_o mosi_pad_o miso _pad_iOpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 7 of 9 ss_pad_o mosi_pad_o miso_pad_i CTRL[LSB] = 0, CTRL[CHAR_LEN] = 0x08, CTRL[TX_NEG] = 1, CTRL[RX_NEG] = 0 LSB (Tx[0])ss_pad_o mosi_pad_o miso_pad_i CTRL[LSB] = 1, CTRL[CHAR_LEN] = 0x0a, CTRL[TX_NEG] = 0, CTRL[RX_NEG] = 1 MSB (Tx[9]) MSB (Tx[7]) MSB (Rx[7])LSB (Tx[0]) LSB (Rx[0]) LSB (Rx[0])MSB (Rx[9]) sclk_pad_o sclk_pad_o OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 8 of 9 WHISHBONE SOC Bus WHISHBONE Interface spi_top.v ss_pad_o mosi_pad_o miso_pad_i 5 Architecture The SPI Master core consists of three parts shown in the following figure: Serial Interface spi_shift.v Clock generator spi_clgen.v sclk_pad_o OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 9 of 9 Appendix A Core configuration To meet specific system requirements and size constraints on behalf of the core functionality, the SPI Master core can be configuredby setting the appropriate define directives in the spi_defines.v source file. The directives are as follows: SPI_DIVIDER_BIT_NB This parameter defines the maximum number of bits needed for the divider. Set this parameter accordingly to the maximum system frequency and lowest serial clock frequency: \uf8fa\nSPI Master Core Specification Author: Simon Srot simons@opencores.org Rev. 0.2 July 12, 2002 OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.1 i Revision History Rev. Date Author Description 0.1 June 13, 2002 Simon Srot First Draft 0.2 July 12, 2002 Simon Srot Document is lectured. OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.1 ii Contents CONTENTS.......................................................................................................... II INTRODUCTION................................................................................................. 1 IO PORTS.............................................................................................................. 2 2.1 WISHBONE INTERFACE SIGNALS ................................................................. 2 2.2 SPI EXTERNAL CONNECTIONS ........................................................................ 2 REGISTERS.......................................................................................................... 3 3.1 C ORE REGISTERS LIST .................................................................................... 3 3.2 D ATA RECEIVE REGISTER [RX]....................................................................... 3 3.3 D ATA TRANSMIT REGISTER [TX] .................................................................... 3 3.4 C ONTROL AND STATUS REGISTER [CTRL] ..................................................... 4 3.5 D IVIDER REGISTER [DIVIDER] ..................................................................... 5 3.6 S LAVE SELECT REGISTER [SS]........................................................................ 5 OPERATION......................................................................................................... 6 4.1 WISHBONE INTERFACE ............................................................................... 6 4.2 S ERIAL INTERFACE ......................................................................................... 6 ARCHITECTURE ................................................................................................ 8 CORE CONFIGURATION ................................................................................. 9 OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 1 of 9 1 Introduction This document provides specifications for the SPI (Serial Peripheral Interface) Master core. Synchronous serial interfaces are widely used to provide economical board-level interfaces between different devices such as microcontrollers, DACs, ADCs and other. Although there is no single standard for a synchronous serial bus, there are industry-wide accepted guidelines based on two most popular implementations: \u2022 SPI (a trademark of Motorola Semiconductor) \u2022 Microwire/Plus (a trademark of National Semiconductor) Many IC manufacturers produce components that are compatible with SPI and Microwire/Plus. The SPI Master core is compatible with both above-mentioned protocols as master with some additional functionality. At the hosts side, the core acts like a WISHBONE compliant slave device. Features: \u2022 Full duplex synchronous serial data transfer \u2022 Variable length of transfer word up to 32 bits \u2022 MSB or LSB first data transfer \u2022 Rx and Tx on both rising or falling edge of serial clock independently \u2022 8 slave select lines \u2022 Fully static synchronous design with one clock domain \u2022 Technology independent Verilog \u2022 Fully synthesizable OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 2 of 9 2 IO ports 2.1 WISHBONE interface signals Port Width Direction Description wb_clk_i 1 Input Master clock wb_rst_i 1 Input Synchronous reset, active high wb_adr_i 5 Input Lower address bits wb_dat_i 32 Input Data towards the core wb_dat_o 32 Output Data from the core wb_sel_i 4 Input Byte select signals wb_we_i 1 Input Write enable input wb_stb_i 1 Input Strobe signal/Core select input wb_cyc_i 1 Input Valid bus cycle input wb_ack_o 1 Output Bus cycle acknowledge output wb_err_o 1 Output Bus cycle error output wb_int_o 1 Output Interrupt signal output Table 1: Wishbone interface signals All output WISHBONE signals are registered and driven on the rising edge of wb_clk_i. All input WISHBONE signals are latched on the rising edge of wb_clk_i. 2.2 SPI external connections Port Width Direction Description /ss_pad_o 8 Output Slave select output signals sclk_pad_o 1 Output Serial clock output mosi_pad_o 1 Output Master out slave in data signal output miso_pad_i 1 Input Master in slave out data signal input\nGenerate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=0 and CPHA=0. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out );\n",
    "answer_3": "```systemverilog\n//---------------------------------------------------------------\n// Simple SPI-MASTER driver (MODE-0: CPOL=0, CPHA=0)\n// \u2022 Sends 8-bit framed data on MOSI and receives 8-bit data\n// \u2022 Programmable serial clock division via CLK_DIV\n//---------------------------------------------------------------\nmodule SPI_driver #(\n    parameter int CLK_DIV = 4         // System-clock cycles per half SCLK period (must be >1)\n)(\n    input  logic        clk,          // System clock\n    input  logic        rst,          // Active-high synchronous reset\n    input  logic [7:0]  data_in,      // Byte to transmit\n    input  logic        SPI_MISO,     // Serial data from slave\n    input  logic        SPI_start,    // 1-pulse: start new transfer\n    output logic        SPI_MOSI,     // Serial data to slave\n    output logic        SPI_CLK,      // Serial clock to slave (MODE-0)\n    output logic        SPI_EN,       // Active-low chip-select (/SS)\n    output logic [7:0]  data_out      // Byte just received\n);\n\n    // ----------------------------------------------------------\n    // Local types / constants\n    // ----------------------------------------------------------\n    typedef enum logic [1:0] {IDLE, LOAD, TRANSFER, DONE} state_t;\n\n    // ----------------------------------------------------------\n    // Registers / wires\n    // ----------------------------------------------------------\n    state_t     state,  nxt_state;\n\n    logic [7:0] shifter_tx;           // Shift register (outgoing)\n    logic [7:0] shifter_rx;           // Shift register (incoming)\n\n    logic [2:0] bit_cnt;              // Counts 7..0\n    logic [$clog2(CLK_DIV)-1:0] div_cnt;   // SCLK divider counter\n    logic       sclk_int;             // Internal SCLK before CPOL addition\n    logic       sclk_rise;            // 1-clk pulse on SCLK rising edge\n    logic       sclk_fall;            // 1-clk pulse on SCLK falling edge\n\n    // ----------------------------------------------------------\n    // Divider : generate internal SCLK (50 % duty)\n    // ----------------------------------------------------------\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            div_cnt  <= '0;\n            sclk_int <= 1'b0;\n        end\n        else if (state == TRANSFER) begin\n            if (div_cnt == CLK_DIV-1) begin\n                div_cnt  <= '0;\n                sclk_int <= ~sclk_int;\n            end\n            else\n                div_cnt <= div_cnt + 1'b1;\n        end\n        else begin\n            div_cnt  <= '0;\n            sclk_int <= 1'b0;  // Idle low (CPOL=0)\n        end\n    end\n\n    // Detect internal SCLK edges (for sampling / driving)\n    assign sclk_rise = (state == TRANSFER) && (div_cnt == CLK_DIV-1) && (sclk_int == 1'b0);\n    assign sclk_fall = (state == TRANSFER) && (div_cnt == CLK_DIV-1) && (sclk_int == 1'b1);\n\n    // ----------------------------------------------------------\n    // FSM : controls sequencing of a single 8-bit frame\n    // ----------------------------------------------------------\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            state <= IDLE;\n        else\n            state <= nxt_state;\n    end\n\n    always_comb begin\n        nxt_state = state;\n        case (state)\n            IDLE   : if (SPI_start)    nxt_state = LOAD;\n            LOAD   :                  nxt_state = TRANSFER;\n            TRANSFER:\n                     if ((bit_cnt == 3'd0) && sclk_rise)\n                                          nxt_state = DONE;\n            DONE   :                  nxt_state = IDLE;\n        endcase\n    end\n\n    // ----------------------------------------------------------\n    // Bit counter\n    // ----------------------------------------------------------\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            bit_cnt <= 3'd7;\n        else if (state == LOAD)\n            bit_cnt <= 3'd7;\n        else if (state == TRANSFER && sclk_rise)\n            bit_cnt <= bit_cnt - 1'b1;\n    end\n\n    // ----------------------------------------------------------\n    // Shift-registers : transmit on falling edge, receive on rising edge\n    // ----------------------------------------------------------\n    // Transmit path (MOSI) ------------------------------------\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            shifter_tx <= '0;\n        else if (state == LOAD)\n            shifter_tx <= data_in;\n        else if (state == TRANSFER && sclk_fall)\n            shifter_tx <= {shifter_tx[6:0], 1'b0};  // Shift left, MSB first\n    end\n    assign SPI_MOSI = shifter_tx[7];     // Drive MSB when CPHA=0\n\n    // Receive path (MISO) -------------------------------------\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            shifter_rx <= '0;\n        else if (state == LOAD)\n            shifter_rx <= '0;\n        else if (state == TRANSFER && sclk_rise)\n            shifter_rx <= {shifter_rx[6:0], SPI_MISO}; // Sample at rising edge\n    end\n\n    // ----------------------------------------------------------\n    // Data-out latch\n    // ----------------------------------------------------------\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            data_out <= '0;\n        else if (state == DONE)\n            data_out <= shifter_rx;\n    end\n\n    // ----------------------------------------------------------\n    // SPI control outputs\n    // ----------------------------------------------------------\n    assign SPI_CLK = sclk_int;           // CPOL=0   (idle low)\n    assign SPI_EN  = (state == TRANSFER || state == LOAD) ? 1'b0  // active-low\n                                                          : 1'b1; // de-asserted otherwise\nendmodule\n```"
}
