{
    "prompt_0": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=1 and CPHA=1. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out ); Please return code only. No sure here, or any text. ",
    "answer_0": "```systemverilog\nmodule SPI_driver (\n    input  logic        clk,\n    input  logic        rst,\n    input  logic [7:0]  data_in,\n    input  logic        SPI_MISO,\n    input  logic        SPI_start,\n    output logic        SPI_MOSI,\n    output logic        SPI_CLK,\n    output logic        SPI_EN,\n    output logic [7:0]  data_out\n);\n\n    // SPI Mode Parameters: CPOL=1, CPHA=1\n    localparam CPOL = 1;\n    localparam CPHA = 1;\n\n    // FSM States\n    typedef enum logic [1:0] {\n        S_IDLE,\n        S_TRANSFER,\n        S_DONE\n    } state_t;\n\n    // Internal Registers\n    state_t     state_reg, state_next;\n    logic [7:0] tx_reg, tx_reg_next;\n    logic [7:0] rx_reg, rx_reg_next;\n    logic [3:0] edge_count_reg, edge_count_next;\n    logic       spi_clk_internal;\n\n    // Sequential Logic (Registers)\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state_reg      <= S_IDLE;\n            tx_reg         <= 8'h00;\n            rx_reg         <= 8'h00;\n            edge_count_reg <= 4'd0;\n            SPI_EN         <= 1'b1;\n            data_out       <= 8'h00;\n        end else begin\n            state_reg      <= state_next;\n            tx_reg         <= tx_reg_next;\n            rx_reg         <= rx_reg_next;\n            edge_count_reg <= edge_count_next;\n\n            // Register outputs to avoid glitches\n            if (state_next == S_IDLE) begin\n                SPI_EN <= 1'b1;\n            end else if (state_reg == S_IDLE && state_next == S_TRANSFER) begin\n                SPI_EN <= 1'b0;\n            end\n\n            if (state_next == S_DONE) begin\n                data_out <= rx_reg_next;\n            end\n        end\n    end\n\n    // Combinational Logic (Next State and Outputs)\n    always_comb begin\n        // Default assignments to avoid latches\n        state_next      = state_reg;\n        tx_reg_next     = tx_reg;\n        rx_reg_next     = rx_reg;\n        edge_count_next = edge_count_reg;\n        \n        // Default MOSI output is the current MSB of the transmit register\n        SPI_MOSI = tx_reg[7];\n\n        case (state_reg)\n            S_IDLE: begin\n                if (SPI_start) begin\n                    state_next      = S_TRANSFER;\n                    tx_reg_next     = data_in;\n                    rx_reg_next     = 8'h00;\n                    // Start counting 16 edges (8 clock cycles)\n                    edge_count_next = 4'd15;\n                end\n            end\n\n            S_TRANSFER: begin\n                // Decrement edge counter on each system clock cycle\n                edge_count_next = edge_count_reg - 1;\n\n                // For CPOL=1, CPHA=1:\n                // Idle clock is High.\n                // Leading edge is Low-to-High. Data is changed here.\n                // Trailing edge is High-to-Low. Data is sampled here.\n                \n                // The internal SPI clock is high for even edge counts (14, 12, ... 0)\n                // and low for odd edge counts (15, 13, ... 1).\n                // This logic determines the action based on the *upcoming* clock edge.\n                \n                // If edge_count is odd, next clock state is low (trailing edge H->L)\n                if (edge_count_reg[0] == 1'b1) begin \n                    // Sample MISO on the trailing edge\n                    rx_reg_next = {rx_reg[6:0], SPI_MISO};\n                end\n                // If edge_count is even, next clock state is high (leading edge L->H)\n                else begin \n                    // Change MOSI on the leading edge by shifting the register\n                    tx_reg_next = {tx_reg[6:0], 1'b0};\n                end\n\n                // After the last edge (count reaches 0), move to DONE state\n                if (edge_count_reg == 4'd0) begin\n                    state_next = S_DONE;\n                end\n            end\n\n            S_DONE: begin\n                // Transition back to IDLE on the next clock cycle\n                state_next = S_IDLE;\n            end\n\n            default: begin\n                state_next = S_IDLE;\n            end\n        endcase\n    end\n\n    // SPI Clock Generation\n    // In IDLE/DONE state, clock is held at CPOL value (1)\n    // In TRANSFER state, clock toggles. It's high on even counts, low on odd counts.\n    assign spi_clk_internal = (state_reg == S_TRANSFER) ? ~edge_count_reg[0] : CPOL;\n    assign SPI_CLK = spi_clk_internal;\n\nendmodule\n```",
    "prompt_1": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=1 and CPHA=0. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out ); Please return code only. No sure here, or any text. ",
    "answer_1": "```systemverilog\n//\n// Generated by AI Assistant\n//\n// SPI Master Driver\n//\n// Parameters:\n// - CPOL (Clock Polarity) = 1\n// - CPHA (Clock Phase) = 0\n//\n// Description:\n// - CPOL=1: SPI Clock (SPI_CLK) is HIGH when idle.\n// - CPHA=0: Data is sampled on the leading (first) clock edge and\n//           changed on the trailing (second) clock edge.\n// - For CPOL=1, the leading edge is High-to-Low, and the trailing edge\n//   is Low-to-High.\n//\n// Transaction Sequence (CPOL=1, CPHA=0):\n// 1. SPI_EN goes LOW to select the slave.\n// 2. Master places the first bit on SPI_MOSI.\n// 3. SPI_CLK goes LOW (leading edge). Master samples SPI_MISO.\n// 4. SPI_CLK goes HIGH (trailing edge). Master changes SPI_MOSI to the next bit.\n// 5. Steps 3-4 repeat for all 8 bits.\n// 6. SPI_EN goes HIGH to deselect the slave.\n//\n\nmodule SPI_driver(\n    input logic clk,\n    input logic rst,\n    input logic [7:0] data_in,\n    input logic SPI_MISO,\n    input logic SPI_start,\n    output logic SPI_MOSI,\n    output logic SPI_CLK,\n    output logic SPI_EN,\n    output logic [7:0] data_out\n);\n\n    // Parameter for SPI clock generation.\n    // SPI_CLK frequency will be clk / (2 * CLK_DIV).\n    // Example: If clk is 100MHz and CLK_DIV is 4, SPI_CLK is 12.5MHz.\n    parameter CLK_DIV = 4;\n\n    // Internal state machine definition\n    typedef enum logic [2:0] {\n        S_IDLE,\n        S_PREPARE,\n        S_TRANSFER_LEAD,  // Leading Edge phase: H->L, Sample MISO\n        S_TRANSFER_TRAIL, // Trailing Edge phase: L->H, Change MOSI\n        S_DONE\n    } state_t;\n\n    state_t state, next_state;\n\n    // Internal registers for data handling and counters\n    logic [7:0] tx_reg;\n    logic [7:0] rx_reg;\n    logic [2:0] bit_count;\n    logic [$clog2(CLK_DIV)-1:0] clk_count;\n\n    // State Register: Sequential logic for state transitions\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= S_IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next State Logic: Combinational logic to determine the next state\n    always_comb begin\n        next_state = state;\n        case (state)\n            S_IDLE: begin\n                if (SPI_start) begin\n                    next_state = S_PREPARE;\n                end\n            end\n            S_PREPARE: begin\n                // This state ensures MOSI is set up before the first clock edge\n                next_state = S_TRANSFER_LEAD;\n            end\n            S_TRANSFER_LEAD: begin\n                // Wait for CLK_DIV cycles before moving\n to the trailing edge\n                if (clk_count == CLK_DIV - 1) begin\n                    next_state = S_TRANSFER_TRAIL;\n                end\n            end\n            S_TRANSFER_TRAIL: begin\n                // Wait for CLK_DIV cycles before moving to the next bit or finishing\n                if (clk_count == CLK_DIV - 1) begin\n                    if (bit_count == 3'd7) begin\n                        next_state = S_DONE; // All 8 bits transferred\n                    end else begin\n                        next_state = S_TRANSFER_LEAD; // Go to next bit\n                    end\n                end\n            end\n            S_DONE: begin\n                // Cleanup state, then return to idle\n                next_state = S_IDLE;\n            end\n        endcase\n    end\n\n    // Output and Datapath Logic: Sequential logic for outputs and internal registers\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all outputs and internal registers to a known state\n            SPI_EN      <= 1'b1;\n            SPI_CLK     <= 1'b1; // CPOL=1: idle is high\n            SPI_MOSI    <= 1'b0;\n            data_out    <= '0;\n            tx_reg      <= '0;\n            rx_reg      <= '0;\n            bit_count   <= '0;\n            clk_count   <= '0;\n        end else begin\n            // Default action for the clock divider counter\n            clk_count <= clk_count + 1;\n\n            case (state)\n                S_IDLE: begin\n                    SPI_EN      <= 1'b1;\n                    SPI_CLK     <= 1'b1; // Maintain idle high\n                    bit_count   <= '0;\n                    clk_count   <= '0;\n                    data_out    <= rx_reg; // Make the last received data available\n\n                    if (SPI_start) begin\n                        // Latch the input data to be transmitted\n                        tx_reg <= data_in;\n                    end\n                end\n\n                S_PREPARE: begin\n                    // Start the SPI transaction\n                    SPI_EN <= 1'b0; // Assert chip enable\n                    // CPHA=0: Data must be valid before the first clock edge.\n                    // Set the first bit (MSB) on the MOSI line.\n                    SPI_MOSI <= tx_reg[7];\n                    clk_count <= '0; // Reset clock divider for the first phase\n                end\n\n                S_TRANSFER_LEAD: begin\n                    // Leading Edge Phase (High -> Low)\n                    SPI_CLK <= 1'b0;\n                    // Sample MISO on the first cycle of this phase\n                    if (clk_count == 0) begin\n                        rx_reg <= {rx_reg[6:0], SPI_MISO};\n                    end\n                    // Reset clock divider when phase is complete\n                    if (clk_count == CLK_DIV - 1) begin\n                        clk_count <= '0;\n                    end\n                end\n\n                S_TRANSFER_TRAIL: begin\n                    // Trailing Edge Phase (Low -> High)\n                    SPI_CLK <= 1'b1;\n                    // Change MOSI on the first cycle of this phase\n                    if (clk_count == 0) begin\n                        // Shift transmit register to get the next bit\n                        tx_reg <= tx_reg << 1;\n                        // The new bit to send is what was at index 6 before the shift\n                        SPI_MOSI <= tx_reg[6];\n                    end\n                    // When phase is complete, increment bit counter and reset clock divider\n                    if (clk_count == CLK_DIV - 1) begin\n                        bit_count <= bit_count + 1;\n                        clk_count <= '0;\n                    end\n                end\n\n                S_DONE: begin\n                    // End the transaction\n                    SPI_EN <= 1'b1; // De-assert chip enable\n                    SPI_CLK <= 1'b1; // Return clock to idle state\n                    // The last bit was sampled in the final S_TRANSFER_LEAD state.\n                    // rx_reg is now complete and will be assigned to data_out in S_IDLE.\n                end\n            endcase\n        end\n    end\n\nendmodule\n\n```",
    "prompt_2": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=0 and CPHA=1. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out ); Please return code only. No sure here, or any text. ",
    "answer_2": "```systemverilog\nmodule SPI_driver (\n    input logic clk,\n    input logic rst,\n    input logic [7:0] data_in,\n    input logic SPI_MISO,\n    input logic SPI_start,\n    output logic SPI_MOSI,\n    output logic SPI_CLK,\n    output logic SPI_EN,\n    output logic [7:0] data_out\n);\n\n    // SPI parameters for Master Mode\n    // CPOL = 0: Clock is idle low\n    // CPHA = 1: Data is sampled on the trailing (falling) edge\n    //           Data is changed on the leading (rising) edge\n    localparam CPOL = 0;\n    localparam CPHA = 1;\n\n    // State machine definition\n    typedef enum logic [1:0] {\n        S_IDLE,\n        S_TRANSFER,\n        S_DONE\n    } state_t;\n\n    state_t state, next_state;\n\n    // Internal registers\n    logic [7:0] tx_reg;      // Transmit shift register\n    logic [7:0] rx_reg;      // Receive shift register\n    logic [3:0] bit_count;   // Counts bits transferred (0 to 8)\n\n    // State register - clocked process\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= S_IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    // Next state logic - combinational process\n    always_comb begin\n        next_state = state;\n        case (state)\n            S_IDLE: begin\n                if (SPI_start) begin\n                    next_state = S_TRANSFER;\n                end\n            end\n            S_TRANSFER: begin\n                // A full SPI clock cycle takes 2 system clock cycles.\n                // We transition out after 8 full SPI cycles (16 system clock cycles).\n                // We use a bit counter that increments on the falling edge of SPI_CLK.\n                if (bit_count == 8) begin\n                    next_state = S_DONE;\n                end\n            end\n            S_DONE: begin\n                next_state = S_IDLE;\n            end\n        endcase\n    end\n\n    // Main sequential logic for data path and outputs\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            SPI_EN <= 1'b1;\n            SPI_CLK <= CPOL;\n            SPI_MOSI <= 1'b0;\n            data_out <= 8'h00;\n            tx_reg <= 8'h00;\n            rx_reg <= 8'h00;\n            bit_count <= 4'd0;\n        end else begin\n            case (state)\n                S_IDLE: begin\n                    SPI_EN <= 1'b1;      // De-assert slave select\n                    SPI_CLK <= CPOL;     // Clock is idle\n                    bit_count <= 4'd0;\n                    if (SPI_start) begin\n                        SPI_EN <= 1'b0;      // Assert slave select\n                        tx_reg <= data_in;   // Load data to transmit\n                        SPI_MOSI <= data_in[7]; // Pre-load MSB for the first clock edge\n                    end\n                end\n\n                S_TRANSFER: begin\n                    // Generate SPI clock at half the system clock frequency\n                    SPI_CLK <= ~SPI_CLK;\n\n                    // CPHA=1: Change on leading edge, sample on trailing edge\n                    // For CPOL=0, leading is rising, trailing is falling.\n                    // The SPI_CLK value has just been updated for the *current* cycle.\n                    // When SPI_CLK is 1, it's a rising edge. When it's 0, it's a falling edge.\n\n                    if (SPI_CLK == 1'b1) begin // Just rose from 0 to 1\n                        // Change data on MOSI\n                        // The bit to be transmitted was already set on the previous state change\n                        // or the previous falling edge. Now we shift the register to prepare the next bit.\n                        if (bit_count < 7) begin\n                           SPI_MOSI <= tx_reg[6 - bit_count];\n                        end\n                    end else begin // Just fell from 1 to 0\n                        // Sample data from MISO\n                        rx_reg <= {rx_reg[6:0], SPI_MISO};\n                        bit_count <= bit_count + 1;\n                    end\n                end\n\n                S_DONE: begin\n                    SPI_EN <= 1'b1;      // De-assert slave select\n                    SPI_CLK <= CPOL;     // Return clock to idle state\n                    data_out <= rx_reg;  // Output the received data\n                    bit_count <= 4'd0;   // Reset bit counter for next transaction\n                end\n            endcase\n        end\n    end\n\nendmodule\n```",
    "prompt_3": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=0 and CPHA=0. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out ); Please return code only. No sure here, or any text. ",
    "answer_3": "```systemverilog\nmodule SPI_driver(\n    input logic clk,\n    input logic rst,\n    input logic [7:0] data_in,\n    input logic SPI_MISO,\n    input logic SPI_start,\n    output logic SPI_MOSI,\n    output logic SPI_CLK,\n    output logic SPI_EN,\n    output logic [7:0] data_out\n);\n\n    // Parameter for SPI clock generation.\n    // The generated SPI_CLK frequency will be the system clk frequency\n    // divided by CLK_DIVIDER. For a 50% duty cycle, CLK_DIVIDER must be even.\n    // Example: clk=50MHz, SPI_CLK=1MHz => CLK_DIVIDER = 50\n    parameter CLK_DIVIDER = 8;\n\n    // Internal state machine definition\n    typedef enum logic [1:0] { S_IDLE, S_TRANSFER, S_CLEANUP } state_t;\n    state_t state;\n\n    // Internal registers for data shifting and counters\n    logic [$clog2(CLK_DIVIDER)-1:0] clk_div_cnt;\n    logic [2:0] bit_cnt;\n    logic [7:0] tx_reg;\n    logic [7:0] rx_reg;\n    logic [7:0] data_out_reg;\n\n    // Single process for state machine and data path logic\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all signals and registers to a known default state\n            state <= S_IDLE;\n            SPI_EN <= 1'b1;\n            SPI_MOSI <= 1'b0;\n            SPI_CLK <= 1'b0; // For CPOL=0, idle clock is low\n            data_out_reg <= 8'h00;\n            clk_div_cnt <= 0;\n            bit_cnt <= 0;\n            tx_reg <= 8'h00;\n            rx_reg <= 8'h00;\n        end else begin\n            case (state)\n                S_IDLE: begin\n                    // In idle state, keep outputs at their inactive levels\n                    SPI_EN <= 1'b1;\n                    SPI_CLK <= 1'b0;\n                    // Reset counters for the next transaction\n                    bit_cnt <= 0;\n                    clk_div_cnt <= 0;\n\n                    // Wait for the start signal\n                    if (SPI_start) begin\n                        // Load input data into the transmit register\n                        tx_reg <= data_in;\n                        // Assert the slave enable (active low)\n                        SPI_EN <= 1'b0;\n                        // For CPHA=0, the first bit must be on MOSI before the first clock edge\n                        SPI_MOSI <= data_in[7];\n                        // Move to the transfer state\n                        state <= S_TRANSFER;\n                    end\n                end\n\n                S_TRANSFER: begin\n                    // Increment the clock divider counter on every system clock cycle\n                    clk_div_cnt <= clk_div_cnt + 1;\n\n                    // SPI Clock Generation (CPOL=0)\n                    // Clock is low for the first half of the period, high for the second half.\n                    if (clk_div_cnt < (CLK_DIVIDER / 2)) begin\n                        SPI_CLK <= 1'b0;\n                    end else begin\n                        SPI_CLK <= 1'b1;\n                    end\n\n                    // CPHA=0: Data is sampled on the rising edge and changed on the falling edge.\n                    // Rising edge occurs when clk_div_cnt transitions to CLK_DIVIDER/2.\n                    // We check for the cycle just before this transition.\n                    if (clk_div_cnt == (CLK_DIVIDER / 2) - 1) begin\n                        // Sample the MISO line into the receive shift register\n                        rx_reg <= {rx_reg[6:0], SPI_MISO};\n                    end\n\n                    // Falling edge occurs when clk_div_cnt wraps around from CLK_DIVIDER-1 to 0.\n                    // We check for the last cycle of the period.\n                    if (clk_div_cnt == CLK_DIVIDER - 1) begin\n                        // Increment the bit counter after a full SPI clock cycle\n                        bit_cnt <= bit_cnt + 1;\n\n                        // Check if all 8 bits have been transferred\n                        if (bit_cnt == 3'd7) begin\n                            // If done, move to the cleanup state\n                            state <= S_CLEANUP;\n                        end else begin\n                            // If not done, drive the next bit onto the MOSI line.\n                            // The bit_cnt has not updated yet, so we use its current value\n                            // to index the next bit.\n                            SPI_MOSI <= tx_reg[6 - bit_cnt];\n                        end\n                        // Reset the clock divider for the next SPI clock cycle\n                        clk_div_cnt <= 0;\n                    end\n                end\n\n                S_CLEANUP: begin\n                    // De-assert the slave enable to end the transaction\n                    SPI_EN <= 1'b1;\n                    // Ensure the clock returns to its idle state\n                    SPI_CLK <= 1'b0;\n                    // Latch the fully received data into the output register\n                    data_out_reg <= rx_reg;\n                    // Return to the idle state to wait for the next transaction\n                    state <= S_IDLE;\n                end\n\n                default: begin\n                    state <= S_IDLE;\n                end\n            endcase\n        end\n    end\n\n    // Assign the registered output to the final output port\n    assign data_out = data_out_reg;\n\nendmodule\n```"
}
