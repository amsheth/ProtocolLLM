{
    "prompt_0": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=1 and CPHA=1. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out ); Please return code only. No sure here, or any text. ",
    "answer_0": "```systemverilog\nmodule SPI_driver(\n    input logic clk,\n    input logic rst,\n    input logic [7:0] data_in,\n    input logic SPI_MISO,\n    input logic SPI_start,\n    output logic SPI_MOSI,\n    output logic SPI_CLK,\n    output logic SPI_EN,\n    output logic [7:0] data_out\n);\n\n    // Parameters\n    // CLK_DIVIDER determines the SPI_CLK frequency relative to the system clk.\n    // SPI_CLK period = 2 * CLK_DIVIDER * clk_period.\n    // For example, if CLK_DIVIDER = 4, SPI_CLK period is 8 clk cycles.\n    parameter CLK_DIVIDER = 4; \n\n    // State definitions for the FSM\n    typedef enum logic [2:0] {\n        IDLE,               // Waiting for a new transfer to start\n        START_TRANSFER,     // Initialize transfer, assert SPI_EN, set first MOSI bit\n        SHIFT_FALLING_EDGE, // Generate falling edge of SPI_CLK, MOSI is stable\n        SHIFT_RISING_EDGE,  // Generate rising edge of SPI_CLK, sample MISO\n        END_TRANSFER        // De-assert SPI_EN, return to idle state\n    } spi_state_e;\n\n    spi_state_e current_state, next_state;\n\n    // Internal registers for data, bit count, and clock generation\n    logic [7:0] data_in_reg;    // Latched input data to be transmitted\n    logic [7:0] data_out_reg;   // Received data\n    logic [2:0] bit_count;      // Counter for the 8 bits (0 to 7)\n    logic [($clog2(CLK_DIVIDER)-1):0] clk_cnt; // Counter for generating SPI_CLK edges\n\n    // Internal registers for SPI signals\n    logic spi_clk_reg;  // Internal register for SPI_CLK (CPOL=1, CPHA=1)\n    logic spi_en_reg;   // Internal register for SPI_EN (active low)\n    logic spi_mosi_reg; // Internal register for SPI_MOSI\n\n    // Assign internal registers to output ports\n    assign SPI_CLK = spi_clk_reg;\n    assign SPI_EN = spi_en_reg;\n    assign SPI_MOSI = spi_mosi_reg;\n    assign data_out = data_out_reg;\n\n    // State and register updates on positive edge of clk or rst\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            // Reset all registers to their idle/initial states\n            current_state <= IDLE;\n            data_in_reg <= 8'h00;\n            data_out_reg <= 8'h00;\n            bit_count <= 3'h0;\n            clk_cnt <= '0;\n            spi_clk_reg <= 1'b1; // CPOL=1: SPI_CLK idles high\n            spi_en_reg <= 1'b1;  // SPI_EN is active low, so high when idle\n            spi_mosi_reg <= 1'b0; // MOSI default low when idle\n        end else begin\n            current_state <= next_state; // Update current state\n            \n            // Update other registers based on the current state\n            case (current_state)\n                IDLE: begin\n                    spi_en_reg <= 1'b1;  // Ensure SPI_EN is high (inactive)\n                    spi_clk_reg <= 1'b1; // Ensure SPI_CLK is high (idle state for CPOL=1)\n                    spi_mosi_reg <= 1'b0; // MOSI default low\n                    data_out_reg <= 8'h00; // Clear received data\n                    if (SPI_start) begin\n                        data_in_reg <= data_in; // Latch data to be sent\n                    end\n                end\n                START_TRANSFER: begin\n                    spi_en_reg <= 1'b0; // Assert SPI_EN (active low)\n                    spi_clk_reg <= 1'b1; // Keep clock high (CPOL=1)\n                    bit_count <= 3'h0;   // Reset bit counter\n                    clk_cnt <= '0;       // Reset clock divider counter\n                    spi_mosi_reg <= data_in_reg[7]; // Drive MSB of data_in_reg onto MOSI\n                end\n                SHIFT_FALLING_EDGE: begin\n                    if (clk_cnt == CLK_DIVIDER - 1) begin\n                        spi_clk_reg <= 1'b0; // Generate falling edge of SPI_CLK\n                        clk_cnt <= '0;       // Reset clock divider counter\n                    end else begin\n                        clk_cnt <= clk_cnt + 1; // Increment clock divider counter\n                    end\n                    // SPI_MOSI remains stable from previous state/edge\n                end\n                SHIFT_RISING_EDGE: begin\n                    if (clk_cnt == CLK_DIVIDER - 1) begin\n                        spi_clk_reg <= 1'b1; // Generate rising edge of SPI_CLK\n                        // CPHA=1: Sample MISO on the rising edge (first edge of data valid)\n                        data_out_reg <= {data_out_reg[6:0], SPI_MISO}; // Shift in MISO bit\n                        bit_count <= bit_count + 1; // Increment bit counter\n                        clk_cnt <= '0;              // Reset clock divider counter\n                        \n                        // Prepare the next MOSI bit if not all bits are sent\n                        if (bit_count < 7) begin // Check if this was not the last bit (0-7)\n                            spi_mosi_reg <= data_in_reg[7 - (bit_count + 1)]; // Drive next bit\n                        end\n                    end else begin\n                        clk_cnt <= clk_cnt + 1; // Increment clock divider counter\n                    end\n                end\n                END_TRANSFER: begin\n                    spi_en_reg <= 1'b1;  // De-assert SPI_EN (inactive)\n                    spi_clk_reg <= 1'b1; // Return SPI_CLK to idle high\n                    spi_mosi_reg <= 1'b0; // MOSI default low\n                end\n            endcase\n        end\n    end\n\n    // Next state logic (combinational)\n    always_comb begin\n        next_state = current_state; // Default to stay in current state\n        case (current_state)\n            IDLE: begin\n                if (SPI_start) begin\n                    next_state = START_TRANSFER; // Start transfer when SPI_start is high\n                end\n            end\n            START_TRANSFER: begin\n                next_state = SHIFT_FALLING_EDGE; // Immediately move to generate first falling edge\n            end\n            SHIFT_FALLING_EDGE: begin\n                if (clk_cnt == CLK_DIVIDER - 1) begin\n                    next_state = SHIFT_RISING_EDGE; // Move to generate rising edge after falling edge is complete\n                end\n            end\n            SHIFT_RISING_EDGE: begin\n                if (clk_cnt == CLK_DIVIDER - 1) begin\n                    if (bit_count == 7) begin // All 8 bits (0 to 7) have been transferred\n                        next_state = END_TRANSFER; // Move to end the transfer\n                    end else begin\n                        next_state = SHIFT_FALLING_EDGE; // Continue with next bit transfer\n                    end\n                end\n            end\n            END_TRANSFER: begin\n                next_state = IDLE; // Return to idle state after transfer completion\n            end\n        endcase\n    end\n\nendmodule\n```",
    "prompt_1": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=1 and CPHA=0. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out ); Please return code only. No sure here, or any text. ",
    "answer_1": "```systemverilog\nmodule SPI_driver(\n  input logic clk,\n  input logic rst,\n  input logic [7:0] data_in,\n  input logic SPI_MISO,\n  input logic SPI_start,\n  output logic SPI_MOSI,\n  output logic SPI_CLK,\n  output logic SPI_EN,\n  output logic [7:0] data_out\n);\n\n  localparam CPOL = 1;\n  localparam CPHA = 0;\n  localparam BITS = 8;\n  localparam CLK_DIV_MAX = 10;\n\n  typedef enum logic [2:0] {\n    IDLE,\n    START_TX,\n    DRIVE_MOSI_PRE,\n    CLK_EDGE1,\n    CLK_EDGE2,\n    END_TX\n  } spi_state_e;\n\n  spi_state_e current_state, next_state;\n\n  logic s_SPI_MOSI;\n  logic s_SPI_CLK;\n  logic s_SPI_EN;\n  logic [7:0] s_data_out;\n\n  logic [BITS-1:0] tx_data_reg;\n  logic [BITS-1:0] rx_data_reg;\n  logic [$clog2(BITS)-1:0] bit_counter;\n\n  logic [$clog2(CLK_DIV_MAX)-1:0] clk_divider_counter;\n\n  assign SPI_MOSI = s_SPI_MOSI;\n  assign SPI_CLK  = s_SPI_CLK;\n  assign SPI_EN   = s_SPI_EN;\n  assign data_out = s_data_out;\n\n  always_ff @(posedge clk or posedge rst) begin\n    if (rst) begin\n      current_state <= IDLE;\n      s_SPI_MOSI <= 1'b0;\n      s_SPI_CLK <= CPOL;\n      s_SPI_EN <= 1'b1;\n      s_data_out <= 8'h00;\n      tx_data_reg <= 8'h00;\n      rx_data_reg <= 8'h00;\n      bit_counter <= 0;\n      clk_divider_counter <= 0;\n    end else begin\n      current_state <= next_state;\n\n      s_SPI_MOSI <= s_SPI_MOSI;\n      s_SPI_CLK <= s_SPI_CLK;\n      s_SPI_EN <= s_SPI_EN;\n      s_data_out <= s_data_out;\n      tx_data_reg <= tx_data_reg;\n      rx_data_reg <= rx_data_reg;\n      bit_counter <= bit_counter;\n      clk_divider_counter <= clk_divider_counter;\n\n      case (current_state)\n        IDLE: begin\n          s_SPI_EN <= 1'b1;\n          s_SPI_CLK <= CPOL;\n          s_SPI_MOSI <= 1'b0;\n          s_data_out <= 8'h00;\n          clk_divider_counter <= 0;\n          bit_counter <= 0;\n          if (SPI_start) begin\n            next_state <= START_TX;\n          end else begin\n            next_state <= IDLE;\n          end\n        end\n\n        START_TX: begin\n          s_SPI_EN <= 1'b0;\n          tx_data_reg <= data_in;\n          rx_data_reg <= 8'h00;\n          bit_counter <= 0;\n          clk_divider_counter <= 0;\n          next_state <= DRIVE_MOSI_PRE;\n        end\n\n        DRIVE_MOSI_PRE: begin\n          s_SPI_EN <= 1'b0;\n          s_SPI_CLK <= CPOL;\n          s_SPI_MOSI <= tx_data_reg[BITS-1 - bit_counter];\n\n          if (clk_divider_counter == CLK_DIV_MAX - 1) begin\n            clk_divider_counter <= 0;\n            next_state <= CLK_EDGE1;\n          end else begin\n            clk_divider_counter <= clk_divider_counter + 1;\n            next_state <= DRIVE_MOSI_PRE;\n          end\n        end\n\n        CLK_EDGE1: begin\n          s_SPI_EN <= 1'b0;\n          s_SPI_CLK <= ~CPOL;\n\n          if (clk_divider_counter == CLK_DIV_MAX - 1) begin\n            rx_data_reg <= {rx_data_reg[BITS-2:0], SPI_MISO};\n            clk_divider_counter <= 0;\n            next_state <= CLK_EDGE2;\n          end else begin\n            clk_divider_counter <= clk_divider_counter + 1;\n            next_state <= CLK_EDGE1;\n          end\n        end\n\n        CLK_EDGE2: begin\n          s_SPI_EN <= 1'b0;\n          s_SPI_CLK <= CPOL;\n          s_SPI_MOSI <= tx_data_reg[BITS-1 - bit_counter];\n\n          if (clk_divider_counter == CLK_DIV_MAX - 1) begin\n            tx_data_reg <= tx_data_reg << 1;\n            bit_counter <= bit_counter + 1;\n            clk_divider_counter <= 0;\n\n            if (bit_counter == BITS - 1) begin\n              next_state <= END_TX;\n            end else begin\n              next_state <= DRIVE_MOSI_PRE;\n            end\n          end else begin\n            clk_divider_counter <= clk_divider_counter + 1;\n            next_state <= CLK_EDGE2;\n          end\n        end\n\n        END_TX: begin\n          s_SPI_EN <= 1'b1;\n          s_SPI_CLK <= CPOL;\n          s_data_out <= rx_data_reg;\n          next_state <= IDLE;\n        end\n\n        default: begin\n          next_state <= IDLE;\n        end\n      endcase\n    end\n  end\n\nendmodule\n```",
    "prompt_2": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=0 and CPHA=1. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out ); Please return code only. No sure here, or any text. ",
    "answer_2": "```systemverilog\nmodule SPI_driver #(\n    parameter CLK_DIV_FACTOR = 2 // SPI_CLK_freq = clk_freq / (2 * CLK_DIV_FACTOR)\n                                 // For example, if CLK_DIV_FACTOR = 2, SPI_CLK is clk / 4\n) (\n    input logic clk,\n    input logic rst,\n    input logic [7:0] data_in,\n    input logic SPI_MISO,\n    input logic SPI_start,\n    output logic SPI_MOSI,\n    output logic SPI_CLK,\n    output logic SPI_EN,\n    output logic [7:0] data_out\n);\n\n    // Internal signals\n    logic [7:0] s_data_in_reg;\n    logic [7:0] s_data_out_reg;\n    logic [3:0] bit_count; // Counts from 0 to 7 for 8 bits\n    logic [7:0] clk_div_counter; // Counter for SPI_CLK generation\n    logic s_spi_clk;\n    logic s_spi_en;\n    logic s_spi_mosi;\n\n    // State machine definition\n    typedef enum logic [1:0] {\n        IDLE,\n        TRANSFER,\n        END_TRANSFER\n    } spi_state_e;\n\n    spi_state_e current_state, next_state;\n\n    // State register\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always_comb begin\n        next_state = current_state; // Default to staying in current state\n        case (current_state)\n            IDLE: begin\n                if (SPI_start) begin\n                    next_state = TRANSFER;\n                end\n            end\n            TRANSFER: begin\n                // Transition to END_TRANSFER after all 8 bits (0-7) have been processed\n                if (bit_count == 8) begin\n                    next_state = END_TRANSFER;\n                end\n            end\n            END_TRANSFER: begin\n                // After completing transfer, return to IDLE\n                next_state = IDLE;\n            end\n            default: next_state = IDLE; // Should not happen\n        endcase\n    end\n\n    // Output assignments\n    assign SPI_MOSI = s_spi_mosi;\n    assign SPI_CLK = s_spi_clk;\n    assign SPI_EN = s_spi_en;\n    assign data_out = s_data_out_reg;\n\n    // Main FSM logic and data path\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            s_spi_en <= 1'b1; // SPI_EN is active low, so high when idle\n            s_spi_clk <= 1'b0; // CPOL=0, SPI_CLK is low when idle\n            s_spi_mosi <= 1'b0;\n            s_data_in_reg <= 8'h00;\n            s_data_out_reg <= 8'h00;\n            bit_count <= 4'h0;\n            clk_div_counter <= 8'h00;\n        end else begin\n            // Default assignments to hold values\n            s_spi_en <= 1'b1; // Default to inactive\n            s_spi_clk <= s_spi_clk;\n            s_spi_mosi <= s_spi_mosi;\n            s_data_out_reg <= s_data_out_reg;\n            s_data_in_reg <= s_data_in_reg;\n            bit_count <= bit_count;\n            clk_div_counter <= clk_div_counter;\n\n            case (current_state)\n                IDLE: begin\n                    s_spi_en <= 1'b1; // Ensure SPI_EN is high\n                    s_spi_clk <= 1'b0; // Ensure SPI_CLK is low\n                    s_spi_mosi <= 1'b0;\n                    s_data_out_reg <= 8'h00; // Clear output data\n                    bit_count <= 4'h0; // Reset bit counter\n                    clk_div_counter <= 8'h00; // Reset clock divider\n\n                    if (SPI_start) begin\n                        s_data_in_reg <= data_in; // Load data to be sent\n                        s_spi_en <= 1'b0; // Assert SPI_EN (active low)\n                    end\n                end\n                TRANSFER: begin\n                    s_spi_en <= 1'b0; // Keep SPI_EN asserted\n\n                    // SPI_CLK generation\n                    if (clk_div_counter == (CLK_DIV_FACTOR - 1)) begin\n                        clk_div_counter <= 8'h00;\n                        s_spi_clk <= ~s_spi_clk; // Toggle SPI_CLK\n                    end else begin\n                        clk_div_counter <= clk_div_counter + 1;\n                    end\n\n                    // Data transfer logic for CPOL=0, CPHA=1\n                    // MOSI changes on the rising edge of SPI_CLK\n                    // MISO samples on the falling edge of SPI_CLK\n\n                    // Check for rising edge of SPI_CLK (s_spi_clk is currently 0, and about to toggle to 1)\n                    if (s_spi_clk == 1'b0 && clk_div_counter == (CLK_DIV_FACTOR - 1)) begin\n                        // Drive MOSI with the current bit (MSB first)\n                        s_spi_mosi <= s_data_in_reg[7 - bit_count];\n                    end\n                    // Check for falling edge of SPI_CLK (s_spi_clk is currently 1, and about to toggle to 0)\n                    else if (s_spi_clk == 1'b1 && clk_div_counter == (CLK_DIV_FACTOR - 1)) begin\n                        // Sample MISO and store it\n                        s_data_out_reg[7 - bit_count] <= SPI_MISO;\n                        // Increment bit_count after sampling each bit\n                        bit_count <= bit_count + 1;\n                    end\n                end\n                END_TRANSFER: begin\n                    s_spi_en <= 1'b1; // Deassert SPI_EN\n                    s_spi_clk <= 1'b0; // Ensure clock returns to idle low\n                    s_spi_mosi <= 1'b0; // Ensure MOSI is low\n                    bit_count <= 4'h0; // Reset bit counter\n                    clk_div_counter <= 8'h00; // Reset clock divider\n                end\n            endcase\n        end\n    end\n\nendmodule\n```",
    "prompt_3": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=0 and CPHA=0. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out ); Please return code only. No sure here, or any text. ",
    "answer_3": "```systemverilog\nmodule SPI_driver(\n    input logic clk,\n    input logic rst,\n    input logic [7:0] data_in,\n    input logic SPI_MISO,\n    input logic SPI_start,\n    output logic SPI_MOSI,\n    output logic SPI_CLK,\n    output logic SPI_EN,\n    output logic [7:0] data_out\n);\n\n    // Internal registers for outputs and data\n    logic [7:0] s_data_in_reg;  // Shift register for data to transmit\n    logic [7:0] s_data_out_reg; // Shift register for received data\n    logic [2:0] bit_count;      // Counter for 8 bits (0 to 7)\n    logic spi_clk_reg;          // Internal register for SPI_CLK\n    logic spi_mosi_reg;         // Internal register for SPI_MOSI\n    logic spi_en_reg;           // Internal register for SPI_EN (Chip Select)\n\n    // State machine definition\n    typedef enum logic [1:0] {\n        IDLE,       // Waiting for a transaction to start\n        START_TX,   // Initialize transaction, assert CS\n        TX_RX_BITS, // Transmit/Receive 8 bits\n        END_TX      // End transaction, de-assert CS\n    } spi_state_e;\n\n    spi_state_e current_state, next_state;\n\n    // FSM State Register\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // FSM Next State Logic\n    always_comb begin\n        next_state = current_state; // Default to stay in current state\n        case (current_state)\n            IDLE: begin\n                if (SPI_start) begin\n                    next_state = START_TX;\n                end\n            end\n            START_TX: begin\n                next_state = TX_RX_BITS;\n            end\n            TX_RX_BITS: begin\n                // After 8 bits are fully processed (bit_count goes from 0 to 7, then increments to 8)\n                if (bit_count == 3'd8) begin\n                    next_state = END_TX;\n                end\n            end\n            END_TX: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Output Logic and Data Path\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            spi_en_reg     <= 1'b1;   // SPI_EN inactive (high)\n            spi_clk_reg    <= 1'b0;   // CPOL=0, idle low\n            spi_mosi_reg   <= 1'b0;\n            s_data_in_reg  <= 8'h00;\n            s_data_out_reg <= 8'h00;\n            bit_count      <= 3'd0;\n        end else begin\n            case (current_state)\n                IDLE: begin\n                    spi_en_reg     <= 1'b1;   // Keep inactive\n                    spi_clk_reg    <= 1'b0;   // Keep idle low\n                    spi_mosi_reg   <= 1'b0;   // Keep low\n                    s_data_out_reg <= 8'h00;   // Clear received data\n                    bit_count      <= 3'd0;   // Reset bit counter\n                    if (SPI_start) begin\n                        s_data_in_reg <= data_in; // Load data to transmit\n                    end\n                end\n                START_TX: begin\n                    spi_en_reg     <= 1'b0;   // Assert SPI_EN (active low)\n                    spi_clk_reg    <= 1'b0;   // Ensure SPI_CLK is low before first edge\n                    spi_mosi_reg   <= s_data_in_reg[7]; // Set MSB of data_in on MOSI\n                    bit_count      <= 3'd0;   // Reset bit counter\n                end\n                TX_RX_BITS: begin\n                    // CPOL=0, CPHA=0:\n                    // SPI_CLK is low when idle.\n                    // Data is sampled on the rising edge of SPI_CLK.\n                    // Data is changed on the falling edge of SPI_CLK.\n                    // This implementation assumes SPI_CLK runs at clk/2.\n\n                    if (spi_clk_reg == 1'b0) begin // Current SPI_CLK is low, about to go high\n                        spi_clk_reg <= 1'b1; // Drive SPI_CLK high (rising edge)\n                        // On the rising edge, sample MISO\n                        s_data_out_reg <= {s_data_out_reg[6:0], SPI_MISO};\n                    end else begin // Current SPI_CLK is high, about to go low\n                        spi_clk_reg <= 1'b0; // Drive SPI_CLK low (falling edge)\n                        // On the falling edge, change MOSI for the next bit\n                        s_data_in_reg <= s_data_in_reg << 1; // Shift out current bit\n                        spi_mosi_reg <= s_data_in_reg[6]; // Set next bit (MSB of shifted data)\n                        bit_count <= bit_count + 1; // Increment bit counter after a full SPI clock cycle\n                    end\n                end\n                END_TX: begin\n                    spi_en_reg     <= 1'b1;   // De-assert SPI_EN\n                    spi_clk_reg    <= 1'b0;   // Return SPI_CLK to idle low\n                    spi_mosi_reg   <= 1'b0;   // Return MOSI to idle low\n                    // data_out is assigned s_data_out_reg outside this always block\n                end\n            endcase\n        end\n    end\n\n    // Assign outputs from internal registers\n    assign SPI_MOSI = spi_mosi_reg;\n    assign SPI_CLK  = spi_clk_reg;\n    assign SPI_EN   = spi_en_reg;\n    assign data_out = s_data_out_reg; // Output the received data when transaction completes\n\nendmodule\n```"
}
