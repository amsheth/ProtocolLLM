{
    "prompt_0": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=1 and CPHA=1. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out ); Please return code only. No sure here, or any text. ",
    "answer_0": "```systemverilog\nmodule SPI_driver(\n    input logic clk,\n    input logic rst,\n    input logic [7:0] data_in,\n    input logic SPI_MISO,\n    Input logic SPI_start,\n    output logic SPI_MOSI,\n    output logic SPI_CLK,\n    output logic SPI_EN,\n    output logic [7:0] data_out\n);\n\n// CPOL = 1 and CPHA = 1 parameters\nlocalparam CPOL = 1;\nlocalparam CPHA = 1;\n\n// Internal signals for state machine\nlogic [2:0] state;\nlogic [3:0] bit_count;\nlogic [7:0] shift_reg;\nlogic SPI_start_dly;\n\nalways_ff @(posedge clk or posedge rst) begin\n    if (rst) begin\n        state <= 3'b000;\n        bit_count <= 4'b0000;\n        shift_reg <= 8'b00000000;\n        SPI_MOSI <= 1'b0;\n        SPI_CLK <= CPOL ^ CPHA; // CPOL = 1, CPHA = 1\n        SPI_EN <= 1'b0;\n        data_out <= 8'b00000000;\n    end else begin\n        case (state)\n            3'b000: begin // Idle state\n                if (SPI_start && !SPI_start_dly) begin\n                    SPI_EN <= 1'b1;\n                    shift_reg <= data_in;\n                    bit_count <= 4'b1000;\n                    state <= 3'b001;\n                end else begin\n                    SPI_EN <= 1'b0;\n                end\n            end\n            3'b001: begin // Start condition setup\n                SPI_CLK <= CPOL ^ CPHA;\n                if (CPHA == 1) begin\n                    SPI_MOSI <= shift_reg[7];\n                end\n                state <= 3'b010;\n            end\n            3'b010: begin // Clock high, data sampling or shifting\n                SPI_CLK <= CPOL ^ CPHA;\n                if (CPHA == 0) begin\n                    SPI_MOSI <= shift_reg[7];\n                end else begin\n                    shift_reg <= {shift_reg[6:0], SPI_MISO};\n                end\n                state <= 3'b011;\n            end\n            3'b011: begin // Clock low, data shifting or sampling\n                if (CPHA == 1) begin\n                    shift_reg <= {shift_reg[6:0], SPI_MISO};\n                end\n                state <= 3'b100;\n            end\n            3'b100: begin // End of bit frame\n                SPI_CLK <= CPOL ^ CPHA;\n                if (CPHA == 1) begin\n                    shift_reg <= {shift_reg[6:0], SPI_MISO};\n                end\n                if (bit_count == 4'b1000) begin\n                    data_out <= shift_reg;\n                    state <= 3'b101;\n                end else begin\n                    bit_count <= bit_count - 1;\n                    state <= 3'b001;\n                end\n            end\n            3'b101: begin // Data output and deassertion of SPI_EN\n                if (bit_count == 4'b1000) begin\n                    SPI_EN <= 1'b0;\n                end\n                state <= 3'b000;\n            end\n        endcase\n    end\nend\n\n// Delay the start signal for one clock cycle\nalways_ff @(posedge clk or posedge rst) begin\n    if (rst) begin\n        SPI_start_dly <= 1'b0;\n    end else begin\n        SPI_start_dly <= SPI_start;\n    end\nend\n\nendmodule\n```",
    "prompt_1": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=1 and CPHA=0. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out ); Please return code only. No sure here, or any text. ",
    "answer_1": "```systemverilog\nmodule SPI_driver(\n    input logic clk,\n    input logic rst,\n    input logic [7:0] data_in,\n    input logic SPI_MISO,\n    Input logic SPI_start,\n    output logic SPI_MOSI,\n    output logic SPI_CLK,\n    output logic SPI_EN,\n    output logic [7:0] data_out\n);\n\n  // Clock polarity and phase settings\n  parameter CPOL = 1;\n  parameter CPHA = 0;\n\n  // Internal signals\n  enum logic [1:0] {IDLE, START, TRANSFER, STOP} state;\n  logic [2:0] bit_cnt;\n  logic [7:0] shift_reg;\n  logic clk_div;\n  logic [1:0] clk_phase;\n\n  // Clock divider to generate SPI clock\n  always_ff @(posedge clk or posedge rst) begin\n    if (rst) begin\n      clk_div <= CPOL;\n    end else begin\n      clk_div <= ~clk_div;\n    end\n  end\n\n  // Phase control for data sampling and shifting\n  always_ff @(posedge clk_div or posedge rst) begin\n    if (rst) begin\n      clk_phase <= 0;\n    end else begin\n      clk_phase <= clk_phase + 1;\n    end\n  end\n\n  // State machine to control the SPI transaction\n  always_ff @(posedge clk or posedge rst) begin\n    if (rst) begin\n      state <= IDLE;\n      bit_cnt <= 0;\n      shift_reg <= 0;\n      SPI_CLK <= CPOL;\n      SPI_MOSI <= 0;\n      SPI_EN <= 0;\n      data_out <= 0;\n    end else begin\n      case (state)\n        IDLE: begin\n          if (SPI_start) begin\n            state <= START;\n            bit_cnt <= 7;\n            shift_reg <= data_in;\n            SPI_EN <= 1;\n          end\n        end\n        START: begin\n          if (clk_phase == 0) begin\n            SPI_CLK <= ~CPOL;\n            SPI_MOSI <= shift_reg[7];\n          end else begin\n            state <= TRANSFER;\n          end\n        end\n        TRANSFER: begin\n          if (clk_phase == 1) begin\n            SPI_CLK <= ~CPOL;\n            shift_reg <= {shift_reg[6:0], SPI_MISO};\n          end else if (clk_phase == 3) begin\n            state <= STOP;\n          end\n        end\n        STOP: begin\n          if (clk_phase == 2) begin\n            data_out <= shift_reg;\n            SPI_EN <= 0;\n            state <= IDLE;\n          end\n        end\n      endcase\n    end\n  end\nendmodule\n```",
    "prompt_2": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=0 and CPHA=1. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out ); Please return code only. No sure here, or any text. ",
    "answer_2": "```systemverilog\nmodule SPI_driver(input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out);\n  // CPOL = 0, CPHA = 1\n  parameter CPOL = 0;\n  parameter CPHA = 1;\n\n  enum logic {IDLE, START, TRANSFER} state, next_state;\n  logic [2:0] bit_cnt;\n  logic [7:0] shift_reg;\n\n  always_ff @(posedge clk or posedge rst) begin\n    if (rst) begin\n      state <= IDLE;\n      bit_cnt <= 3'b0;\n      shift_reg <= 8'h0;\n    end else begin\n      state <= next_state;\n      case (next_state)\n        TRANSFER: begin\n          if (bit_cnt < 3'd7) begin\n            bit_cnt <= bit_cnt + 1;\n            shift_reg <= {shift_reg[6:0], SPI_MISO};\n          end else begin\n            data_out <= shift_reg;\n            bit_cnt <= 3'b0;\n          end\n        end\n      endcase\n    end\n  end\n\n  always_comb begin\n    next_state = state;\n    case (state)\n      IDLE: if (SPI_start) next_state = START;\n      START: next_state = TRANSFER;\n      TRANSFER: if (bit_cnt == 3'd7) next_state = IDLE;\n    endcase\n  end\n\n  always_comb begin\n    SPI_CLK = CPOL ? clk : ~clk;\n    SPI_MOSI = shift_reg[7];\n    case (CPHA)\n      0: SPI_CLK = state == TRANSFER ? clk : ~clk;\n      1: SPI_CLK = state == TRANSFER ? ~clk : clk;\n    endcase\n  end\n\n  assign SPI_EN = (state != IDLE);\nendmodule\n```",
    "prompt_3": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=0 and CPHA=0. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out ); Please return code only. No sure here, or any text. ",
    "answer_3": "```systemverilog\nmodule SPI_driver(\n    input logic clk,\n    input logic rst,\n    input logic [7:0] data_in,\n    input logic SPI_MISO,\n    input logic SPI_start,\n    output logic SPI_MOSI,\n    output logic SPI_CLK,\n    output logic SPI_EN,\n    output logic [7:0] data_out\n);\n    // CPOL = 0 and CPHA = 0 means Clock Polarity (CPOL) is low when idle and Clock Phase (CPHA) is sampling on the first edge.\n\n    enum logic {IDLE, START, TRANSFER, STOP} state, next_state;\n    logic [2:0] bit_count;\n    logic [7:0] shift_reg;\n    logic clk_div;\n\n    // Clock Divider to generate SPI clock (assuming 16x faster than input clock)\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            clk_div <= 0;\n        end else begin\n            clk_div <= ~clk_div; // Simple divide-by-two for demonstration purposes\n        end\n    end\n\n    // SPI Clock Generation\n    assign SPI_CLK = (~CPOL & clk_div) | (CPOL & ~clk_div);\n\n    // State Machine Logic\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n            bit_count <= 0;\n            shift_reg <= 0;\n        end else begin\n            state <= next_state;\n            case (next_state)\n                TRANSFER: begin\n                    if (bit_count < 7) begin\n                        bit_count <= bit_count + 1;\n                    end else begin\n                        bit_count <= 0;\n                    end\n                    shift_reg <= {shift_reg[6:0], SPI_MISO}; // Shift in data on MOSI if CPHA=0\n                end\n            endcase\n        end\n    end\n\n    always_comb begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (SPI_start) begin\n                    next_state = START;\n                    bit_count = 0;\n                    shift_reg = data_in;\n                end\n            end\n            START: begin\n                next_state = TRANSFER;\n            end\n            TRANSFER: begin\n                if (bit_count == 7) begin\n                    next_state = STOP;\n                end\n            end\n            STOP: begin\n                // End of transfer, no action needed except to reset start signal if necessary.\n            end\n        endcase\n    end\n\n    // Output Logic for SPI signals\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            SPI_MOSI <= 0;\n            SPI_EN <= 0;\n        end else begin\n            case (state)\n                TRANSFER: begin\n                    SPI_MOSI <= shift_reg[7]; // Output the MSB first\n                end\n                STOP: begin\n                    SPI_EN <= 0; // Deassert EN after transfer if necessary, or adjust based on requirements.\n                end\n            endcase\n        end\n    end\n\n    assign data_out = shift_reg;\nendmodule\n```"
}
