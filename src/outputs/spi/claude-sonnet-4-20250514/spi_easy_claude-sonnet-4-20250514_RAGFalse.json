{
    "prompt_0": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=1 and CPHA=1. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out );\n",
    "answer_0": "Here's a SystemVerilog SPI driver implementation with CPOL=1 and CPHA=1 parameters:\n\n```systemverilog\nmodule SPI_driver(\n    input logic clk,\n    input logic rst,\n    input logic [7:0] data_in,\n    input logic SPI_MISO,\n    input logic SPI_start,\n    output logic SPI_MOSI,\n    output logic SPI_CLK,\n    output logic SPI_EN,\n    output logic [7:0] data_out\n);\n\n    // Parameters for CPOL=1, CPHA=1\n    parameter CPOL = 1'b1;  // Clock polarity: idle high\n    parameter CPHA = 1'b1;  // Clock phase: sample on falling edge, shift on rising edge\n    parameter CLK_DIV = 4;  // Clock divider (adjust as needed)\n    \n    // State machine states\n    typedef enum logic [2:0] {\n        IDLE    = 3'b000,\n        START   = 3'b001,\n        ACTIVE  = 3'b010,\n        DONE    = 3'b011\n    } state_t;\n    \n    state_t current_state, next_state;\n    \n    // Internal registers\n    logic [7:0] tx_shift_reg;\n    logic [7:0] rx_shift_reg;\n    logic [7:0] data_out_reg;\n    logic [3:0] bit_counter;\n    logic [3:0] clk_counter;\n    logic spi_clk_reg;\n    logic spi_en_reg;\n    logic spi_mosi_reg;\n    logic sample_enable;\n    logic shift_enable;\n    \n    // Clock generation counter\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            clk_counter <= 4'b0;\n        end else if (current_state == ACTIVE) begin\n            clk_counter <= clk_counter + 1;\n        end else begin\n            clk_counter <= 4'b0;\n        end\n    end\n    \n    // Generate sample and shift enables\n    assign sample_enable = (clk_counter == (CLK_DIV/2 - 1)) && (current_state == ACTIVE);\n    assign shift_enable = (clk_counter == (CLK_DIV - 1)) && (current_state == ACTIVE);\n    \n    // SPI Clock generation (CPOL=1: idle high, CPHA=1: toggle on shift_enable)\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            spi_clk_reg <= CPOL;  // Idle state is high for CPOL=1\n        end else if (current_state == IDLE || current_state == DONE) begin\n            spi_clk_reg <= CPOL;  // Return to idle state\n        end else if (shift_enable) begin\n            spi_clk_reg <= ~spi_clk_reg;  // Toggle clock\n        end\n    end\n    \n    // State machine sequential logic\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n    \n    // State machine combinational logic\n    always_comb begin\n        next_state = current_state;\n        \n        case (current_state)\n            IDLE: begin\n                if (SPI_start) begin\n                    next_state = START;\n                end\n            end\n            \n            START: begin\n                next_state = ACTIVE;\n            end\n            \n            ACTIVE: begin\n                if (bit_counter == 4'd8 && shift_enable) begin\n                    next_state = DONE;\n                end\n            end\n            \n            DONE: begin\n                next_state = IDLE;\n            end\n            \n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n    \n    // Bit counter\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            bit_counter <= 4'd0;\n        end else if (current_state == START) begin\n            bit_counter <= 4'd0;\n        end else if (shift_enable && current_state == ACTIVE) begin\n            bit_counter <= bit_counter + 1;\n        end\n    end\n    \n    // TX shift register (MOSI data)\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tx_shift_reg <= 8'b0;\n            spi_mosi_reg <= 1'b0;\n        end else if (current_state == START) begin\n            tx_shift_reg <= data_in;\n            spi_mosi_reg <= data_in[7];  // Load first bit\n        end else if (shift_enable && current_state == ACTIVE) begin\n            tx_shift_reg <= {tx_shift_reg[6:0], 1'b0};  // Shift left\n            spi_mosi_reg <= tx_shift_reg[6];  // Next bit to transmit\n        end\n    end\n    \n    // RX shift register (MISO data) - Sample on falling edge for CPHA=1\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_shift_reg <= 8'b0;\n        end else if (current_state == START) begin\n            rx_shift_reg <= 8'b0;\n        end else if (sample_enable && current_state == ACTIVE) begin\n            rx_shift_reg <= {rx_shift_reg[6:0], SPI_MISO};  // Shift in received bit\n        end\n    end\n    \n    // Output data register\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            data_out_reg <= 8'b0;\n        end else if (current_state == DONE) begin\n            data_out_reg <= rx_shift_reg;\n        end\n    end\n    \n    // SPI Enable signal\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            spi_en_reg <= 1'b1;  // Idle high (inactive)\n        end else if (current_state == ACTIVE) begin\n            spi_en_reg <= 1'b0;  // Active low during transmission\n        end else begin\n            spi_en_reg <= 1'b1;  // Inactive\n        end\n    end\n    \n    // Output assignments\n    assign SPI_CLK = spi_clk_reg;\n    assign SPI_MOSI = spi_mosi_reg;\n    assign SPI_EN = spi_en_reg;\n    assign data_out = data_out_reg;\n\nendmodule\n```\n\nThis SPI driver implementation features:\n\n**Key Characteristics for CPOL=1, CPHA=1:**\n- **CPOL=1**: Clock idles high\n- **CPHA=1**: Data is sampled on the falling edge and shifted on the rising edge\n\n**Features:**\n1. **State Machine**: 4-state FSM (IDLE, START, ACTIVE, DONE)\n2. **Clock Generation**: Configurable clock divider with proper timing\n3. **Data Transmission**: 8-bit shift register for MOSI\n4. **Data Reception**: 8-bit shift register for MISO\n5. **Chip Select**: SPI_EN signal (active low during transmission)\n6. **Bit Counter**: Tracks transmitted/received bits\n\n**Operation:**\n1. Assert `SPI_start` to begin transmission\n2. Load `data_in` into TX shift register\n3. Generate SPI clock and shift data\n4. Sample MISO data on falling clock edges\n5. Complete after 8 bits, output received data\n6. Return to idle state\n\n**Timing:**\n- Clock divider creates slower SPI clock from system clock\n- Proper setup/hold times maintained for CPOL=1/CPHA=1 mode\n- Data changes on rising edges, sampled on falling edges\n\nThe module can be easily customized by adjusting the `CLK_DIV` parameter for different SPI clock frequencies.",
    "prompt_1": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=1 and CPHA=0. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out );\n",
    "answer_1": "Here's a SystemVerilog SPI driver implementation with CPOL=1 and CPHA=0:\n\n```systemverilog\nmodule SPI_driver(\n    input logic clk,\n    input logic rst,\n    input logic [7:0] data_in,\n    input logic SPI_MISO,\n    input logic SPI_start,\n    output logic SPI_MOSI,\n    output logic SPI_CLK,\n    output logic SPI_EN,\n    output logic [7:0] data_out\n);\n\n    // Parameters for SPI configuration\n    parameter CPOL = 1;  // Clock polarity: idle state is high\n    parameter CPHA = 0;  // Clock phase: data sampled on first edge\n    \n    // Internal registers and signals\n    typedef enum logic [2:0] {\n        IDLE,\n        ACTIVE,\n        DONE\n    } state_t;\n    \n    state_t current_state, next_state;\n    \n    logic [7:0] tx_shift_reg;\n    logic [7:0] rx_shift_reg;\n    logic [3:0] bit_counter;\n    logic [7:0] clk_divider;\n    logic spi_clk_en;\n    logic spi_clk_internal;\n    logic data_valid;\n    \n    // Clock divider for SPI clock generation\n    // Adjust the division factor as needed for your application\n    parameter CLK_DIV = 8;  // Divide system clock by 8\n    \n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            clk_divider <= 0;\n            spi_clk_en <= 0;\n        end else begin\n            if (current_state == ACTIVE) begin\n                if (clk_divider == CLK_DIV/2 - 1) begin\n                    clk_divider <= 0;\n                    spi_clk_en <= 1;\n                end else begin\n                    clk_divider <= clk_divider + 1;\n                    spi_clk_en <= 0;\n                end\n            end else begin\n                clk_divider <= 0;\n                spi_clk_en <= 0;\n            end\n        end\n    end\n    \n    // SPI clock generation with CPOL=1 (idle high)\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            spi_clk_internal <= CPOL;  // Initialize to idle state (high for CPOL=1)\n        end else begin\n            if (current_state == ACTIVE && spi_clk_en) begin\n                spi_clk_internal <= ~spi_clk_internal;\n            end else if (current_state == IDLE) begin\n                spi_clk_internal <= CPOL;  // Return to idle state\n            end\n        end\n    end\n    \n    // State machine\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n    \n    // Next state logic\n    always_comb begin\n        next_state = current_state;\n        case (current_state)\n            IDLE: begin\n                if (SPI_start) begin\n                    next_state = ACTIVE;\n                end\n            end\n            ACTIVE: begin\n                if (bit_counter == 8 && spi_clk_en && spi_clk_internal == CPOL) begin\n                    next_state = DONE;\n                end\n            end\n            DONE: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n    \n    // Bit counter\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            bit_counter <= 0;\n        end else begin\n            case (current_state)\n                IDLE: begin\n                    bit_counter <= 0;\n                end\n                ACTIVE: begin\n                    // For CPHA=0, count on the first edge (falling edge when CPOL=1)\n                    if (spi_clk_en && spi_clk_internal == 1'b1) begin\n                        bit_counter <= bit_counter + 1;\n                    end\n                end\n                DONE: begin\n                    bit_counter <= 0;\n                end\n            endcase\n        end\n    end\n    \n    // TX shift register\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tx_shift_reg <= 8'h00;\n        end else begin\n            case (current_state)\n                IDLE: begin\n                    if (SPI_start) begin\n                        tx_shift_reg <= data_in;\n                    end\n                end\n                ACTIVE: begin\n                    // For CPHA=0, shift on the first edge (falling edge when CPOL=1)\n                    if (spi_clk_en && spi_clk_internal == 1'b1 && bit_counter < 8) begin\n                        tx_shift_reg <= {tx_shift_reg[6:0], 1'b0};\n                    end\n                end\n            endcase\n        end\n    end\n    \n    // RX shift register\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            rx_shift_reg <= 8'h00;\n        end else begin\n            case (current_state)\n                IDLE: begin\n                    rx_shift_reg <= 8'h00;\n                end\n                ACTIVE: begin\n                    // For CPHA=0, sample on the first edge (falling edge when CPOL=1)\n                    if (spi_clk_en && spi_clk_internal == 1'b1 && bit_counter < 8) begin\n                        rx_shift_reg <= {rx_shift_reg[6:0], SPI_MISO};\n                    end\n                end\n            endcase\n        end\n    end\n    \n    // Data valid flag\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            data_valid <= 0;\n        end else begin\n            data_valid <= (current_state == DONE);\n        end\n    end\n    \n    // Output assignments\n    assign SPI_CLK = spi_clk_internal;\n    assign SPI_MOSI = tx_shift_reg[7];  // MSB first\n    assign SPI_EN = (current_state == ACTIVE);  // Active low chip select\n    assign data_out = data_valid ? rx_shift_reg : 8'h00;\n\nendmodule\n```\n\nThis SPI driver implementation features:\n\n**Key Characteristics:**\n- **CPOL = 1**: Clock idle state is high\n- **CPHA = 0**: Data is sampled on the first clock edge (falling edge when CPOL=1)\n- **Master mode**: Generates SPI clock and controls chip select\n- **8-bit data transfers**: Sends and receives 8 bits per transaction\n- **MSB first**: Most significant bit transmitted first\n\n**State Machine:**\n- **IDLE**: Waiting for SPI_start signal\n- **ACTIVE**: Performing SPI transaction\n- **DONE**: Transaction complete, data_out valid\n\n**Key Features:**\n1. **Clock Generation**: Divides system clock to create SPI clock\n2. **Shift Registers**: Separate TX and RX shift registers for simultaneous send/receive\n3. **Bit Counter**: Tracks number of bits transmitted/received\n4. **Data Valid**: Indicates when received data is valid\n\n**Usage:**\n1. Load data into `data_in`\n2. Assert `SPI_start` for one clock cycle\n3. Monitor `SPI_EN` to see when transaction is active\n4. Read `data_out` when transaction completes\n\nThe clock divider can be adjusted by changing the `CLK_DIV` parameter to match your timing requirements.",
    "prompt_2": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=0 and CPHA=1. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out );\n",
    "answer_2": "Here's a SystemVerilog SPI driver implementation with CPOL=0 and CPHA=1:\n\n```systemverilog\nmodule SPI_driver(\n    input logic clk,\n    input logic rst,\n    input logic [7:0] data_in,\n    input logic SPI_MISO,\n    input logic SPI_start,\n    output logic SPI_MOSI,\n    output logic SPI_CLK,\n    output logic SPI_EN,\n    output logic [7:0] data_out\n);\n\n    // Parameters for CPOL=0, CPHA=1\n    parameter CPOL = 1'b0;  // Clock polarity: idle state is low\n    parameter CPHA = 1'b1;  // Clock phase: data captured on rising edge, shifted on falling edge\n    \n    // Internal signals\n    typedef enum logic [1:0] {\n        IDLE = 2'b00,\n        ACTIVE = 2'b01,\n        DONE = 2'b10\n    } state_t;\n    \n    state_t current_state, next_state;\n    \n    logic [3:0] bit_counter;\n    logic [7:0] tx_shift_reg;\n    logic [7:0] rx_shift_reg;\n    logic spi_clk_en;\n    logic spi_clk_internal;\n    logic clk_div;\n    logic [3:0] clk_counter;\n    \n    // Clock divider for SPI clock generation\n    // Divides input clock by 8 to create SPI clock\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            clk_counter <= 4'b0;\n            clk_div <= 1'b0;\n        end else begin\n            clk_counter <= clk_counter + 1'b1;\n            if (clk_counter == 4'b0111) begin\n                clk_div <= ~clk_div;\n                clk_counter <= 4'b0;\n            end\n        end\n    end\n    \n    // State machine\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst)\n            current_state <= IDLE;\n        else\n            current_state <= next_state;\n    end\n    \n    always_comb begin\n        case (current_state)\n            IDLE: begin\n                if (SPI_start)\n                    next_state = ACTIVE;\n                else\n                    next_state = IDLE;\n            end\n            \n            ACTIVE: begin\n                if (bit_counter == 4'b1000)  // 8 bits transmitted\n                    next_state = DONE;\n                else\n                    next_state = ACTIVE;\n            end\n            \n            DONE: begin\n                next_state = IDLE;\n            end\n            \n            default: next_state = IDLE;\n        endcase\n    end\n    \n    // Control signals\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            spi_clk_en <= 1'b0;\n            SPI_EN <= 1'b0;\n            bit_counter <= 4'b0;\n            tx_shift_reg <= 8'b0;\n            rx_shift_reg <= 8'b0;\n            data_out <= 8'b0;\n        end else begin\n            case (current_state)\n                IDLE: begin\n                    spi_clk_en <= 1'b0;\n                    SPI_EN <= 1'b0;\n                    bit_counter <= 4'b0;\n                    if (SPI_start) begin\n                        tx_shift_reg <= data_in;\n                        rx_shift_reg <= 8'b0;\n                    end\n                end\n                \n                ACTIVE: begin\n                    spi_clk_en <= 1'b1;\n                    SPI_EN <= 1'b1;\n                    \n                    // For CPHA=1: Data changes on falling edge, sampled on rising edge\n                    if (clk_div == 1'b0 && clk_counter == 4'b0111) begin  // Falling edge of SPI clock\n                        // Shift out next bit (MSB first)\n                        tx_shift_reg <= {tx_shift_reg[6:0], 1'b0};\n                    end\n                    \n                    if (clk_div == 1'b1 && clk_counter == 4'b0111) begin  // Rising edge of SPI clock\n                        // Sample MISO and increment bit counter\n                        rx_shift_reg <= {rx_shift_reg[6:0], SPI_MISO};\n                        bit_counter <= bit_counter + 1'b1;\n                    end\n                end\n                \n                DONE: begin\n                    spi_clk_en <= 1'b0;\n                    SPI_EN <= 1'b0;\n                    data_out <= rx_shift_reg;\n                end\n            endcase\n        end\n    end\n    \n    // SPI Clock generation\n    // CPOL=0: Idle state is low\n    // CPHA=1: Data captured on rising edge, shifted on falling edge\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            spi_clk_internal <= CPOL;\n        end else begin\n            if (spi_clk_en) begin\n                if (clk_counter == 4'b0111) begin\n                    spi_clk_internal <= clk_div;\n                end\n            end else begin\n                spi_clk_internal <= CPOL;  // Return to idle state\n            end\n        end\n    end\n    \n    // Output assignments\n    assign SPI_CLK = spi_clk_internal;\n    assign SPI_MOSI = tx_shift_reg[7];  // MSB first\n    \nendmodule\n```\n\nThis SPI driver implements the following features:\n\n**Key Characteristics:**\n- **CPOL=0**: Clock idle state is low\n- **CPHA=1**: Data is captured on the rising edge and shifted on the falling edge of the SPI clock\n- **Master mode**: Generates SPI clock and controls chip select (SPI_EN)\n- **8-bit data transfer**: Transmits and receives 8-bit data\n- **MSB first**: Most significant bit is transmitted first\n\n**Operation:**\n1. **IDLE State**: Waits for SPI_start signal\n2. **ACTIVE State**: \n   - Enables SPI clock and chip select\n   - Shifts out data on MOSI (falling edge of SPI_CLK)\n   - Samples data from MISO (rising edge of SPI_CLK)\n   - Counts 8 bits\n3. **DONE State**: Completes transaction and outputs received data\n\n**Clock Generation:**\n- Uses a clock divider to generate SPI clock from the input clock\n- SPI clock frequency = input clock frequency / 16\n- Can be adjusted by modifying the clock divider logic\n\n**Usage:**\n1. Load data into `data_in`\n2. Assert `SPI_start` for one clock cycle\n3. Wait for transaction to complete\n4. Read received data from `data_out`\n\nThe driver handles the timing requirements for CPHA=1 mode automatically and provides proper setup and hold times for reliable SPI communication.",
    "prompt_3": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=0 and CPHA=0. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out );\n",
    "answer_3": "Here's a SystemVerilog SPI driver implementation with CPOL=0 and CPHA=0 parameters:\n\n```systemverilog\nmodule SPI_driver(\n    input logic clk,\n    input logic rst,\n    input logic [7:0] data_in,\n    input logic SPI_MISO,\n    input logic SPI_start,\n    output logic SPI_MOSI,\n    output logic SPI_CLK,\n    output logic SPI_EN,\n    output logic [7:0] data_out\n);\n\n    // Parameters for CPOL=0, CPHA=0\n    parameter CPOL = 1'b0;  // Clock polarity: idle state is low\n    parameter CPHA = 1'b0;  // Clock phase: data captured on first edge, shifted on second edge\n    parameter CLK_DIV = 4;  // Clock divider to generate SPI clock (adjust as needed)\n    \n    // State machine states\n    typedef enum logic [2:0] {\n        IDLE    = 3'b000,\n        START   = 3'b001,\n        ACTIVE  = 3'b010,\n        FINISH  = 3'b011\n    } spi_state_t;\n    \n    // Internal signals\n    spi_state_t current_state, next_state;\n    logic [7:0] tx_shift_reg;\n    logic [7:0] rx_shift_reg;\n    logic [3:0] bit_counter;\n    logic [3:0] clk_counter;\n    logic spi_clk_en;\n    logic spi_clk_internal;\n    logic data_valid;\n    \n    // Clock generation for SPI\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            clk_counter <= 4'b0;\n            spi_clk_internal <= CPOL;  // Initialize to idle state (CPOL=0 means idle low)\n        end else if (spi_clk_en) begin\n            if (clk_counter == (CLK_DIV/2 - 1)) begin\n                clk_counter <= 4'b0;\n                spi_clk_internal <= ~spi_clk_internal;\n            end else begin\n                clk_counter <= clk_counter + 1;\n            end\n        end else begin\n            clk_counter <= 4'b0;\n            spi_clk_internal <= CPOL;  // Return to idle state\n        end\n    end\n    \n    // State machine - sequential logic\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n    \n    // State machine - combinational logic\n    always_comb begin\n        next_state = current_state;\n        \n        case (current_state)\n            IDLE: begin\n                if (SPI_start) begin\n                    next_state = START;\n                end\n            end\n            \n            START: begin\n                next_state = ACTIVE;\n            end\n            \n            ACTIVE: begin\n                if (bit_counter == 4'b1111 && clk_counter == (CLK_DIV/2 - 1) && spi_clk_internal == 1'b1) begin\n                    next_state = FINISH;\n                end\n            end\n            \n            FINISH: begin\n                next_state = IDLE;\n            end\n            \n            default: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n    \n    // Control signals generation\n    always_comb begin\n        case (current_state)\n            IDLE: begin\n                spi_clk_en = 1'b0;\n                SPI_EN = 1'b0;\n            end\n            \n            START: begin\n                spi_clk_en = 1'b1;\n                SPI_EN = 1'b1;\n            end\n            \n            ACTIVE: begin\n                spi_clk_en = 1'b1;\n                SPI_EN = 1'b1;\n            end\n            \n            FINISH: begin\n                spi_clk_en = 1'b0;\n                SPI_EN = 1'b0;\n            end\n            \n            default: begin\n                spi_clk_en = 1'b0;\n                SPI_EN = 1'b0;\n            end\n        endcase\n    end\n    \n    // Bit counter\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            bit_counter <= 4'b0;\n        end else if (current_state == START) begin\n            bit_counter <= 4'b0;\n        end else if (current_state == ACTIVE && clk_counter == (CLK_DIV/2 - 1) && spi_clk_internal == 1'b1) begin\n            bit_counter <= bit_counter + 1;\n        end\n    end\n    \n    // Shift registers for TX and RX\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tx_shift_reg <= 8'b0;\n            rx_shift_reg <= 8'b0;\n        end else if (current_state == START) begin\n            // Load new data to transmit\n            tx_shift_reg <= data_in;\n            rx_shift_reg <= 8'b0;\n        end else if (current_state == ACTIVE && clk_counter == (CLK_DIV/2 - 1)) begin\n            if (spi_clk_internal == 1'b0) begin\n                // Rising edge of SPI clock - shift out data (CPHA=0)\n                tx_shift_reg <= {tx_shift_reg[6:0], 1'b0};\n            end else begin\n                // Falling edge of SPI clock - shift in data (CPHA=0)\n                rx_shift_reg <= {rx_shift_reg[6:0], SPI_MISO};\n            end\n        end\n    end\n    \n    // Output data register\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            data_out <= 8'b0;\n            data_valid <= 1'b0;\n        end else if (current_state == FINISH) begin\n            data_out <= rx_shift_reg;\n            data_valid <= 1'b1;\n        end else if (current_state == IDLE) begin\n            data_valid <= 1'b0;\n        end\n    end\n    \n    // Output assignments\n    assign SPI_CLK = spi_clk_internal;\n    assign SPI_MOSI = tx_shift_reg[7];  // MSB first transmission\n    \nendmodule\n```\n\nThis SPI driver implementation features:\n\n**Key Characteristics:**\n- **CPOL=0**: Clock idle state is low\n- **CPHA=0**: Data is captured on the first clock edge (rising) and shifted on the second edge (falling)\n- **MSB First**: Transmits most significant bit first\n- **8-bit Transfer**: Handles 8-bit data transfers\n\n**Operation:**\n1. **IDLE State**: Waits for `SPI_start` signal\n2. **START State**: Loads input data into shift register and begins operation\n3. **ACTIVE State**: Performs the 8-bit SPI transfer\n4. **FINISH State**: Completes the transfer and updates output data\n\n**Timing:**\n- Uses a configurable clock divider (`CLK_DIV`) to generate SPI clock from system clock\n- For CPHA=0: Data is transmitted on rising edges and received on falling edges\n- Bit counter tracks the progress of the 8-bit transfer\n\n**Usage:**\n- Assert `SPI_start` for one clock cycle to initiate a transfer\n- `SPI_EN` indicates when a transfer is active (can be used as chip select)\n- `data_out` contains the received data after transfer completion\n\nYou can adjust the `CLK_DIV` parameter to achieve the desired SPI clock frequency relative to your system clock."
}
