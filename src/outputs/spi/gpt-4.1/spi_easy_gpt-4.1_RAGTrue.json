{
    "prompt_0": "The SPI Master core consists of three parts shown in the following figure: Serial Interface spi_shift.v Clock generator spi_clgen.v sclk_pad_o OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 9 of 9 Appendix A Core configuration To meet specific system requirements and size constraints on behalf of the core functionality, the SPI Master core can be configuredby setting the appropriate define directives in the spi_defines.v source file. The directives are as follows: SPI_DIVIDER_BIT_NB This parameter defines the maximum number of bits needed for the divider. Set this parameter accordingly to the maximum system frequency and lowest serial clock frequency: \uf8fa \uf8fb\uf8f9 \uf8ef \uf8f0\uf8ee\u2212\u2217= 12log R_BIT_NB SPI_DIVIDE minmax 2 sclksys ff Default value is 16. SPI_MAX_CHAR This parameter defines the maximum number of bits that can be received/transmitted in one transfer. The default value is 32. SPI_SS_NB This parameter defines the number of slave select lines. The default value is 8.\nTable 8: Slave Select register Reset Value: 0x00000000 SS Writing 1 to any bit location of this field sets the proper ss_pad_o line to an active state. OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 6 of 9 4 Operation This core is an SPI and Microwire/Plus compliant synchronous serial controller. At the host side, it is controlled via registers accessible through a WISHBONE rev. B1 interface. 4.1 WISHBONE interface The SPI core has four 32-bit registers through the WISHBONE rev. B1 compatible interface. All accesses to SPI registers must be 32-bit (wb_sel[3:0] = 0xf). Please refer to the WISHBONE specification at http://www.opencores.org/wishbone/specs/wbspec_b1.pdf 4.2 Serial interface The serial interface consists of slave select lines, serial clock lines, as well as input and output data lines. All transfers are full duplex transfers of a programmable number of bits per transfer (up to 32 bits). Compared to the SPI/Microwire protocol, this core has some additional functionality. It can drive data to the output data line in respect to the falling (SPI/Microwire compliant) or rising edge of the serial clock, and it can latch data on an input data line on the rising (SPI/Microwire compliant) or falling edge of a serial clock line. It also can transmit (receive) the MSB first (SPI/Microwire compliant) or the LSB first. It is important to know that the Rx and Tx registers share the same flip-flops, which means that what is received from the input data line in one transfer will be transmitted on the output data line in the next transfer if no write access to the Tx register is executed between the transfers. /ss_pad_o[0] /ss_pad_o[1] /ss_pad_o[2] MASTER sclk_pad_o mosi_pad_o miso pad i MISO MOSI SCLK /SS SLAVE 0 MISO MOSI SCLK / SS SLAVE 1 MISO MOSI SCLK /SS SLAVE 2 WISHBONE MISO MOSI SCLK/SS SLAVE 0 MISO MOSI SCLK/SS SLAVE 1 MISO MOSI SCLK/SS SLAVE 2 WISHBON E /ss_pad_o[0]/ss_pad_o[1]/ss_pad_o[2] MASTER sclk_pad_o mosi_pad_o miso _pad_iOpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 7 of 9 ss_pad_o mosi_pad_o miso_pad_i CTRL[LSB] = 0, CTRL[CHAR_LEN] = 0x08, CTRL[TX_NEG] = 1, CTRL[RX_NEG] = 0 LSB (Tx[0])ss_pad_o mosi_pad_o miso_pad_i CTRL[LSB] = 1, CTRL[CHAR_LEN] = 0x0a, CTRL[TX_NEG] = 0, CTRL[RX_NEG] = 1 MSB (Tx[9]) MSB (Tx[7]) MSB (Rx[7])LSB (Tx[0]) LSB (Rx[0]) LSB (Rx[0])MSB (Rx[9]) sclk_pad_o sclk_pad_o OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 8 of 9 WHISHBONE SOC Bus WHISHBONE Interface spi_top.v ss_pad_o mosi_pad_o miso_pad_i 5 Architecture The SPI Master core consists of three parts shown in the following figure: Serial Interface spi_shift.v Clock generator spi_clgen.v sclk_pad_o OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 9 of 9 Appendix A Core configuration To meet specific system requirements and size constraints on behalf of the core functionality, the SPI Master core can be configuredby setting the appropriate define directives in the spi_defines.v source file. The directives are as follows: SPI_DIVIDER_BIT_NB This parameter defines the maximum number of bits needed for the divider. Set this parameter accordingly to the maximum system frequency and lowest serial clock frequency: \uf8fa\nSPI Master Core Specification Author: Simon Srot simons@opencores.org Rev. 0.2 July 12, 2002 OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.1 i Revision History Rev. Date Author Description 0.1 June 13, 2002 Simon Srot First Draft 0.2 July 12, 2002 Simon Srot Document is lectured. OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.1 ii Contents CONTENTS.......................................................................................................... II INTRODUCTION................................................................................................. 1 IO PORTS.............................................................................................................. 2 2.1 WISHBONE INTERFACE SIGNALS ................................................................. 2 2.2 SPI EXTERNAL CONNECTIONS ........................................................................ 2 REGISTERS.......................................................................................................... 3 3.1 C ORE REGISTERS LIST .................................................................................... 3 3.2 D ATA RECEIVE REGISTER [RX]....................................................................... 3 3.3 D ATA TRANSMIT REGISTER [TX] .................................................................... 3 3.4 C ONTROL AND STATUS REGISTER [CTRL] ..................................................... 4 3.5 D IVIDER REGISTER [DIVIDER] ..................................................................... 5 3.6 S LAVE SELECT REGISTER [SS]........................................................................ 5 OPERATION......................................................................................................... 6 4.1 WISHBONE INTERFACE ............................................................................... 6 4.2 S ERIAL INTERFACE ......................................................................................... 6 ARCHITECTURE ................................................................................................ 8 CORE CONFIGURATION ................................................................................. 9 OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 1 of 9 1 Introduction This document provides specifications for the SPI (Serial Peripheral Interface) Master core. Synchronous serial interfaces are widely used to provide economical board-level interfaces between different devices such as microcontrollers, DACs, ADCs and other. Although there is no single standard for a synchronous serial bus, there are industry-wide accepted guidelines based on two most popular implementations: \u2022 SPI (a trademark of Motorola Semiconductor) \u2022 Microwire/Plus (a trademark of National Semiconductor) Many IC manufacturers produce components that are compatible with SPI and Microwire/Plus. The SPI Master core is compatible with both above-mentioned protocols as master with some additional functionality. At the hosts side, the core acts like a WISHBONE compliant slave device. Features: \u2022 Full duplex synchronous serial data transfer \u2022 Variable length of transfer word up to 32 bits \u2022 MSB or LSB first data transfer \u2022 Rx and Tx on both rising or falling edge of serial clock independently \u2022 8 slave select lines \u2022 Fully static synchronous design with one clock domain \u2022 Technology independent Verilog \u2022 Fully synthesizable OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 2 of 9 2 IO ports 2.1 WISHBONE interface signals Port Width Direction Description wb_clk_i 1 Input Master clock wb_rst_i 1 Input Synchronous reset, active high wb_adr_i 5 Input Lower address bits wb_dat_i 32 Input Data towards the core wb_dat_o 32 Output Data from the core wb_sel_i 4 Input Byte select signals wb_we_i 1 Input Write enable input wb_stb_i 1 Input Strobe signal/Core select input wb_cyc_i 1 Input Valid bus cycle input wb_ack_o 1 Output Bus cycle acknowledge output wb_err_o 1 Output Bus cycle error output wb_int_o 1 Output Interrupt signal output Table 1: Wishbone interface signals All output WISHBONE signals are registered and driven on the rising edge of wb_clk_i. All input WISHBONE signals are latched on the rising edge of wb_clk_i. 2.2 SPI external connections Port Width Direction Description /ss_pad_o 8 Output Slave select output signals sclk_pad_o 1 Output Serial clock output mosi_pad_o 1 Output Master out slave in data signal output miso_pad_i 1 Input Master in slave out data signal input\nGenerate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=1 and CPHA=1. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out );\n",
    "answer_0": "```systemverilog\nmodule SPI_driver (\n    input  logic        clk,\n    input  logic        rst,\n    input  logic [7:0]  data_in,\n    input  logic        SPI_MISO,\n    input  logic        SPI_start,\n    output logic        SPI_MOSI,\n    output logic        SPI_CLK,\n    output logic        SPI_EN,\n    output logic [7:0]  data_out\n);\n\n    // Parameters for CPOL=1, CPHA=1\n    localparam CPOL = 1'b1; // Clock idle high\n    localparam CPHA = 1'b1; // Data sampled on trailing edge\n\n    typedef enum logic [1:0] {\n        IDLE,\n        LOAD,\n        TRANSFER,\n        DONE\n    } state_t;\n\n    state_t state, next_state;\n    logic [2:0] bit_cnt;\n    logic [7:0] shift_reg_tx;\n    logic [7:0] shift_reg_rx;\n    logic       spi_clk_int;\n    logic       spi_clk_en;\n    logic       spi_clk_last;\n\n    // SPI_CLK generation (CPOL=1)\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            spi_clk_int <= CPOL;\n        end else if (spi_clk_en) begin\n            spi_clk_int <= ~spi_clk_int;\n        end else begin\n            spi_clk_int <= CPOL;\n        end\n        spi_clk_last <= spi_clk_int;\n    end\n\n    assign SPI_CLK = spi_clk_int;\n\n    // FSM: Next State Logic\n    always_comb begin\n        next_state = state;\n        unique case (state)\n            IDLE:     if (SPI_start) next_state = LOAD;\n            LOAD:     next_state = TRANSFER;\n            TRANSFER: if (bit_cnt == 3'd7 && spi_clk_int==~CPOL && spi_clk_last==CPOL) next_state = DONE;\n            DONE:     next_state = IDLE;\n            default:  next_state = IDLE;\n        endcase\n    end\n\n    // FSM: State/Output Logic\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state         <= IDLE;\n            shift_reg_tx  <= 8'd0;\n            shift_reg_rx  <= 8'd0;\n            bit_cnt       <= 3'd0;\n            spi_clk_en    <= 1'b0;\n        end else begin\n            state <= next_state;\n            unique case (state)\n                IDLE: begin\n                    SPI_EN      <= 1'b1;        // Inactive, /CS deasserted (active low assumed)\n                    spi_clk_en  <= 1'b0;\n                end\n                LOAD: begin\n                    shift_reg_tx <= data_in;\n                    shift_reg_rx <= 8'd0;\n                    bit_cnt      <= 3'd0;\n                    SPI_EN       <= 1'b0;       // Active, /CS asserted\n                    spi_clk_en   <= 1'b1;\n                    // Start clock toggling with a first falling edge, if required\n                end\n                TRANSFER: begin\n                    SPI_EN     <= 1'b0;\n                    spi_clk_en <= 1'b1;\n                    // SPI_MOSI assignment on leading (first/latching) edge\n                    // SPI_MISO sampled on trailing (second/sampling) edge for CPHA=1, CPOL=1\n                    if (spi_clk_int == CPOL && spi_clk_last == ~CPOL) begin\n                        // Leading edge: Shift data out\n                        SPI_MOSI    <= shift_reg_tx[7];\n                    end\n                    else if (spi_clk_int == ~CPOL && spi_clk_last == CPOL) begin\n                        // Trailing edge: Sample data in and shift left\n                        shift_reg_tx <= {shift_reg_tx[6:0], 1'b0};\n                        shift_reg_rx <= {shift_reg_rx[6:0], SPI_MISO};\n                        if (bit_cnt < 3'd7)\n                            bit_cnt <= bit_cnt + 3'd1;\n                    end\n                end\n                DONE: begin\n                    SPI_EN      <= 1'b1;         // Deassert /CS\n                    spi_clk_en  <= 1'b0;\n                end\n            endcase\n        end\n    end\n\n    // Output Data Register\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            data_out <= 8'd0;\n        end\n        else if (state == DONE) begin\n            data_out <= shift_reg_rx;\n        end\n    end\n\n    // SPI MOSI output control\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            SPI_MOSI <= 1'b0;\n        end else if (state == LOAD) begin\n            SPI_MOSI <= data_in[7];  // MSB first\n        end\n    end\n\nendmodule\n```\n\n**Notes:**\n- `SPI_EN` is assumed to be active low (pulled low to enable the slave). If you need active high, please invert the signal as required.\n- MOSI clocking: For CPOL=1, CPHA=1 \u2014 data is shifted out on the leading edge, sampled on the trailing edge, with the SPI clock idling high.\n- The implementation handles 8-bit transfers (as per your port `data_in`/`data_out` width). Adapt `bit_cnt` and shift registers for other word sizes.\n- This FSM ensures `SPI_start` triggers a transfer, and `data_out` is valid in the `DONE` state (on the next clock).\n- The module does not include any clock divider; it shifts out at the system clock rate. For most apps, you should add a clock division stage to generate proper SCLK frequency.\n\nLet me know if you need automatically generated SCLK with a divider, or a more complex controller!",
    "prompt_1": "The SPI Master core consists of three parts shown in the following figure: Serial Interface spi_shift.v Clock generator spi_clgen.v sclk_pad_o OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 9 of 9 Appendix A Core configuration To meet specific system requirements and size constraints on behalf of the core functionality, the SPI Master core can be configuredby setting the appropriate define directives in the spi_defines.v source file. The directives are as follows: SPI_DIVIDER_BIT_NB This parameter defines the maximum number of bits needed for the divider. Set this parameter accordingly to the maximum system frequency and lowest serial clock frequency: \uf8fa \uf8fb\uf8f9 \uf8ef \uf8f0\uf8ee\u2212\u2217= 12log R_BIT_NB SPI_DIVIDE minmax 2 sclksys ff Default value is 16. SPI_MAX_CHAR This parameter defines the maximum number of bits that can be received/transmitted in one transfer. The default value is 32. SPI_SS_NB This parameter defines the number of slave select lines. The default value is 8.\nTable 8: Slave Select register Reset Value: 0x00000000 SS Writing 1 to any bit location of this field sets the proper ss_pad_o line to an active state. OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 6 of 9 4 Operation This core is an SPI and Microwire/Plus compliant synchronous serial controller. At the host side, it is controlled via registers accessible through a WISHBONE rev. B1 interface. 4.1 WISHBONE interface The SPI core has four 32-bit registers through the WISHBONE rev. B1 compatible interface. All accesses to SPI registers must be 32-bit (wb_sel[3:0] = 0xf). Please refer to the WISHBONE specification at http://www.opencores.org/wishbone/specs/wbspec_b1.pdf 4.2 Serial interface The serial interface consists of slave select lines, serial clock lines, as well as input and output data lines. All transfers are full duplex transfers of a programmable number of bits per transfer (up to 32 bits). Compared to the SPI/Microwire protocol, this core has some additional functionality. It can drive data to the output data line in respect to the falling (SPI/Microwire compliant) or rising edge of the serial clock, and it can latch data on an input data line on the rising (SPI/Microwire compliant) or falling edge of a serial clock line. It also can transmit (receive) the MSB first (SPI/Microwire compliant) or the LSB first. It is important to know that the Rx and Tx registers share the same flip-flops, which means that what is received from the input data line in one transfer will be transmitted on the output data line in the next transfer if no write access to the Tx register is executed between the transfers. /ss_pad_o[0] /ss_pad_o[1] /ss_pad_o[2] MASTER sclk_pad_o mosi_pad_o miso pad i MISO MOSI SCLK /SS SLAVE 0 MISO MOSI SCLK / SS SLAVE 1 MISO MOSI SCLK /SS SLAVE 2 WISHBONE MISO MOSI SCLK/SS SLAVE 0 MISO MOSI SCLK/SS SLAVE 1 MISO MOSI SCLK/SS SLAVE 2 WISHBON E /ss_pad_o[0]/ss_pad_o[1]/ss_pad_o[2] MASTER sclk_pad_o mosi_pad_o miso _pad_iOpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 7 of 9 ss_pad_o mosi_pad_o miso_pad_i CTRL[LSB] = 0, CTRL[CHAR_LEN] = 0x08, CTRL[TX_NEG] = 1, CTRL[RX_NEG] = 0 LSB (Tx[0])ss_pad_o mosi_pad_o miso_pad_i CTRL[LSB] = 1, CTRL[CHAR_LEN] = 0x0a, CTRL[TX_NEG] = 0, CTRL[RX_NEG] = 1 MSB (Tx[9]) MSB (Tx[7]) MSB (Rx[7])LSB (Tx[0]) LSB (Rx[0]) LSB (Rx[0])MSB (Rx[9]) sclk_pad_o sclk_pad_o OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 8 of 9 WHISHBONE SOC Bus WHISHBONE Interface spi_top.v ss_pad_o mosi_pad_o miso_pad_i 5 Architecture The SPI Master core consists of three parts shown in the following figure: Serial Interface spi_shift.v Clock generator spi_clgen.v sclk_pad_o OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 9 of 9 Appendix A Core configuration To meet specific system requirements and size constraints on behalf of the core functionality, the SPI Master core can be configuredby setting the appropriate define directives in the spi_defines.v source file. The directives are as follows: SPI_DIVIDER_BIT_NB This parameter defines the maximum number of bits needed for the divider. Set this parameter accordingly to the maximum system frequency and lowest serial clock frequency: \uf8fa\nSPI Master Core Specification Author: Simon Srot simons@opencores.org Rev. 0.2 July 12, 2002 OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.1 i Revision History Rev. Date Author Description 0.1 June 13, 2002 Simon Srot First Draft 0.2 July 12, 2002 Simon Srot Document is lectured. OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.1 ii Contents CONTENTS.......................................................................................................... II INTRODUCTION................................................................................................. 1 IO PORTS.............................................................................................................. 2 2.1 WISHBONE INTERFACE SIGNALS ................................................................. 2 2.2 SPI EXTERNAL CONNECTIONS ........................................................................ 2 REGISTERS.......................................................................................................... 3 3.1 C ORE REGISTERS LIST .................................................................................... 3 3.2 D ATA RECEIVE REGISTER [RX]....................................................................... 3 3.3 D ATA TRANSMIT REGISTER [TX] .................................................................... 3 3.4 C ONTROL AND STATUS REGISTER [CTRL] ..................................................... 4 3.5 D IVIDER REGISTER [DIVIDER] ..................................................................... 5 3.6 S LAVE SELECT REGISTER [SS]........................................................................ 5 OPERATION......................................................................................................... 6 4.1 WISHBONE INTERFACE ............................................................................... 6 4.2 S ERIAL INTERFACE ......................................................................................... 6 ARCHITECTURE ................................................................................................ 8 CORE CONFIGURATION ................................................................................. 9 OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 1 of 9 1 Introduction This document provides specifications for the SPI (Serial Peripheral Interface) Master core. Synchronous serial interfaces are widely used to provide economical board-level interfaces between different devices such as microcontrollers, DACs, ADCs and other. Although there is no single standard for a synchronous serial bus, there are industry-wide accepted guidelines based on two most popular implementations: \u2022 SPI (a trademark of Motorola Semiconductor) \u2022 Microwire/Plus (a trademark of National Semiconductor) Many IC manufacturers produce components that are compatible with SPI and Microwire/Plus. The SPI Master core is compatible with both above-mentioned protocols as master with some additional functionality. At the hosts side, the core acts like a WISHBONE compliant slave device. Features: \u2022 Full duplex synchronous serial data transfer \u2022 Variable length of transfer word up to 32 bits \u2022 MSB or LSB first data transfer \u2022 Rx and Tx on both rising or falling edge of serial clock independently \u2022 8 slave select lines \u2022 Fully static synchronous design with one clock domain \u2022 Technology independent Verilog \u2022 Fully synthesizable OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 2 of 9 2 IO ports 2.1 WISHBONE interface signals Port Width Direction Description wb_clk_i 1 Input Master clock wb_rst_i 1 Input Synchronous reset, active high wb_adr_i 5 Input Lower address bits wb_dat_i 32 Input Data towards the core wb_dat_o 32 Output Data from the core wb_sel_i 4 Input Byte select signals wb_we_i 1 Input Write enable input wb_stb_i 1 Input Strobe signal/Core select input wb_cyc_i 1 Input Valid bus cycle input wb_ack_o 1 Output Bus cycle acknowledge output wb_err_o 1 Output Bus cycle error output wb_int_o 1 Output Interrupt signal output Table 1: Wishbone interface signals All output WISHBONE signals are registered and driven on the rising edge of wb_clk_i. All input WISHBONE signals are latched on the rising edge of wb_clk_i. 2.2 SPI external connections Port Width Direction Description /ss_pad_o 8 Output Slave select output signals sclk_pad_o 1 Output Serial clock output mosi_pad_o 1 Output Master out slave in data signal output miso_pad_i 1 Input Master in slave out data signal input\nGenerate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=1 and CPHA=0. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out );\n",
    "answer_1": "```systemverilog\nmodule SPI_driver(\n    input  logic        clk,\n    input  logic        rst,\n    input  logic [7:0]  data_in,\n    input  logic        SPI_MISO,\n    input  logic        SPI_start,\n    output logic        SPI_MOSI,\n    output logic        SPI_CLK,\n    output logic        SPI_EN,\n    output logic [7:0]  data_out\n);\n\n    // Parameters: CPOL=1 (idle high), CPHA=0 (data changes on trailing, sampled on leading edge)\n    parameter CPOL = 1;\n    parameter CPHA = 0;\n    parameter DATA_WIDTH = 8;\n\n    typedef enum logic [1:0] {\n        IDLE,\n        LOAD,\n        TRANSFER,\n        DONE\n    } spi_state_t;\n\n    spi_state_t state, next_state;\n\n    logic [DATA_WIDTH-1:0] shift_reg;\n    logic [DATA_WIDTH-1:0] recv_reg;\n    logic [3:0]            bit_cnt;\n    logic                  sclk;\n    logic                  sclk_int;\n    logic                  en;\n\n    // Clock Divider for SPI (Assume SCLK is half freq of clk for simplicity)\n    logic clk_div;\n    always_ff @(posedge clk or posedge rst) begin\n        if(rst) begin\n            clk_div <= 1'b0;\n        end else if (en && state==TRANSFER) begin\n            clk_div <= ~clk_div;\n        end else begin\n            clk_div <= 1'b0;\n        end\n    end\n\n    // Edge detect for sampling and shifting\n    logic clk_div_r;\n    always_ff @(posedge clk or posedge rst) begin\n        if(rst) clk_div_r <= CPOL;\n        else    clk_div_r <= clk_div;\n    end\n\n    wire sclk_posedge = (clk_div == 1'b1) && (clk_div_r == 1'b0);\n    wire sclk_negedge = (clk_div == 1'b0) && (clk_div_r == 1'b1);\n\n    // State Machine\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always_comb begin\n        next_state = state;\n        case (state)\n            IDLE:    if (SPI_start) next_state = LOAD;\n            LOAD:    next_state = TRANSFER;\n            TRANSFER:if (bit_cnt == DATA_WIDTH) next_state = DONE;\n            DONE:    next_state = IDLE;\n        endcase\n    end\n\n    // Control logic\n    always_ff @(posedge clk or posedge rst) begin\n        if(rst) begin\n            shift_reg <= '0;\n            recv_reg  <= '0;\n            bit_cnt   <= '0;\n            sclk      <= CPOL;\n            en        <= 1'b0;\n            data_out  <= 8'h00;\n        end else begin\n            case(state)\n                IDLE: begin\n                    shift_reg <= data_in;\n                    recv_reg  <= '0;\n                    bit_cnt   <= 4'd0;\n                    sclk      <= CPOL;\n                    en        <= 1'b0;\n                end\n                LOAD: begin\n                    shift_reg <= data_in;\n                    bit_cnt   <= 4'd0;\n                    sclk      <= CPOL;\n                    en        <= 1'b1;\n                end\n                TRANSFER: begin\n                    en <= 1'b1;\n                    // For CPOL=1, idle is high. CPHA=0, sample on leading, shift on trailing.\n                    // Leading edge for CPOL=1 is falling edge.\n                    if(sclk_negedge) begin\n                        // Shift out data on trailing edge\n                        shift_reg <= {shift_reg[DATA_WIDTH-2:0], 1'b0};\n                        bit_cnt   <= bit_cnt + 1'b1;\n                    end\n                    if(sclk_posedge) begin\n                        // Sample data in on leading edge\n                        recv_reg <= {recv_reg[DATA_WIDTH-2:0], SPI_MISO};\n                    end\n                    // Toggle SCLK in transfer state only\n                    sclk <= clk_div;\n                end\n                DONE: begin\n                    data_out <= recv_reg;\n                    en       <= 1'b0;\n                    sclk     <= CPOL;\n                end\n            endcase\n        end\n    end\n\n    // Outputs\n    assign SPI_CLK = (state == TRANSFER) ? sclk : CPOL;\n    assign SPI_EN  = en;\n    assign SPI_MOSI= shift_reg[DATA_WIDTH-1];\n\nendmodule\n```\n\n**Notes:**  \n- **SPI_CLK** is high in idle (CPOL=1), toggles only during TRANSFER.\n- **SPI_EN** goes high during LOAD and TRANSFER, asserted low otherwise.\n- **SPI_MOSI** presents MSB first.  \n- **data_out** holds received byte after DONE state.\n- Designed for `CPOL=1, CPHA=0` (MISO sampled on falling-to-rising edge, MOSI updated on rising-to-falling edge).\n- Driver initiates transfer on `SPI_start=1`. Transfer is full-duplex, 8 bits, master-only.\n\nLet me know if you need it modified for a different SPI mode or width!",
    "prompt_2": "The SPI Master core consists of three parts shown in the following figure: Serial Interface spi_shift.v Clock generator spi_clgen.v sclk_pad_o OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 9 of 9 Appendix A Core configuration To meet specific system requirements and size constraints on behalf of the core functionality, the SPI Master core can be configuredby setting the appropriate define directives in the spi_defines.v source file. The directives are as follows: SPI_DIVIDER_BIT_NB This parameter defines the maximum number of bits needed for the divider. Set this parameter accordingly to the maximum system frequency and lowest serial clock frequency: \uf8fa \uf8fb\uf8f9 \uf8ef \uf8f0\uf8ee\u2212\u2217= 12log R_BIT_NB SPI_DIVIDE minmax 2 sclksys ff Default value is 16. SPI_MAX_CHAR This parameter defines the maximum number of bits that can be received/transmitted in one transfer. The default value is 32. SPI_SS_NB This parameter defines the number of slave select lines. The default value is 8.\nTable 8: Slave Select register Reset Value: 0x00000000 SS Writing 1 to any bit location of this field sets the proper ss_pad_o line to an active state. OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 6 of 9 4 Operation This core is an SPI and Microwire/Plus compliant synchronous serial controller. At the host side, it is controlled via registers accessible through a WISHBONE rev. B1 interface. 4.1 WISHBONE interface The SPI core has four 32-bit registers through the WISHBONE rev. B1 compatible interface. All accesses to SPI registers must be 32-bit (wb_sel[3:0] = 0xf). Please refer to the WISHBONE specification at http://www.opencores.org/wishbone/specs/wbspec_b1.pdf 4.2 Serial interface The serial interface consists of slave select lines, serial clock lines, as well as input and output data lines. All transfers are full duplex transfers of a programmable number of bits per transfer (up to 32 bits). Compared to the SPI/Microwire protocol, this core has some additional functionality. It can drive data to the output data line in respect to the falling (SPI/Microwire compliant) or rising edge of the serial clock, and it can latch data on an input data line on the rising (SPI/Microwire compliant) or falling edge of a serial clock line. It also can transmit (receive) the MSB first (SPI/Microwire compliant) or the LSB first. It is important to know that the Rx and Tx registers share the same flip-flops, which means that what is received from the input data line in one transfer will be transmitted on the output data line in the next transfer if no write access to the Tx register is executed between the transfers. /ss_pad_o[0] /ss_pad_o[1] /ss_pad_o[2] MASTER sclk_pad_o mosi_pad_o miso pad i MISO MOSI SCLK /SS SLAVE 0 MISO MOSI SCLK / SS SLAVE 1 MISO MOSI SCLK /SS SLAVE 2 WISHBONE MISO MOSI SCLK/SS SLAVE 0 MISO MOSI SCLK/SS SLAVE 1 MISO MOSI SCLK/SS SLAVE 2 WISHBON E /ss_pad_o[0]/ss_pad_o[1]/ss_pad_o[2] MASTER sclk_pad_o mosi_pad_o miso _pad_iOpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 7 of 9 ss_pad_o mosi_pad_o miso_pad_i CTRL[LSB] = 0, CTRL[CHAR_LEN] = 0x08, CTRL[TX_NEG] = 1, CTRL[RX_NEG] = 0 LSB (Tx[0])ss_pad_o mosi_pad_o miso_pad_i CTRL[LSB] = 1, CTRL[CHAR_LEN] = 0x0a, CTRL[TX_NEG] = 0, CTRL[RX_NEG] = 1 MSB (Tx[9]) MSB (Tx[7]) MSB (Rx[7])LSB (Tx[0]) LSB (Rx[0]) LSB (Rx[0])MSB (Rx[9]) sclk_pad_o sclk_pad_o OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 8 of 9 WHISHBONE SOC Bus WHISHBONE Interface spi_top.v ss_pad_o mosi_pad_o miso_pad_i 5 Architecture The SPI Master core consists of three parts shown in the following figure: Serial Interface spi_shift.v Clock generator spi_clgen.v sclk_pad_o OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 9 of 9 Appendix A Core configuration To meet specific system requirements and size constraints on behalf of the core functionality, the SPI Master core can be configuredby setting the appropriate define directives in the spi_defines.v source file. The directives are as follows: SPI_DIVIDER_BIT_NB This parameter defines the maximum number of bits needed for the divider. Set this parameter accordingly to the maximum system frequency and lowest serial clock frequency: \uf8fa\nSPI Master Core Specification Author: Simon Srot simons@opencores.org Rev. 0.2 July 12, 2002 OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.1 i Revision History Rev. Date Author Description 0.1 June 13, 2002 Simon Srot First Draft 0.2 July 12, 2002 Simon Srot Document is lectured. OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.1 ii Contents CONTENTS.......................................................................................................... II INTRODUCTION................................................................................................. 1 IO PORTS.............................................................................................................. 2 2.1 WISHBONE INTERFACE SIGNALS ................................................................. 2 2.2 SPI EXTERNAL CONNECTIONS ........................................................................ 2 REGISTERS.......................................................................................................... 3 3.1 C ORE REGISTERS LIST .................................................................................... 3 3.2 D ATA RECEIVE REGISTER [RX]....................................................................... 3 3.3 D ATA TRANSMIT REGISTER [TX] .................................................................... 3 3.4 C ONTROL AND STATUS REGISTER [CTRL] ..................................................... 4 3.5 D IVIDER REGISTER [DIVIDER] ..................................................................... 5 3.6 S LAVE SELECT REGISTER [SS]........................................................................ 5 OPERATION......................................................................................................... 6 4.1 WISHBONE INTERFACE ............................................................................... 6 4.2 S ERIAL INTERFACE ......................................................................................... 6 ARCHITECTURE ................................................................................................ 8 CORE CONFIGURATION ................................................................................. 9 OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 1 of 9 1 Introduction This document provides specifications for the SPI (Serial Peripheral Interface) Master core. Synchronous serial interfaces are widely used to provide economical board-level interfaces between different devices such as microcontrollers, DACs, ADCs and other. Although there is no single standard for a synchronous serial bus, there are industry-wide accepted guidelines based on two most popular implementations: \u2022 SPI (a trademark of Motorola Semiconductor) \u2022 Microwire/Plus (a trademark of National Semiconductor) Many IC manufacturers produce components that are compatible with SPI and Microwire/Plus. The SPI Master core is compatible with both above-mentioned protocols as master with some additional functionality. At the hosts side, the core acts like a WISHBONE compliant slave device. Features: \u2022 Full duplex synchronous serial data transfer \u2022 Variable length of transfer word up to 32 bits \u2022 MSB or LSB first data transfer \u2022 Rx and Tx on both rising or falling edge of serial clock independently \u2022 8 slave select lines \u2022 Fully static synchronous design with one clock domain \u2022 Technology independent Verilog \u2022 Fully synthesizable OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 2 of 9 2 IO ports 2.1 WISHBONE interface signals Port Width Direction Description wb_clk_i 1 Input Master clock wb_rst_i 1 Input Synchronous reset, active high wb_adr_i 5 Input Lower address bits wb_dat_i 32 Input Data towards the core wb_dat_o 32 Output Data from the core wb_sel_i 4 Input Byte select signals wb_we_i 1 Input Write enable input wb_stb_i 1 Input Strobe signal/Core select input wb_cyc_i 1 Input Valid bus cycle input wb_ack_o 1 Output Bus cycle acknowledge output wb_err_o 1 Output Bus cycle error output wb_int_o 1 Output Interrupt signal output Table 1: Wishbone interface signals All output WISHBONE signals are registered and driven on the rising edge of wb_clk_i. All input WISHBONE signals are latched on the rising edge of wb_clk_i. 2.2 SPI external connections Port Width Direction Description /ss_pad_o 8 Output Slave select output signals sclk_pad_o 1 Output Serial clock output mosi_pad_o 1 Output Master out slave in data signal output miso_pad_i 1 Input Master in slave out data signal input\nGenerate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=0 and CPHA=1. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out );\n",
    "answer_2": "```systemverilog\n// Simple SPI Master Driver (CPOL=0, CPHA=1)\n// Assumptions: \n// - 8-bit transfers\n// - Single transfer per SPI_start pulse\n// - CPOL=0: Clock idle low, data changes on trailing edge, sampled on leading edge\n// - CPHA=1: Data changes on leading clk edge, sampled on trailing edge (relative to SPI_CLK)\n// - SPI_EN is active low (active-low slave select)\n\n/*\nParameters for CPOL=0, CPHA=1:\nIdle:       SCLK = 0, SS = 1 (inactive)\nStart:      SS goes 0, SCLK = 0 before first edge\nFirst edge: SCLK rising (data sampled)\nData valid: After rising edge, before falling edge\nData change: MOSI on falling edge, sample MISO on rising edge\n*/\n\nmodule SPI_driver(\n    input  logic        clk,          // system clk\n    input  logic        rst,          // synchronous reset\n    input  logic [7:0]  data_in,      // data to send (MSB first)\n    input  logic        SPI_MISO,     // MISO signal from slave\n    input  logic        SPI_start,    // one-clock strobe to start transfer\n    output logic        SPI_MOSI,     // MOSI to slave\n    output logic        SPI_CLK,      // SCLK to slave\n    output logic        SPI_EN,       // active low SS/EN to slave\n    output logic [7:0]  data_out      // data received from slave (MSB first)\n);\n\n    typedef enum logic [1:0] {\n        IDLE,\n        ASSERT_SS,\n        TRANSFER,\n        DEASSERT_SS\n    } state_t;\n\n    state_t state, next_state;\n\n    logic [7:0] shift_out;\n    logic [7:0] shift_in;\n    logic [2:0] bit_cnt;\n    logic       sclk;\n    logic       sclk_en;\n    logic       sclk_rise;\n    logic       sclk_fall;\n\n    // SPI Clock Divider (Change as needed for slower SPI)\n    // Here we run SPI_CLK at clk/2 (one clk cycle = half SCLK period)\n    logic [0:0] clk_div; // 1-bit toggle for clk/2\n\n    // SCLK clocking\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            clk_div <= 1'b0;\n        end else if (sclk_en) begin\n            clk_div <= ~clk_div;\n        end else begin\n            clk_div <= 1'b0;\n        end\n    end\n\n    assign sclk = (state == TRANSFER && sclk_en) ? clk_div : 1'b0;\n\n    // Generate SPI_CLK output (CPOL=0)\n    assign SPI_CLK = sclk;\n\n    // Generate SPI_EN (active low): SS goes low only during TRANSFER or ASSERT_SS\n    assign SPI_EN = ~((state == ASSERT_SS) || (state == TRANSFER));\n\n    // Edge detection for SCLK (within TRANSFER state)\n    always_comb begin\n        sclk_rise = 0;\n        sclk_fall = 0;\n        if (state == TRANSFER && sclk_en) begin\n            if (clk_div == 1'b1) // rising edge just happened\n                sclk_rise = 1;\n            else // falling edge just happened\n                sclk_fall = 1;\n        end\n    end\n\n    // FSM: State transitions\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n\n    always_comb begin\n        next_state = state;\n        case (state)\n            IDLE:         next_state = SPI_start ? ASSERT_SS : IDLE;\n            ASSERT_SS:    next_state = TRANSFER;\n            TRANSFER:     next_state = (bit_cnt == 3'd7 && sclk_rise) ? DEASSERT_SS : TRANSFER;\n            DEASSERT_SS:  next_state = IDLE;\n        endcase\n    end\n\n    // Bit Counter and SCLK control\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            bit_cnt   <= 3'd0;\n            sclk_en   <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    bit_cnt <= 3'd0;\n                    sclk_en <= 1'b0;\n                end\n                ASSERT_SS: begin\n                    bit_cnt <= 3'd0;\n                    sclk_en <= 1'b1;\n                end\n                TRANSFER: begin\n                    sclk_en <= 1'b1;\n                    if (sclk_rise) begin\n                        if (bit_cnt != 3'd7)\n                            bit_cnt <= bit_cnt + 3'd1;\n                        else\n                            bit_cnt <= bit_cnt;\n                    end\n                end\n                DEASSERT_SS: begin\n                    sclk_en <= 1'b0;\n                end\n            endcase\n        end\n    end\n\n    // Output shift register (drive MOSI on SCLK falling edge, sample MISO on SCLK rising edge)\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            shift_out <= 8'h00;\n            shift_in  <= 8'h00;\n            SPI_MOSI  <= 1'b0;\n        end else begin\n            case (state)\n                IDLE: begin\n                    shift_out <= data_in;\n                    shift_in  <= 8'h00;\n                    SPI_MOSI  <= data_in[7]; // MSB (first)\n                end\n                ASSERT_SS: begin\n                    shift_out <= data_in;\n                    shift_in  <= 8'h00;\n                    SPI_MOSI  <= data_in[7];\n                end\n                TRANSFER: begin\n                    // Change data at falling edge (CPHA=1)\n                    if (sclk_fall) begin\n                        shift_out <= {shift_out[6:0], 1'b0}; // shift out next bit\n                        SPI_MOSI  <= shift_out[6];          // next MSB\n                    end\n                    // Sample at rising edge (CPHA=1)\n                    if (sclk_rise) begin\n                        shift_in <= {shift_in[6:0], SPI_MISO}; // shift in at MSB first\n                    end\n                end\n                default: ;\n            endcase\n        end\n    end\n\n    // Latch data_out after transfer finished\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            data_out <= 8'h00;\n        end else if (state == DEASSERT_SS) begin\n            data_out <= shift_in;\n        end\n    end\n\nendmodule\n```\n\n**Notes:**\n- This SPI driver acts as a master and supports single transaction per `SPI_start` pulse.\n- **CPOL=0, CPHA=1:** Data is output on MOSI on SCLK falling edge, MISO is sampled on SCLK rising edge. (Idle clock state is low.)\n- `SPI_EN` is active-low: goes low during transfer.\n- Data is sent MSB first, but can be inverted if LSB first is needed.\n- The system clock is divided by 2 for SCLK. You may replace this with a parameter for different speeds.\n- The module is simple, for clarity, and for a real system extra error handling and handshaking may be desired.\n",
    "prompt_3": "The SPI Master core consists of three parts shown in the following figure: Serial Interface spi_shift.v Clock generator spi_clgen.v sclk_pad_o OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 9 of 9 Appendix A Core configuration To meet specific system requirements and size constraints on behalf of the core functionality, the SPI Master core can be configuredby setting the appropriate define directives in the spi_defines.v source file. The directives are as follows: SPI_DIVIDER_BIT_NB This parameter defines the maximum number of bits needed for the divider. Set this parameter accordingly to the maximum system frequency and lowest serial clock frequency: \uf8fa \uf8fb\uf8f9 \uf8ef \uf8f0\uf8ee\u2212\u2217= 12log R_BIT_NB SPI_DIVIDE minmax 2 sclksys ff Default value is 16. SPI_MAX_CHAR This parameter defines the maximum number of bits that can be received/transmitted in one transfer. The default value is 32. SPI_SS_NB This parameter defines the number of slave select lines. The default value is 8.\nTable 8: Slave Select register Reset Value: 0x00000000 SS Writing 1 to any bit location of this field sets the proper ss_pad_o line to an active state. OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 6 of 9 4 Operation This core is an SPI and Microwire/Plus compliant synchronous serial controller. At the host side, it is controlled via registers accessible through a WISHBONE rev. B1 interface. 4.1 WISHBONE interface The SPI core has four 32-bit registers through the WISHBONE rev. B1 compatible interface. All accesses to SPI registers must be 32-bit (wb_sel[3:0] = 0xf). Please refer to the WISHBONE specification at http://www.opencores.org/wishbone/specs/wbspec_b1.pdf 4.2 Serial interface The serial interface consists of slave select lines, serial clock lines, as well as input and output data lines. All transfers are full duplex transfers of a programmable number of bits per transfer (up to 32 bits). Compared to the SPI/Microwire protocol, this core has some additional functionality. It can drive data to the output data line in respect to the falling (SPI/Microwire compliant) or rising edge of the serial clock, and it can latch data on an input data line on the rising (SPI/Microwire compliant) or falling edge of a serial clock line. It also can transmit (receive) the MSB first (SPI/Microwire compliant) or the LSB first. It is important to know that the Rx and Tx registers share the same flip-flops, which means that what is received from the input data line in one transfer will be transmitted on the output data line in the next transfer if no write access to the Tx register is executed between the transfers. /ss_pad_o[0] /ss_pad_o[1] /ss_pad_o[2] MASTER sclk_pad_o mosi_pad_o miso pad i MISO MOSI SCLK /SS SLAVE 0 MISO MOSI SCLK / SS SLAVE 1 MISO MOSI SCLK /SS SLAVE 2 WISHBONE MISO MOSI SCLK/SS SLAVE 0 MISO MOSI SCLK/SS SLAVE 1 MISO MOSI SCLK/SS SLAVE 2 WISHBON E /ss_pad_o[0]/ss_pad_o[1]/ss_pad_o[2] MASTER sclk_pad_o mosi_pad_o miso _pad_iOpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 7 of 9 ss_pad_o mosi_pad_o miso_pad_i CTRL[LSB] = 0, CTRL[CHAR_LEN] = 0x08, CTRL[TX_NEG] = 1, CTRL[RX_NEG] = 0 LSB (Tx[0])ss_pad_o mosi_pad_o miso_pad_i CTRL[LSB] = 1, CTRL[CHAR_LEN] = 0x0a, CTRL[TX_NEG] = 0, CTRL[RX_NEG] = 1 MSB (Tx[9]) MSB (Tx[7]) MSB (Rx[7])LSB (Tx[0]) LSB (Rx[0]) LSB (Rx[0])MSB (Rx[9]) sclk_pad_o sclk_pad_o OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 8 of 9 WHISHBONE SOC Bus WHISHBONE Interface spi_top.v ss_pad_o mosi_pad_o miso_pad_i 5 Architecture The SPI Master core consists of three parts shown in the following figure: Serial Interface spi_shift.v Clock generator spi_clgen.v sclk_pad_o OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 9 of 9 Appendix A Core configuration To meet specific system requirements and size constraints on behalf of the core functionality, the SPI Master core can be configuredby setting the appropriate define directives in the spi_defines.v source file. The directives are as follows: SPI_DIVIDER_BIT_NB This parameter defines the maximum number of bits needed for the divider. Set this parameter accordingly to the maximum system frequency and lowest serial clock frequency: \uf8fa\nSPI Master Core Specification Author: Simon Srot simons@opencores.org Rev. 0.2 July 12, 2002 OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.1 i Revision History Rev. Date Author Description 0.1 June 13, 2002 Simon Srot First Draft 0.2 July 12, 2002 Simon Srot Document is lectured. OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.1 ii Contents CONTENTS.......................................................................................................... II INTRODUCTION................................................................................................. 1 IO PORTS.............................................................................................................. 2 2.1 WISHBONE INTERFACE SIGNALS ................................................................. 2 2.2 SPI EXTERNAL CONNECTIONS ........................................................................ 2 REGISTERS.......................................................................................................... 3 3.1 C ORE REGISTERS LIST .................................................................................... 3 3.2 D ATA RECEIVE REGISTER [RX]....................................................................... 3 3.3 D ATA TRANSMIT REGISTER [TX] .................................................................... 3 3.4 C ONTROL AND STATUS REGISTER [CTRL] ..................................................... 4 3.5 D IVIDER REGISTER [DIVIDER] ..................................................................... 5 3.6 S LAVE SELECT REGISTER [SS]........................................................................ 5 OPERATION......................................................................................................... 6 4.1 WISHBONE INTERFACE ............................................................................... 6 4.2 S ERIAL INTERFACE ......................................................................................... 6 ARCHITECTURE ................................................................................................ 8 CORE CONFIGURATION ................................................................................. 9 OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 1 of 9 1 Introduction This document provides specifications for the SPI (Serial Peripheral Interface) Master core. Synchronous serial interfaces are widely used to provide economical board-level interfaces between different devices such as microcontrollers, DACs, ADCs and other. Although there is no single standard for a synchronous serial bus, there are industry-wide accepted guidelines based on two most popular implementations: \u2022 SPI (a trademark of Motorola Semiconductor) \u2022 Microwire/Plus (a trademark of National Semiconductor) Many IC manufacturers produce components that are compatible with SPI and Microwire/Plus. The SPI Master core is compatible with both above-mentioned protocols as master with some additional functionality. At the hosts side, the core acts like a WISHBONE compliant slave device. Features: \u2022 Full duplex synchronous serial data transfer \u2022 Variable length of transfer word up to 32 bits \u2022 MSB or LSB first data transfer \u2022 Rx and Tx on both rising or falling edge of serial clock independently \u2022 8 slave select lines \u2022 Fully static synchronous design with one clock domain \u2022 Technology independent Verilog \u2022 Fully synthesizable OpenCores SPI Master Core Specification 12.7.2002 www.opencores.org Rev 0.2 2 of 9 2 IO ports 2.1 WISHBONE interface signals Port Width Direction Description wb_clk_i 1 Input Master clock wb_rst_i 1 Input Synchronous reset, active high wb_adr_i 5 Input Lower address bits wb_dat_i 32 Input Data towards the core wb_dat_o 32 Output Data from the core wb_sel_i 4 Input Byte select signals wb_we_i 1 Input Write enable input wb_stb_i 1 Input Strobe signal/Core select input wb_cyc_i 1 Input Valid bus cycle input wb_ack_o 1 Output Bus cycle acknowledge output wb_err_o 1 Output Bus cycle error output wb_int_o 1 Output Interrupt signal output Table 1: Wishbone interface signals All output WISHBONE signals are registered and driven on the rising edge of wb_clk_i. All input WISHBONE signals are latched on the rising edge of wb_clk_i. 2.2 SPI external connections Port Width Direction Description /ss_pad_o 8 Output Slave select output signals sclk_pad_o 1 Output Serial clock output mosi_pad_o 1 Output Master out slave in data signal output miso_pad_i 1 Input Master in slave out data signal input\nGenerate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=0 and CPHA=0. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out );\n",
    "answer_3": "```systemverilog\nmodule SPI_driver(\n    input  logic        clk,\n    input  logic        rst,\n    input  logic [7:0]  data_in,\n    input  logic        SPI_MISO,\n    input  logic        SPI_start,\n    output logic        SPI_MOSI,\n    output logic        SPI_CLK,\n    output logic        SPI_EN,\n    output logic [7:0]  data_out\n);\n\n    // SPI parameters\n    // CPOL = 0: Clock idle low\n    // CPHA = 0: Data sampled on leading (rising) edge (so data must be stable on falling edge)\n\n    typedef enum logic [1:0] {\n        IDLE, \n        LOAD, \n        TRANSFER, \n        DONE\n    } state_t;\n\n    state_t state, next_state;\n\n    logic [7:0] shift_reg_tx;\n    logic [7:0] shift_reg_rx;\n    logic [2:0] bit_cnt;\n    logic       sclk_int;\n    logic       sclk_en;\n    logic       mosi_int;\n    logic       en_int;\n\n    // SPI clock generation (one SCLK cycle per bit)\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            sclk_int  <= 1'b0;\n            sclk_en   <= 1'b0;\n        end else if (state == TRANSFER) begin\n            sclk_en   <= 1'b1;\n            sclk_int  <= ~sclk_int;\n        end else begin\n            sclk_int  <= 1'b0; // Idle low for CPOL=0\n            sclk_en   <= 1'b0;\n        end\n    end\n\n    // FSM\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state       <= IDLE;\n            bit_cnt     <= 3'd7;\n            shift_reg_tx<= 8'd0;\n            shift_reg_rx<= 8'd0;\n            en_int      <= 1'b0;\n            mosi_int    <= 1'b0;\n            data_out    <= 8'd0;\n        end else begin\n            state <= next_state;\n            case (state)\n                IDLE: begin\n                    en_int      <= 1'b1; // SPI_EN active low (assume active low user can invert as needed)\n                    shift_reg_rx<= 8'd0;\n                    if (SPI_start) begin\n                        shift_reg_tx <= data_in;\n                        bit_cnt      <= 3'd7;\n                        mosi_int     <= data_in[7];\n                    end else begin\n                        mosi_int     <= 1'b0;\n                    end\n                end\n                LOAD: begin\n                    en_int   <= 1'b0; // select slave (active low)\n                    mosi_int <= shift_reg_tx[7];\n                end\n                TRANSFER: begin\n                    en_int <= 1'b0;\n                    // SCLK transitions -- CPOL=0, CPHA=0: sample on rising edge\n                    if (sclk_en && sclk_int==1'b1) begin  // rising edge: sample input\n                        shift_reg_rx <= {shift_reg_rx[6:0], SPI_MISO};\n                        if (bit_cnt==0) begin\n                            data_out <= {shift_reg_rx[6:0], SPI_MISO};\n                        end\n                    end\n                    if (sclk_en && sclk_int==1'b0) begin  // falling edge: change MOSI\n                        if (bit_cnt != 0) begin\n                            shift_reg_tx <= {shift_reg_tx[6:0], 1'b0};\n                            mosi_int     <= shift_reg_tx[6];\n                            bit_cnt      <= bit_cnt - 3'd1;\n                        end\n                    end\n                end\n                DONE: begin\n                    en_int   <= 1'b1; // deselect slave\n                    mosi_int <= 1'b0;\n                end\n            endcase\n        end\n    end\n\n    // Next state logic\n    always_comb begin\n        next_state = state;\n        case (state)\n            IDLE:      if (SPI_start) next_state = LOAD;\n            LOAD:      next_state = TRANSFER;\n            TRANSFER:  if ((bit_cnt==0) && (sclk_en && sclk_int==1'b1)) next_state = DONE;\n            DONE:      next_state = IDLE;\n        endcase\n    end\n\n    // Outputs\n    assign SPI_MOSI = mosi_int;\n    assign SPI_EN   = en_int;\n    assign SPI_CLK  = sclk_int;\n\nendmodule\n```"
}
