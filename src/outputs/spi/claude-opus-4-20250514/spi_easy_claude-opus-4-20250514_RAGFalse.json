{
    "prompt_0": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=1 and CPHA=1. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out );\n",
    "answer_0": "Here's a SystemVerilog SPI master driver with CPOL=1 and CPHA=1:\n\n```systemverilog\nmodule SPI_driver(\n    input  logic       clk,\n    input  logic       rst,\n    input  logic [7:0] data_in,\n    input  logic       SPI_MISO,\n    input  logic       SPI_start,\n    output logic       SPI_MOSI,\n    output logic       SPI_CLK,\n    output logic       SPI_EN,\n    output logic [7:0] data_out\n);\n\n    // State machine states\n    typedef enum logic [1:0] {\n        IDLE   = 2'b00,\n        LOAD   = 2'b01,\n        SHIFT  = 2'b10,\n        DONE   = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Internal registers\n    logic [7:0] tx_shift_reg;\n    logic [7:0] rx_shift_reg;\n    logic [3:0] bit_counter;\n    logic [3:0] clk_divider;\n    logic       spi_clk_edge;\n    logic       tx_latch;\n\n    // Parameters for clock division (adjust as needed)\n    parameter CLK_DIV = 4'd4;  // Divide system clock by 4 for SPI clock\n\n    // Clock divider for SPI_CLK generation\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            clk_divider <= 4'd0;\n        end else if (current_state == SHIFT) begin\n            if (clk_divider == CLK_DIV - 1) begin\n                clk_divider <= 4'd0;\n            end else begin\n                clk_divider <= clk_divider + 1'b1;\n            end\n        end else begin\n            clk_divider <= 4'd0;\n        end\n    end\n\n    // Generate SPI clock edge signal\n    assign spi_clk_edge = (clk_divider == CLK_DIV/2 - 1) || (clk_divider == CLK_DIV - 1);\n\n    // State machine\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // Next state logic\n    always_comb begin\n        next_state = current_state;\n        case (current_state)\n            IDLE: begin\n                if (SPI_start) begin\n                    next_state = LOAD;\n                end\n            end\n            LOAD: begin\n                next_state = SHIFT;\n            end\n            SHIFT: begin\n                if (bit_counter == 4'd8 && clk_divider == CLK_DIV - 1) begin\n                    next_state = DONE;\n                end\n            end\n            DONE: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Bit counter\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            bit_counter <= 4'd0;\n        end else if (current_state == LOAD) begin\n            bit_counter <= 4'd0;\n        end else if (current_state == SHIFT && clk_divider == CLK_DIV - 1) begin\n            bit_counter <= bit_counter + 1'b1;\n        end\n    end\n\n    // Shift registers and data handling\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tx_shift_reg <= 8'd0;\n            rx_shift_reg <= 8'd0;\n            tx_latch <= 1'b0;\n        end else begin\n            case (current_state)\n                LOAD: begin\n                    tx_shift_reg <= data_in;\n                    rx_shift_reg <= 8'd0;\n                end\n                SHIFT: begin\n                    if (spi_clk_edge && clk_divider == CLK_DIV/2 - 1) begin\n                        // Sample on first edge (CPHA=1)\n                        rx_shift_reg <= {rx_shift_reg[6:0], SPI_MISO};\n                    end else if (spi_clk_edge && clk_divider == CLK_DIV - 1) begin\n                        // Shift on second edge (CPHA=1)\n                        tx_shift_reg <= {tx_shift_reg[6:0], 1'b0};\n                        tx_latch <= tx_shift_reg[6];\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output assignments\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            SPI_CLK <= 1'b1;  // CPOL=1: idle high\n            SPI_EN <= 1'b1;   // Active low chip select\n            data_out <= 8'd0;\n        end else begin\n            case (current_state)\n                IDLE: begin\n                    SPI_CLK <= 1'b1;  // CPOL=1: idle high\n                    SPI_EN <= 1'b1;\n                end\n                LOAD: begin\n                    SPI_EN <= 1'b0;  // Assert chip select\n                end\n                SHIFT: begin\n                    // Toggle clock for CPOL=1\n                    if (clk_divider < CLK_DIV/2) begin\n                        SPI_CLK <= 1'b0;  // First half: low\n                    end else begin\n                        SPI_CLK <= 1'b1;  // Second half: high\n                    end\n                end\n                DONE: begin\n                    SPI_CLK <= 1'b1;  // Return to idle high\n                    SPI_EN <= 1'b1;   // Deassert chip select\n                    data_out <= rx_shift_reg;\n                end\n            endcase\n        end\n    end\n\n    // MOSI output - update on second edge for CPHA=1\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            SPI_MOSI <= 1'b0;\n        end else if (current_state == LOAD) begin\n            SPI_MOSI <= data_in[7];  // Prepare first bit\n        end else if (current_state == SHIFT && clk_divider == CLK_DIV - 1 && bit_counter < 4'd8) begin\n            SPI_MOSI <= tx_latch;\n        end\n    end\n\nendmodule\n```\n\nThis SPI master driver implements:\n\n1. **CPOL=1**: SPI clock idles high\n2. **CPHA=1**: Data is sampled on the first clock edge (falling edge) and shifted out on the second clock edge (rising edge)\n3. **8-bit data transfer**: MSB first\n4. **Active-low chip select** (SPI_EN)\n5. **Configurable clock divider** to generate SPI clock from system clock\n6. **State machine** with IDLE, LOAD, SHIFT, and DONE states\n\nKey features:\n- The module waits for `SPI_start` to begin a transfer\n- Data is loaded from `data_in` when starting\n- Received data is available on `data_out` after completion\n- The SPI clock frequency is system clock divided by CLK_DIV parameter\n- Full-duplex operation (simultaneous transmit and receive)\n\nYou can adjust the `CLK_DIV` parameter to change the SPI clock frequency relative to your system clock.",
    "prompt_1": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=1 and CPHA=0. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out );\n",
    "answer_1": "Here's a SystemVerilog SPI master driver with CPOL=1 and CPHA=0:\n\n```systemverilog\nmodule SPI_driver(\n    input  logic       clk,\n    input  logic       rst,\n    input  logic [7:0] data_in,\n    input  logic       SPI_MISO,\n    input  logic       SPI_start,\n    output logic       SPI_MOSI,\n    output logic       SPI_CLK,\n    output logic       SPI_EN,\n    output logic [7:0] data_out\n);\n\n    // Parameters\n    parameter CLK_DIV = 4;  // Clock divider (SPI_CLK = clk/CLK_DIV)\n    \n    // State machine states\n    typedef enum logic [1:0] {\n        IDLE    = 2'b00,\n        ACTIVE  = 2'b01,\n        DONE    = 2'b10\n    } state_t;\n    \n    state_t state, next_state;\n    \n    // Internal signals\n    logic [7:0] tx_data_reg;\n    logic [7:0] rx_data_reg;\n    logic [2:0] bit_counter;\n    logic [$clog2(CLK_DIV)-1:0] clk_divider;\n    logic spi_clk_edge;\n    logic transfer_done;\n    \n    // Clock divider for SPI_CLK generation\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            clk_divider <= '0;\n        end else if (state == ACTIVE) begin\n            if (clk_divider == CLK_DIV/2 - 1) begin\n                clk_divider <= '0;\n            end else begin\n                clk_divider <= clk_divider + 1'b1;\n            end\n        end else begin\n            clk_divider <= '0;\n        end\n    end\n    \n    // Generate SPI clock edge signal\n    assign spi_clk_edge = (clk_divider == CLK_DIV/2 - 1);\n    \n    // State machine\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            state <= IDLE;\n        end else begin\n            state <= next_state;\n        end\n    end\n    \n    // Next state logic\n    always_comb begin\n        next_state = state;\n        case (state)\n            IDLE: begin\n                if (SPI_start) begin\n                    next_state = ACTIVE;\n                end\n            end\n            ACTIVE: begin\n                if (transfer_done) begin\n                    next_state = DONE;\n                end\n            end\n            DONE: begin\n                next_state = IDLE;\n            end\n            default: next_state = IDLE;\n        endcase\n    end\n    \n    // Bit counter and transfer control\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            bit_counter <= 3'b0;\n            transfer_done <= 1'b0;\n        end else begin\n            if (state == IDLE) begin\n                bit_counter <= 3'b0;\n                transfer_done <= 1'b0;\n            end else if (state == ACTIVE && spi_clk_edge) begin\n                if (bit_counter == 3'd7) begin\n                    transfer_done <= 1'b1;\n                end else begin\n                    bit_counter <= bit_counter + 1'b1;\n                end\n            end\n        end\n    end\n    \n    // Data registers\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            tx_data_reg <= 8'h00;\n            rx_data_reg <= 8'h00;\n        end else begin\n            if (state == IDLE && SPI_start) begin\n                tx_data_reg <= data_in;\n            end else if (state == ACTIVE && spi_clk_edge) begin\n                // CPHA=0: Sample on leading edge (falling edge for CPOL=1)\n                rx_data_reg <= {rx_data_reg[6:0], SPI_MISO};\n                // Shift tx data for next bit\n                tx_data_reg <= {tx_data_reg[6:0], 1'b0};\n            end\n        end\n    end\n    \n    // SPI_CLK generation (CPOL=1: idle high)\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            SPI_CLK <= 1'b1;  // CPOL=1: idle high\n        end else begin\n            if (state == ACTIVE) begin\n                if (clk_divider < CLK_DIV/2) begin\n                    SPI_CLK <= 1'b0;  // Low phase\n                end else begin\n                    SPI_CLK <= 1'b1;  // High phase\n                end\n            end else begin\n                SPI_CLK <= 1'b1;  // CPOL=1: idle high\n            end\n        end\n    end\n    \n    // Output assignments\n    assign SPI_MOSI = (state == ACTIVE) ? tx_data_reg[7] : 1'b0;\n    assign SPI_EN = (state != IDLE);\n    assign data_out = rx_data_reg;\n\nendmodule\n```\n\nThis SPI master driver implements the following features:\n\n1. **CPOL=1, CPHA=0 Configuration**:\n   - Clock idles high (CPOL=1)\n   - Data is sampled on the falling edge (leading edge)\n   - Data changes on the rising edge (trailing edge)\n\n2. **State Machine**:\n   - IDLE: Waiting for SPI_start signal\n   - ACTIVE: Transferring data\n   - DONE: Transfer complete (single cycle state)\n\n3. **Clock Division**:\n   - Parameterizable clock divider to generate slower SPI clock\n   - Default divider is 4 (SPI_CLK = clk/4)\n\n4. **Data Transfer**:\n   - 8-bit serial transfer (MSB first)\n   - Simultaneous transmit and receive\n   - SPI_EN signal active during transfer\n\n5. **Operation**:\n   - Assert SPI_start with valid data_in\n   - Driver shifts out data_in on MOSI while capturing MISO data\n   - After 8 bits, received data is available on data_out\n   - SPI_EN goes low when transfer completes\n\nThe timing follows standard SPI mode 2 (CPOL=1, CPHA=0) where data is captured on the falling edge of the clock and propagated on the rising edge.",
    "prompt_2": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=0 and CPHA=1. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out );\n",
    "answer_2": "Here's a complete SPI master driver in SystemVerilog with CPOL=0 and CPHA=1:\n\n```systemverilog\nmodule SPI_driver(\n    input  logic       clk,\n    input  logic       rst,\n    input  logic [7:0] data_in,\n    input  logic       SPI_MISO,\n    input  logic       SPI_start,\n    output logic       SPI_MOSI,\n    output logic       SPI_CLK,\n    output logic       SPI_EN,\n    output logic [7:0] data_out\n);\n\n    // State machine states\n    typedef enum logic [1:0] {\n        IDLE    = 2'b00,\n        LOAD    = 2'b01,\n        SHIFT   = 2'b10,\n        DONE    = 2'b11\n    } state_t;\n    \n    state_t current_state, next_state;\n    \n    // Internal registers\n    logic [7:0] shift_reg_tx;  // Transmit shift register\n    logic [7:0] shift_reg_rx;  // Receive shift register\n    logic [2:0] bit_counter;    // Counts bits (0-7)\n    logic       spi_clk_reg;    // Internal SPI clock register\n    logic       first_edge;     // Tracks first edge in CPHA=1\n    \n    // Clock divider counter (adjust for desired SPI clock frequency)\n    logic [3:0] clk_divider;\n    parameter CLK_DIV = 4'd4;   // Divide system clock by 4\n    \n    // State machine - sequential logic\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n    \n    // State machine - combinational logic\n    always_comb begin\n        next_state = current_state;\n        \n        case (current_state)\n            IDLE: begin\n                if (SPI_start) begin\n                    next_state = LOAD;\n                end\n            end\n            \n            LOAD: begin\n                next_state = SHIFT;\n            end\n            \n            SHIFT: begin\n                if (bit_counter == 3'd7 && clk_divider == CLK_DIV-1 && !spi_clk_reg) begin\n                    next_state = DONE;\n                end\n            end\n            \n            DONE: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n    \n    // Clock divider and bit counter\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            clk_divider <= 4'd0;\n            bit_counter <= 3'd0;\n            first_edge  <= 1'b0;\n        end else begin\n            case (current_state)\n                IDLE: begin\n                    clk_divider <= 4'd0;\n                    bit_counter <= 3'd0;\n                    first_edge  <= 1'b0;\n                end\n                \n                LOAD: begin\n                    clk_divider <= 4'd0;\n                    bit_counter <= 3'd0;\n                    first_edge  <= 1'b1;  // Set for first edge handling\n                end\n                \n                SHIFT: begin\n                    if (clk_divider == CLK_DIV-1) begin\n                        clk_divider <= 4'd0;\n                        \n                        // For CPHA=1, increment bit counter on falling edge\n                        if (!spi_clk_reg) begin\n                            if (!first_edge) begin\n                                bit_counter <= bit_counter + 1'b1;\n                            end else begin\n                                first_edge <= 1'b0;\n                            end\n                        end\n                    end else begin\n                        clk_divider <= clk_divider + 1'b1;\n                    end\n                end\n                \n                default: begin\n                    clk_divider <= 4'd0;\n                    bit_counter <= 3'd0;\n                    first_edge  <= 1'b0;\n                end\n            endcase\n        end\n    end\n    \n    // SPI clock generation (CPOL=0)\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            spi_clk_reg <= 1'b0;  // CPOL=0: clock idle low\n        end else begin\n            case (current_state)\n                SHIFT: begin\n                    if (clk_divider == CLK_DIV-1) begin\n                        spi_clk_reg <= ~spi_clk_reg;\n                    end\n                end\n                default: begin\n                    spi_clk_reg <= 1'b0;  // CPOL=0: clock idle low\n                end\n            endcase\n        end\n    end\n    \n    // Shift registers for TX and RX\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            shift_reg_tx <= 8'd0;\n            shift_reg_rx <= 8'd0;\n        end else begin\n            case (current_state)\n                LOAD: begin\n                    shift_reg_tx <= data_in;\n                    shift_reg_rx <= 8'd0;\n                end\n                \n                SHIFT: begin\n                    if (clk_divider == CLK_DIV-1) begin\n                        // CPHA=1: Sample on rising edge, shift on falling edge\n                        if (spi_clk_reg) begin  // Rising edge\n                            shift_reg_rx <= {shift_reg_rx[6:0], SPI_MISO};\n                        end else begin  // Falling edge\n                            if (!first_edge) begin\n                                shift_reg_tx <= {shift_reg_tx[6:0], 1'b0};\n                            end\n                        end\n                    end\n                end\n            endcase\n        end\n    end\n    \n    // Output data register\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            data_out <= 8'd0;\n        end else begin\n            if (current_state == DONE) begin\n                data_out <= shift_reg_rx;\n            end\n        end\n    end\n    \n    // Output assignments\n    assign SPI_CLK = spi_clk_reg;\n    assign SPI_MOSI = shift_reg_tx[7];  // MSB first\n    assign SPI_EN = (current_state == IDLE) ? 1'b1 : 1'b0;  // Active low chip select\n\nendmodule\n```\n\nThis SPI master driver implementation features:\n\n**Key Characteristics (CPOL=0, CPHA=1):**\n- Clock idle state is LOW (CPOL=0)\n- Data is sampled on the rising edge of SPI_CLK\n- Data is shifted out on the falling edge of SPI_CLK\n- MSB is transmitted first\n\n**Features:**\n1. **State Machine**: Four states (IDLE, LOAD, SHIFT, DONE) control the SPI transaction\n2. **Clock Divider**: Generates SPI clock from system clock (adjustable via CLK_DIV parameter)\n3. **Bit Counter**: Tracks the 8 bits being transmitted/received\n4. **Shift Registers**: Separate registers for transmit and receive data\n5. **Chip Select (SPI_EN)**: Active low, asserted during transmission\n\n**Operation:**\n1. Assert `SPI_start` with valid `data_in` to begin transmission\n2. The module loads data, asserts chip select (SPI_EN goes low)\n3. Shifts out 8 bits on MOSI while simultaneously reading MISO\n4. After 8 bits, deasserts chip select and updates `data_out`\n5. Returns to IDLE state, ready for next transaction\n\n**Timing Diagram (CPHA=1):**\n- First clock edge (rising) samples the first bit\n- Subsequent falling edges shift out new data\n- Rising edges sample incoming data\n\nYou can adjust the `CLK_DIV` parameter to change the SPI clock frequency relative to your system clock.",
    "prompt_3": "Generate a SPI driver in system verilog with the following structure, and given that we want its parameters as CPOL=0 and CPHA=0. This SPI driver should be able to act as the master.. module SPI_driver( input logic clk, input logic rst, input logic [7:0] data_in, input logic SPI_MISO, Input logic SPI_start, output logic SPI_MOSI, output logic SPI_CLK, output logic SPI_EN, output logic [7:0] data_out );\n",
    "answer_3": "Here's a SystemVerilog SPI master driver with CPOL=0 and CPHA=0:\n\n```systemverilog\nmodule SPI_driver(\n    input  logic       clk,\n    input  logic       rst,\n    input  logic [7:0] data_in,\n    input  logic       SPI_MISO,\n    input  logic       SPI_start,\n    output logic       SPI_MOSI,\n    output logic       SPI_CLK,\n    output logic       SPI_EN,\n    output logic [7:0] data_out\n);\n\n    // State machine states\n    typedef enum logic [1:0] {\n        IDLE    = 2'b00,\n        LOAD    = 2'b01,\n        SHIFT   = 2'b10,\n        DONE    = 2'b11\n    } state_t;\n\n    state_t current_state, next_state;\n\n    // Internal registers\n    logic [7:0] shift_reg_out;  // Shift register for output data\n    logic [7:0] shift_reg_in;   // Shift register for input data\n    logic [3:0] bit_counter;     // Counter for bits (0-7)\n    logic       spi_clk_reg;     // Internal SPI clock register\n    logic       clk_enable;      // Enable for clock generation\n\n    // Clock divider counter (adjust for desired SPI frequency)\n    logic [3:0] clk_divider;\n    parameter CLK_DIV = 4'd4;    // Divide system clock by 4 for SPI clock\n\n    // State machine - sequential logic\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            current_state <= IDLE;\n        end else begin\n            current_state <= next_state;\n        end\n    end\n\n    // State machine - combinational logic\n    always_comb begin\n        next_state = current_state;\n        \n        case (current_state)\n            IDLE: begin\n                if (SPI_start)\n                    next_state = LOAD;\n            end\n            \n            LOAD: begin\n                next_state = SHIFT;\n            end\n            \n            SHIFT: begin\n                if (bit_counter == 4'd8 && clk_divider == CLK_DIV - 1'b1)\n                    next_state = DONE;\n            end\n            \n            DONE: begin\n                next_state = IDLE;\n            end\n        endcase\n    end\n\n    // Clock divider and bit counter\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            clk_divider <= 4'd0;\n            bit_counter <= 4'd0;\n        end else begin\n            if (current_state == SHIFT) begin\n                if (clk_divider == CLK_DIV - 1'b1) begin\n                    clk_divider <= 4'd0;\n                    if (spi_clk_reg == 1'b1) begin  // Count on falling edge of SPI_CLK\n                        bit_counter <= bit_counter + 1'b1;\n                    end\n                end else begin\n                    clk_divider <= clk_divider + 1'b1;\n                end\n            end else begin\n                clk_divider <= 4'd0;\n                bit_counter <= 4'd0;\n            end\n        end\n    end\n\n    // SPI clock generation (CPOL=0: idle low)\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            spi_clk_reg <= 1'b0;\n        end else begin\n            if (current_state == SHIFT) begin\n                if (clk_divider == (CLK_DIV >> 1) - 1'b1)\n                    spi_clk_reg <= 1'b1;\n                else if (clk_divider == CLK_DIV - 1'b1)\n                    spi_clk_reg <= 1'b0;\n            end else begin\n                spi_clk_reg <= 1'b0;  // CPOL=0: idle low\n            end\n        end\n    end\n\n    // Shift registers and data handling\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            shift_reg_out <= 8'd0;\n            shift_reg_in  <= 8'd0;\n        end else begin\n            case (current_state)\n                LOAD: begin\n                    shift_reg_out <= data_in;\n                    shift_reg_in  <= 8'd0;\n                end\n                \n                SHIFT: begin\n                    // CPHA=0: Sample on leading (rising) edge, shift on trailing (falling) edge\n                    if (clk_divider == (CLK_DIV >> 1) - 1'b1) begin\n                        // Sample MISO on rising edge of SPI_CLK\n                        shift_reg_in <= {shift_reg_in[6:0], SPI_MISO};\n                    end\n                    else if (clk_divider == CLK_DIV - 1'b1) begin\n                        // Shift out data on falling edge of SPI_CLK\n                        shift_reg_out <= {shift_reg_out[6:0], 1'b0};\n                    end\n                end\n            endcase\n        end\n    end\n\n    // Output assignments\n    assign SPI_CLK = spi_clk_reg;\n    assign SPI_EN = (current_state != IDLE);  // Active during transmission\n    assign SPI_MOSI = shift_reg_out[7];       // MSB first\n\n    // Capture received data\n    always_ff @(posedge clk or posedge rst) begin\n        if (rst) begin\n            data_out <= 8'd0;\n        end else begin\n            if (current_state == DONE) begin\n                data_out <= shift_reg_in;\n            end\n        end\n    end\n\nendmodule\n```\n\nThis SPI master driver implements:\n\n**Key Features:**\n1. **CPOL=0**: Clock idles low\n2. **CPHA=0**: Data is sampled on the rising edge and shifted on the falling edge\n3. **8-bit data transfer**: MSB first\n4. **Configurable clock divider**: Adjust `CLK_DIV` parameter for desired SPI frequency\n5. **State machine**: IDLE \u2192 LOAD \u2192 SHIFT \u2192 DONE\n\n**Operation:**\n1. Assert `SPI_start` to begin transmission\n2. `data_in` is loaded into the shift register\n3. `SPI_EN` goes high to indicate active transmission\n4. Data is shifted out on `SPI_MOSI` while simultaneously reading `SPI_MISO`\n5. After 8 bits, received data is available on `data_out`\n6. `SPI_EN` returns low when complete\n\n**Timing (CPOL=0, CPHA=0):**\n- Data changes on falling edge of SPI_CLK\n- Data is sampled on rising edge of SPI_CLK\n- First bit is available on MOSI before the first clock edge"
}
